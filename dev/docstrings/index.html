<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · KomaMRI.jl: General MRI simulation framework</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/extra-styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="KomaMRI.jl: General MRI simulation framework logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="KomaMRI.jl: General MRI simulation framework logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../ui-details/">Graphical User Interface</a></li><li><a class="tocitem" href="../simulation-examples/">Examples</a></li><li><a class="tocitem" href="../mri-theory/">Simulation Method</a></li><li><a class="tocitem" href="../api/">API Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cncastillo/KomaMRI.jl/blob/master/docs/src/docstrings.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><h2 id="dataflow-graph"><a class="docs-heading-anchor" href="#dataflow-graph">Dataflow Graph</a><a id="dataflow-graph-1"></a><a class="docs-heading-anchor-permalink" href="#dataflow-graph" title="Permalink"></a></h2><p><img src="../assets/dataflow.svg" alt/></p><ul><li><a href="#API-Documentation">API Documentation</a></li><li class="no-marker"><ul><li><a href="#dataflow-graph">Dataflow Graph</a></li><li><a href="#datatypes">DataTypes</a></li><li class="no-marker"><ul><li><a href="#Mag"><code>Mag</code></a></li><li><a href="#Phantom"><code>Phantom</code></a></li><li><a href="#Scanner"><code>Scanner</code></a></li><li><a href="#Sequence"><code>Sequence</code></a></li><li><a href="#Grad"><code>Grad</code></a></li><li><a href="#RF"><code>RF</code></a></li><li><a href="#ADC"><code>ADC</code></a></li><li><a href="#Delay"><code>Delay</code></a></li></ul></li><li><a href="#pulseq">Pulseq.jl</a></li><li class="no-marker"><ul><li><a href="#read_Grad"><code>read_Grad</code></a></li><li><a href="#read_RF"><code>read_RF</code></a></li><li><a href="#read_ADC"><code>read_ADC</code></a></li><li><a href="#get_block"><code>get_block</code></a></li></ul></li><li><a href="#jemris">JEMRIS.jl</a></li><li class="no-marker"><ul><li><a href="#read_phantom_jemris"><code>read_phantom_jemris</code></a></li></ul></li><li><a href="#ismrmrd">ISMRMRD.jl</a></li><li class="no-marker"><ul><li><a href="#signal_to_raw_data"><code>signal_to_raw_data</code></a></li></ul></li><li><a href="#pulse-designer">PulseDesigner.jl</a></li><li><a href="#key-values-calculation">KeyValuesCalculation.jl</a></li><li class="no-marker"><ul><li><a href="#get_theo_A"><code>get_theo_A</code></a></li><li><a href="#get_theo_t"><code>get_theo_t</code></a></li><li><a href="#get_theo_Gi"><code>get_theo_Gi</code></a></li></ul></li><li><a href="#trapezoidal-integration">TrapezoidalIntegration.jl</a></li><li class="no-marker"><ul><li><a href="#trapz"><code>trapz</code></a></li><li><a href="#cumtrapz"><code>cumtrapz</code></a></li></ul></li><li><a href="#time-step-calculation">TimeStepCalculation.jl</a></li><li class="no-marker"><ul><li><a href="#points_from_key_times"><code>points_from_key_times</code></a></li><li><a href="#get_variable_times"><code>get_variable_times</code></a></li><li><a href="#get_uniform_times"><code>get_uniform_times</code></a></li><li><a href="#kfoldperm"><code>kfoldperm</code></a></li><li><a href="#get_breaks_in_RF_key_points"><code>get_breaks_in_RF_key_points</code></a></li></ul></li><li><a href="#simulation-core">SimulationCore.jl</a></li><li class="no-marker"><ul><li><a href="#print_gpus"><code>print_gpus</code></a></li><li><a href="#run_spin_precession"><code>run_spin_precession</code></a></li><li><a href="#run_spin_precession_parallel"><code>run_spin_precession_parallel</code></a></li><li><a href="#run_spin_excitation"><code>run_spin_excitation</code></a></li><li><a href="#run_spin_excitation_parallel"><code>run_spin_excitation_parallel</code></a></li><li><a href="#run_sim_time_iter"><code>run_sim_time_iter</code></a></li></ul></li><li><a href="#display-functions">DisplayFunctions.jl</a></li><li class="no-marker"><ul><li><a href="#theme_chooser"><code>theme_chooser</code></a></li><li><a href="#interp_map"><code>interp_map</code></a></li><li><a href="#plot_dict"><code>plot_dict</code></a></li></ul></li></ul></li></ul><h2 id="datatypes"><a class="docs-heading-anchor" href="#datatypes">DataTypes</a><a id="datatypes-1"></a><a class="docs-heading-anchor-permalink" href="#datatypes" title="Permalink"></a></h2><h3 id="Mag"><a class="docs-heading-anchor" href="#Mag"><code>Mag</code></a><a id="Mag-1"></a><a class="docs-heading-anchor-permalink" href="#Mag" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Mag" href="#KomaMRI.Mag"><code>KomaMRI.Mag</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mag = Mag(xy::Complex, z::Real)</code></pre><p>The Magnetization struct.</p><p><strong>Arguments</strong></p><ul><li><code>xy</code>: (<code>::Complex{Int64}</code>) the magnetization of a spin in the xy plane</li><li><code>z</code>: (<code>::Real</code>) the magnetization of a spin in the z plane</li></ul><p><strong>Returns</strong></p><ul><li><code>mag</code>: (<code>::Mag</code>) the Magnetization struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/simulation/Magnetization.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Mag-Tuple{Phantom, Symbol}" href="#KomaMRI.Mag-Tuple{Phantom, Symbol}"><code>KomaMRI.Mag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mag = Mag(p::Phantom, dir::Symbol)</code></pre><p>Generates a Vector of Mag structs with the information of the <code>p</code> panthom struct (the proton density) in the axis given by the <code>dir</code> symbol.</p><p><strong>Arguments</strong></p><ul><li><code>p</code>: (<code>::Phantom</code>) the phantom struct</li><li><code>dir</code>: (<code>::Symbol</code>, opts: [<code>:x</code>, <code>:z</code>]) the symbol that represents the axis of the   magnetization</li></ul><p><strong>Returns</strong></p><ul><li><code>mag</code>: (<code>Vector{Mag}</code>) the vector of Magnetization structs</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; obj = Phantom(x=zeros(5));

julia&gt; mag = Mag(obj, :z)
5-element Vector{Mag}:
 Mag(xy = 0.0 + 0.0im, z = 1.0)
 Mag(xy = 0.0 + 0.0im, z = 1.0)
 Mag(xy = 0.0 + 0.0im, z = 1.0)
 Mag(xy = 0.0 + 0.0im, z = 1.0)
 Mag(xy = 0.0 + 0.0im, z = 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/simulation/Magnetization.jl#L18-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, Mag}" href="#Base.show-Tuple{IO, Mag}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">str = show(io::IO, x::Mag)</code></pre><p>Displays information about the Mag struct <code>x</code> in the julia REPL.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Mag</code>) the Magnetization struct</li></ul><p><strong>Returns</strong></p><ul><li><code>str</code> (<code>::String</code>) the output string message</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/simulation/Magnetization.jl#L47-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty-Tuple{Vector{Mag}, Symbol}" href="#Base.getproperty-Tuple{Vector{Mag}, Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = getproperty(x::Vector{Mag}, f::Symbol)</code></pre><p>Overchages Base.getproperty(). It is meant to access properties of the Mag vector <code>x</code> directly without needing to iterate elementwise.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Vector{Mag}</code>) the vector of Mag structs</li><li><code>f</code>: (<code>::Symbol</code>, opts: [<code>:xy</code>, <code>:z</code>]) the symbol that represents a property of a Mag   struct</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Vector{Any}</code>) the vector with the property defined by the <code>f</code> symbol for all   elements of the Mag vector <code>x</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/simulation/Magnetization.jl#L62-L76">source</a></section></article><h3 id="Phantom"><a class="docs-heading-anchor" href="#Phantom"><code>Phantom</code></a><a id="Phantom-1"></a><a class="docs-heading-anchor-permalink" href="#Phantom" title="Permalink"></a></h3><p>Refer to <a href="../api/#Phantom">API Documentation</a>:</p><ul><li><a href="../api/#KomaMRI.Phantom"><code>KomaMRI.Phantom</code></a> — Type</li><li><a href="../api/#KomaMRI.brain_phantom2D"><code>KomaMRI.brain_phantom2D</code></a> — Function</li><li><a href="../api/#KomaMRI.brain_phantom3D"><code>KomaMRI.brain_phantom3D</code></a> — Function</li></ul><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.heart_phantom" href="#KomaMRI.heart_phantom"><code>KomaMRI.heart_phantom</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phantom = heart_phantom(α=1, β=1, γ=1, fat_bool::Bool=false)</code></pre><p>Heart-like LV phantom. The variable <code>α</code> is for streching, <code>β</code> for contraction, and <code>γ</code> for rotation.</p><p><strong>Arguments</strong></p><ul><li><code>α</code>: (<code>::Real</code>, <code>=1</code>) the streching parameter</li><li><code>β</code>: (<code>::Real</code>, <code>=1</code>) the contraction parameter</li><li><code>γ</code>: (<code>::Real</code>, <code>=1</code>) the rotation parameter</li><li><code>fat_bool</code>: (<code>::Bool</code>, <code>=false</code>) the fat boolean parameter</li></ul><p><strong>Returns</strong></p><ul><li><code>phantom</code>: (<code>::Phantom</code>) the Heart-like LV phantom struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Phantom.jl#L153-L167">source</a></section></article><h3 id="Scanner"><a class="docs-heading-anchor" href="#Scanner"><code>Scanner</code></a><a id="Scanner-1"></a><a class="docs-heading-anchor-permalink" href="#Scanner" title="Permalink"></a></h3><p>Refer to <a href="../api/#Scanner">API Documentation</a>:</p><ul><li><a href="../api/#KomaMRI.Scanner"><code>KomaMRI.Scanner</code></a> — Type</li></ul><h3 id="Sequence"><a class="docs-heading-anchor" href="#Sequence"><code>Sequence</code></a><a id="Sequence-1"></a><a class="docs-heading-anchor-permalink" href="#Sequence" title="Permalink"></a></h3><p>Refer to <a href="../api/#Sequence">API Documentation</a>:</p><ul><li><a href="../api/#KomaMRI.Sequence"><code>KomaMRI.Sequence</code></a> — Type</li></ul><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, Sequence}" href="#Base.show-Tuple{IO, Sequence}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">str = show(io::IO, s::Sequence)</code></pre><p>Displays information about the Sequence struct <code>s</code> in the julia REPL.</p><p><strong>Arguments</strong></p><ul><li><code>s</code>: (<code>::Sequence</code>) the Sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>str</code> (<code>::String</code>) the output string message</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L107-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.is_ADC_on" href="#KomaMRI.is_ADC_on"><code>KomaMRI.is_ADC_on</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y = is_ADC_on(x::Sequence)
y = is_ADC_on(x::Sequence, t::Union{Array{Float64,1}, Array{Float64,2}})</code></pre><p>Tells if the sequence <code>seq</code> has elements with ADC active, or active during time <code>t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>t</code>: (<code>::Union{Array{Float64,1}, Array{Float64,2}}</code>, <code>[s]</code>) the time to check</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Bool</code>) the boolean that tells whether or not the ADC in the sequence is active</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L162-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.is_RF_on" href="#KomaMRI.is_RF_on"><code>KomaMRI.is_RF_on</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y = is_RF_on(x::Sequence)
y = is_RF_on(x::Sequence, t::Vector{Float64})</code></pre><p>Tells if the sequence <code>seq</code> has elements with RF active, or active during time <code>t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>t</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the time to check</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Bool</code>) the boolean that tells whether or not the RF in the sequence is active</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L192-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.is_GR_on" href="#KomaMRI.is_GR_on"><code>KomaMRI.is_GR_on</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y = is_GR_on(x::Sequence)</code></pre><p>Tells if the sequence <code>seq</code> has elements with GR active.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Bool</code>) the boolean that tells whether or not the GR in the sequence is active</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L222-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.is_Gx_on" href="#KomaMRI.is_Gx_on"><code>KomaMRI.is_Gx_on</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y = is_Gx_on(x::Sequence)</code></pre><p>Tells if the sequence <code>seq</code> has elements with GR active in x direction.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Bool</code>) the boolean that tells whether or not the GRx in the sequence is active</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L235-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.is_Gy_on" href="#KomaMRI.is_Gy_on"><code>KomaMRI.is_Gy_on</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y = is_Gy_on(x::Sequence)</code></pre><p>Tells if the sequence <code>seq</code> has elements with GR active in y direction.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Bool</code>) the boolean that tells whether or not the GRy in the sequence is active</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L248-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.is_Gz_on" href="#KomaMRI.is_Gz_on"><code>KomaMRI.is_Gz_on</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y = is_Gz_on(x::Sequence)</code></pre><p>Tells if the sequence <code>seq</code> has elements with GR active in z direction.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Bool</code>) the boolean that tells whether or not the GRz in the sequence is active</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L261-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.is_Delay" href="#KomaMRI.is_Delay"><code>KomaMRI.is_Delay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y = is_Delay(x::Sequence)</code></pre><p>Tells if the sequence <code>seq</code> is a delay.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>y::Bool</code>: the boolean that tells whether or not the sequence is a delay</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L274-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.durs-Tuple{Sequence}" href="#KomaMRI.durs-Tuple{Sequence}"><code>KomaMRI.durs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ΔT = durs(x::Sequence)</code></pre><p>Returns the array of durations of sequence&#39;s blocks in [s].</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>ΔT</code>: (<code>::Vector{Real}</code>, <code>[s]</code>) the array of durations of sequence&#39;s blocks</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L287-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.dur-Tuple{Sequence}" href="#KomaMRI.dur-Tuple{Sequence}"><code>KomaMRI.dur</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T = dur(x::Sequence)</code></pre><p>The total duration of the sequence in [s].</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>T</code>: (<code>::Real</code>, <code>[s]</code>) the total duration of the sequence</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L307-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.⏢" href="#KomaMRI.⏢"><code>KomaMRI.⏢</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y = ⏢(A, t, ΔT, ζ1, ζ2, delay)</code></pre><p>Generates a trapezoidal waveform vector.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: (<code>::Real</code>) the amplitude</li><li><code>t</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the times to evaluate (actually it&#39;s a <code>1-row   ::Matrix{Float64}</code>)</li><li><code>ΔT</code>: (<code>::Real</code>, <code>[s]</code>) the time duration of the top-flat</li><li><code>ζ1</code>: (<code>::Real</code>, <code>[s]</code>) the rise time duration</li><li><code>ζ2</code>: (<code>::Real</code>, <code>[s]</code>) the fall time duration</li><li><code>delay</code>: (<code>::Real</code>, <code>[s]</code>) the delay time</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Vector{Float64}</code>) the trapezoidal waveform (actually it&#39;s a <code>1-row   ::Matrix{Float64}</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L320-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_grads" href="#KomaMRI.get_grads"><code>KomaMRI.get_grads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Gx, Gy, Gz = get_grads(seq, t::Vector)
Gx, Gy, Gz = get_grads(seq, t::Matrix)</code></pre><p>Get the gradient array from sequence <code>seq</code> evaluated in time points <code>t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>t</code>: (<code>::Vector{Float64}</code> or <code>1-row ::Matrix{Float64}</code>, <code>[s]</code>) the times to evaluate</li></ul><p><strong>Returns</strong></p><ul><li><code>Gx</code>: (<code>Vector{Float64}</code> or <code>1-row ::Matrix{Float64}</code>, <code>[T]</code>) the gradient vector values   in the x direction</li><li><code>Gy</code>: (<code>Vector{Float64}</code> or <code>1-row ::Matrix{Float64}</code>, <code>[T]</code>) the gradient vector values   in the y direction</li><li><code>Gz</code>: (<code>Vector{Float64}</code> or <code>1-row ::Matrix{Float64}</code>, <code>[T]</code>) the gradient vector values   in the z direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L364-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_rfs" href="#KomaMRI.get_rfs"><code>KomaMRI.get_rfs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">B1, Δf_rf  = get_rfs(seq::Sequence, t)</code></pre><p>Returns the RF pulses and the delta frequency.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>t</code>: (<code>1-row ::Matrix{Float64}</code>, <code>[s]</code>) the time points</li></ul><p><strong>Returns</strong></p><ul><li><code>B1</code>: (<code>1-row ::Matrix{ComplexF64}</code>, <code>[T]</code>) the vector of RF pulses</li><li><code>Δf_rf</code>: (<code>1-row ::Matrix{Float64}</code>, <code>[Hz]</code>) the delta frequency vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L416-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_flip_angles" href="#KomaMRI.get_flip_angles"><code>KomaMRI.get_flip_angles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y = get_flip_angles(x::Sequence)</code></pre><p>Returns all the flip angles of the RF pulses in the sequence <code>x</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Vector{Float64}</code>, <code>[deg]</code>) the flip angles</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L442-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_ADC_on" href="#KomaMRI.get_ADC_on"><code>KomaMRI.get_ADC_on</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y = get_ADC_on(seq::Sequence, t::Array{Float64,1})</code></pre><p>Get the ADC struct that are active.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is not being used.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>t</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the time vector</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Vector{Bool}</code>) the ADC struct that are active</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L455-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_kspace" href="#KomaMRI.get_kspace"><code>KomaMRI.get_kspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kspace, kspace_adc = get_kspace(seq::Sequence; Δt=1)</code></pre><p>Outputs designed k-space trajectory from sequence struct.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>Δt</code>: (<code>::Real</code>, <code>=1</code>, <code>[s]</code>) the nominal delta time separation between two time samples   for ADC acquisition and Gradients</li></ul><p><strong>Returns</strong></p><ul><li><code>kspace</code>: (<code>3-column ::Matrix{Float64}</code>) the kspace</li><li><code>kspace_adc</code>: (<code>3-column ::Matrix{Float64}</code>) the adc kspace</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L689-L702">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_RF_types" href="#KomaMRI.get_RF_types"><code>KomaMRI.get_RF_types</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rf_idx, rf_type = get_RF_types(seq, t)</code></pre><p>Get RF centers and types (excitation or precession). Useful for k-space calculations.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>t</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the time values</li></ul><p><strong>Returns</strong></p><ul><li><code>rf_idx</code>: (<code>::Vector{Int64}</code>) the indices of the RF centers</li><li><code>rf_type</code>: (<code>::Vector{Int64}</code>, opts: [<code>0</code>, <code>1</code>]) the RF type (<code>0</code>: excitation, <code>1</code>:   precession)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/Sequence.jl#L653-L666">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>KomaMRI.δ2N</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="Grad"><a class="docs-heading-anchor" href="#Grad"><code>Grad</code></a><a id="Grad-1"></a><a class="docs-heading-anchor-permalink" href="#Grad" title="Permalink"></a></h3><p>Refer to <a href="../api/#Grad">API Documentation</a>:</p><ul><li><a href="../api/#KomaMRI.Grad"><code>KomaMRI.Grad</code></a> — Type</li><li><a href="../api/#KomaMRI.Grad-Tuple{Function, Real, Int64}"><code>KomaMRI.Grad(::Function, ::Real, ::Int64)</code></a> — Method</li></ul><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.rotx" href="#KomaMRI.rotx"><code>KomaMRI.rotx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Rx = rotx(θ::Real)</code></pre><p>Rotates vector counter-clockwise with respect to the x-axis.</p><p><strong>Arguments</strong></p><ul><li><code>θ</code>: (<code>::Real</code>, <code>[rad]</code>) the rotation angle</li></ul><p><strong>Returns</strong></p><ul><li><code>Rx</code>: (<code>::Matrix{Int64}</code>) the rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/Grad.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.roty" href="#KomaMRI.roty"><code>KomaMRI.roty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Ry = roty(θ::Real)</code></pre><p>Rotates vector counter-clockwise with respect to the y-axis.</p><p><strong>Arguments</strong></p><ul><li><code>θ</code>: (<code>::Real</code>, <code>[rad]</code>) the rotation angle</li></ul><p><strong>Returns</strong></p><ul><li><code>Ry</code>: (<code>::Matrix{Int64}</code>) the rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/Grad.jl#L16-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.rotz" href="#KomaMRI.rotz"><code>KomaMRI.rotz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Rz = rotz(θ::Real)</code></pre><p>Rotates vector counter-clockwise with respect to the z-axis.</p><p><strong>Arguments</strong></p><ul><li><code>θ</code>: (<code>::Real</code>, <code>[rad]</code>) the rotation angle</li></ul><p><strong>Returns</strong></p><ul><li><code>Rz</code>: (<code>::Matrix{Int64}</code>) the rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/Grad.jl#L31-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, Grad}" href="#Base.show-Tuple{IO, Grad}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">str = show(io::IO, x::Grad)</code></pre><p>Displays information about the Grad struct <code>x</code> in the julia REPL.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Grad</code>) the Grad struct</li></ul><p><strong>Returns</strong></p><ul><li><code>str</code> (<code>::String</code>) the output string message</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/Grad.jl#L156-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty-Tuple{Vector{Grad}, Symbol}" href="#Base.getproperty-Tuple{Vector{Grad}, Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = getproperty(x::Vector{Grad}, f::Symbol)
y = getproperty(x::Matrix{Grad}, f::Symbol)</code></pre><p>Overchages Base.getproperty(). It is meant to access properties of the Grad vector <code>x</code> directly without the need to iterate elementwise.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Vector{Grad}</code> or <code>::Matrix{Grad}</code>) the vector or matrix of Grad structs</li><li><code>f</code>: (<code>::Symbol</code>, opts: [<code>:x</code>, <code>:y</code>, <code>:z</code>, <code>:T</code>, <code>:delay</code>, <code>:rise</code>, <code>:delay</code>, <code>:dur</code>,   <code>:A</code>, <code>f</code>]) the input symbol that represents a property of the vector or matrix of Grad   structs</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Vector{Any}</code> or <code>::Matrix{Any}</code>) the vector or matrix with the property defined   by the symbol <code>f</code> for all elements of the Grad vector or matrix <code>x</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/Grad.jl#L183-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.dur-Tuple{Grad}" href="#KomaMRI.dur-Tuple{Grad}"><code>KomaMRI.dur</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = dur(x::Grad)
y = dur(x::Vector{Grad})</code></pre><p>Duration time in [s] of Grad struct or Grad array. When the input is a gradient vector, then the duration is the maximum duration of all the elements of the gradient vector.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Grad</code> or <code>::Vector{Grad}</code>) the RF struct or RF array</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Float64</code>, <code>[s]</code>) the duration of the RF struct or RF array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/Grad.jl#L238-L250">source</a></section></article><h3 id="RF"><a class="docs-heading-anchor" href="#RF"><code>RF</code></a><a id="RF-1"></a><a class="docs-heading-anchor-permalink" href="#RF" title="Permalink"></a></h3><p>Refer to <a href="../api/#RF">API Documentation</a>:</p><ul><li><a href="../api/#KomaMRI.RF"><code>KomaMRI.RF</code></a> — Type</li></ul><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Spinor" href="#KomaMRI.Spinor"><code>KomaMRI.Spinor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">spinor = Spinor(α, β)</code></pre><p>Spinor(α, β) with Cayley-Klein parameters α and β. Based on &quot;Introduction to the Shinnar-Le Roux algorithm&quot;, Patrick Le Roux (1995). A spinor is a way to represent 3D rotations, the underlying representation is a 2 X 2 complex unitary matrix (<span>$\alpha,\beta\in\mathbb{C}$</span>):</p><p class="math-container">\[R=\left[\begin{array}{cc}
\alpha &amp; -\beta^{*}\\
\beta &amp; \alpha^{*}
\end{array}\right],\]</p><p>with <span>$|\alpha|^2+|\beta|^2 = 1$</span>.</p><p>This later operates on the <span>$2\times2$</span> representation of <span>$(x,y,z)$</span> as follows <span>$V^{+} = R V R^{*}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>α</code>: (<code>::Complex{Int64}</code>) the Cayley-Klein parameter α</li><li><code>β</code>: (<code>::Complex{Int64}</code>) the Cayley-Klein parameter β</li></ul><p><strong>Returns</strong></p><ul><li><code>spinor</code>: (<code>::Spinor</code>) the Spinor struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, Spinor}" href="#Base.show-Tuple{IO, Spinor}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">str = show(io::IO, s::Spinor)</code></pre><p>Displays the spinor parameters in the julia REPL.</p><p><strong>Arguments</strong></p><ul><li><code>s</code>: (<code>::Spinor</code>) the spinnor struct</li></ul><p><strong>Returns</strong></p><ul><li><code>str</code>: (<code>::String</code>) the output string message</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L31-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Spinor, Spinor}" href="#Base.:*-Tuple{Spinor, Spinor}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">s = *(s1::Spinor, s2::Spinor)</code></pre><p>Spinor multiplication identity: (α1,β1)×(α2,β2) = (α1 α2 - β2⋆ β1 , β2 α1 + α2⋆ β1)</p><p><strong>Arguments</strong></p><ul><li><code>s1</code>: (<code>::Spinor</code>) the first spinnor struct</li><li><code>s2</code>: (<code>::Spinor</code>) the second spinnor struct</li></ul><p><strong>Returns</strong></p><ul><li><code>s</code>: (<code>::Spinor</code>) the multiplication spinnor identity result</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L46-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Rz" href="#KomaMRI.Rz"><code>KomaMRI.Rz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">s = Rz(φ)</code></pre><p>Spinor clockwise rotation matrix with angle <code>φ</code> with respect to z-axis.</p><p><strong>Arguments</strong></p><ul><li><code>φ</code>: (<code>::Real</code>, <code>[rad]</code>) the angle with respect to z-axis</li></ul><p><strong>Returns</strong></p><ul><li><code>s</code>: (<code>::Spinnor</code>) the spinnor struct that represents the <code>Rz</code> rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L63-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Ry" href="#KomaMRI.Ry"><code>KomaMRI.Ry</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">s = Ry(θ)</code></pre><p>Spinor clockwise rotation matrix with angle <code>θ</code> with respect to y-axis.</p><p><strong>Arguments</strong></p><ul><li><code>θ</code>: (<code>::Real</code>, <code>[rad]</code>) the angle with respect to y-axis</li></ul><p><strong>Returns</strong></p><ul><li><code>s</code>: (<code>::Spinnor</code>) the spinnor struct that represents the <code>Ry</code> rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L76-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Rx" href="#KomaMRI.Rx"><code>KomaMRI.Rx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">s = Rx(θ)</code></pre><p>Spinor clockwise rotation matrix with angle <code>θ</code> with respect to x-axis.</p><p><strong>Arguments</strong></p><ul><li><code>θ</code>: (<code>::Real</code>, <code>[rad]</code>) the angle with respect to x-axis</li></ul><p><strong>Returns</strong></p><ul><li><code>s</code>: (<code>::Spinnor</code>) the spinnor struct that represents the <code>Rx</code> rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L89-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Rg" href="#KomaMRI.Rg"><code>KomaMRI.Rg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">s = Rg(φ1, θ, φ2)</code></pre><p>Spinor rotation matrix: Rg(φ1, θ, φ2) = Rz(φ2) Ry(θ) Rz(φ1)</p><p><strong>Arguments</strong></p><ul><li><code>φ1</code>: (<code>::Real</code>, <code>[rad]</code>) the φ1 angle</li><li><code>θ</code>: (<code>::Real</code>, <code>[rad]</code>) the θ angle</li><li><code>φ2</code>: (<code>::Real</code>, <code>[rad]</code>) the φ2 angle</li></ul><p><strong>Returns</strong></p><ul><li><code>s</code>: (<code>::Spinnor</code>) the spinnor struct that represents the <code>Rg</code> rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L102-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Rφ" href="#KomaMRI.Rφ"><code>KomaMRI.Rφ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">s = Rφ(φ, θ)</code></pre><p>Spinor rotation matrix with angle <code>θ</code> with axis in the xy plane u=(cosφ, sinφ).</p><p>Rφ(φ,θ) = Rg(-φ,θ,φ) = Rz(φ) Ry(θ) Rz(-φ)</p><p><strong>Arguments</strong></p><ul><li><code>φ</code>: (<code>::Real</code>, <code>[rad]</code>) the φ angle</li><li><code>θ</code>: (<code>::Real</code>, <code>[rad]</code>) the θ angle</li></ul><p><strong>Returns</strong></p><ul><li><code>s</code>: (<code>::Spinnor</code>) the spinnor struct that represents the <code>Rφ</code> rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L117-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Q" href="#KomaMRI.Q"><code>KomaMRI.Q</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">s = Q(φ, nxy, nz)</code></pre><p>Spinor rotation matrix. Rotation of <code>φ</code> with respect to the axis of rotation n=(nx, ny, nz).</p><p>Pauly, J., Le Roux, P., Nishimura, D., &amp; Macovski, A. (1991). Parameter relations for the Shinnar-Le Roux selective excitation pulse design algorithm (NMR imaging). IEEE Transactions on Medical Imaging, 10(1), 53-65. doi:10.1109/42.75611</p><p class="math-container">\[\varphi=-\gamma\Delta t\sqrt{\left|B_{1}\right|^{2}+\left(\boldsymbol{G}\cdot\boldsymbol{x}
\right)^{2}}=-\gamma\Delta t\left\Vert \boldsymbol{B}\right\Vert\]</p><p class="math-container">\[\boldsymbol{n}=\boldsymbol{B}/\left\Vert \boldsymbol{B}\right\Vert\]</p><p><strong>Arguments</strong></p><ul><li><code>φ</code>: (<code>::Real</code>, <code>[rad]</code>) the φ angle</li><li><code>nxy</code>: (<code>::Real</code>) the nxy factor</li><li><code>nz</code>: (<code>::Real</code>) the nz factor</li></ul><p><strong>Returns</strong></p><ul><li><code>s</code>: (<code>::Spinnor</code>) the spinnor struct that represents the <code>Q</code> rotation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L133-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs-Tuple{Spinor}" href="#Base.abs-Tuple{Spinor}"><code>Base.abs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = abs(s::Spinor)</code></pre><p>It calculates |α|^2 + |β|^2 of the Cayley-Klein parameters.</p><p><strong>Arguments</strong></p><ul><li><code>s</code>: (<code>::Spinnor</code>) the spinnor struct</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Real</code>) the result of the abs operator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L161-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, RF}" href="#Base.show-Tuple{IO, RF}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">str = show(io::IO, x::RF)</code></pre><p>Displays information about the RF struct <code>x</code> in the julia REPL.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::RF</code>) the RF struct</li></ul><p><strong>Returns</strong></p><ul><li><code>str</code>: (<code>::String</code>) the output string message</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L226-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty-Tuple{Vector{RF}, Symbol}" href="#Base.getproperty-Tuple{Vector{RF}, Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = getproperty(x::Vector{RF}, f::Symbol)
y = getproperty(x::Matrix{RF}, f::Symbol)</code></pre><p>Overchages Base.getproperty(). It is meant to access properties of the RF vector <code>x</code> directly without the need to iterate elementwise.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Vector{RF}</code> or <code>::Matrix{RF}</code>) the vector or matrix of RF structs</li><li><code>f</code>: (<code>::Symbol</code>, opts: [<code>:A</code>, <code>:Bx</code>, <code>:By</code>, <code>:T</code>, <code>:Δf</code>, <code>:delay</code> and <code>:dur</code>]) the input   symbol that represents a property of the vector or matrix of RF structs</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Vector{Any}</code> or <code>::Matrix{Any}</code>) the vector with the property defined by the   symbol <code>f</code> for all elements of the RF vector or matrix <code>x</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L249-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.dur-Tuple{RF}" href="#KomaMRI.dur-Tuple{RF}"><code>KomaMRI.dur</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = dur(x::RF)
y = dur(x::Array{RF,1})
y = dur(x::Array{RF,2})</code></pre><p>Duration time in [s] of RF struct or RF array.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::RF</code> or <code>::Array{RF,1}</code> or <code>::Array{RF,2}</code>) the RF struct or RF array</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Float64</code>, [<code>s</code>]) the duration of the RF struct or RF array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L289-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.RF_fun" href="#KomaMRI.RF_fun"><code>KomaMRI.RF_fun</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rf = RF_fun(f::Function, T::Real, N::Int64)</code></pre><p>Generate an RF sequence with amplitudes sampled from a function waveform.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is not being used in this KomaMRI version.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>f</code>: (<code>::Function</code>, [<code>T</code>]) the function for the RF amplitud waveform</li><li><code>T</code>: (<code>::Real</code>, [<code>s</code>]) the duration of the RF pulse</li><li><code>N</code>: (<code>::Int64</code>) the number of samples of the RF pulse</li></ul><p><strong>Returns</strong></p><ul><li><code>rf</code>:(<code>::RF</code>) the RF struct with amplitud defined by the function <code>f</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L306-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_flip_angle" href="#KomaMRI.get_flip_angle"><code>KomaMRI.get_flip_angle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">α = get_flip_angle(x::RF)</code></pre><p>Calculates the flip angle α [deg] of an RF struct. α = γ ∫ B1(τ) dτ</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::RF</code>) the RF struct</li></ul><p><strong>Returns</strong></p><ul><li><code>α</code>: (<code>::Int64</code>, <code>[deg]</code>) the flip angle RF struct <code>x</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L328-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_RF_center" href="#KomaMRI.get_RF_center"><code>KomaMRI.get_RF_center</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">t = get_RF_center(x::RF)</code></pre><p>Calculates the time where is the center of the RF pulse <code>x</code>. This calculation includes the RF delay.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::RF</code>) the RF struct</li></ul><p><strong>Returns</strong></p><ul><li><code>t</code>: (<code>::Int64</code>, <code>[s]</code>) the time where is the center of the RF pulse <code>x</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/RF.jl#L346-L357">source</a></section></article><h3 id="ADC"><a class="docs-heading-anchor" href="#ADC"><code>ADC</code></a><a id="ADC-1"></a><a class="docs-heading-anchor-permalink" href="#ADC" title="Permalink"></a></h3><p>Refer to <a href="../api/#ADC">API Documentation</a>:</p><ul><li><a href="../api/#KomaMRI.ADC"><code>KomaMRI.ADC</code></a> — Type</li></ul><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty-Tuple{Vector{ADC}, Symbol}" href="#Base.getproperty-Tuple{Vector{ADC}, Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y = getproperty(x::Vector{ADC}, f::Symbol)</code></pre><p>Overchages Base.getproperty(). It is meant to access properties of the ADC vector <code>x</code> directly without the need to iterate elementwise.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: (<code>::Vector{ADC}</code>) the vector of ADC structs</li><li><code>f</code>: (<code>::Symbol</code>, opts: [<code>:N</code>, <code>:T</code>, <code>:delay</code>, <code>:Δf</code>, <code>:ϕ</code>, <code>:dur</code>]) the input symbol that   represents a property of the ACD structs</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>::Vector{Any}</code>) the vector with the property defined by the <code>f</code> for all elements of   the ADC vector <code>x</code></li></ul><pre><code class="language-julia-repl hljs">julia&gt; ADCs = [ADC(16, 8, 2); ADC(8, 4, 6); ADC(4, 2, 8)]
3-element Vector{ADC}:
 ADC(16, 8.0, 2.0, 0.0, 0.0)
 ADC(8, 4.0, 6.0, 0.0, 0.0)
 ADC(4, 2.0, 8.0, 0.0, 0.0)

julia&gt; getproperty(ADCs, :dur)
3-element Vector{Float64}:
 10.0
 10.0
 10.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/ADC.jl#L53-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_sample_times" href="#KomaMRI.get_sample_times"><code>KomaMRI.get_sample_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">times = get_sample_times(seq)</code></pre><p>Returns an array of times when the samples of the sequence <code>seq</code> are acquired.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>times</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the time array when samples are acquired</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/ADC.jl#L92-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_sample_phase_compensation" href="#KomaMRI.get_sample_phase_compensation"><code>KomaMRI.get_sample_phase_compensation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phase = get_sample_phase_compensation(seq)</code></pre><p>Returns the array of phases for every acquired sample in the sequence <code>seq</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is useful to compensate the phase when the RF pulse has a phase too. Refer to the end of the <a href="#KomaMRI.run_sim_time_iter"><code>run_sim_time_iter</code></a> function to see its usage.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Returns</strong></p><ul><li><code>phase</code>: (<code>::Vector{Complex{Int64}}</code>, <code>[rad]</code>) the array of phases for every acquired   sample</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/ADC.jl#L118-L133">source</a></section></article><h3 id="Delay"><a class="docs-heading-anchor" href="#Delay"><code>Delay</code></a><a id="Delay-1"></a><a class="docs-heading-anchor-permalink" href="#Delay" title="Permalink"></a></h3><p>Refer to <a href="../api/#Delay">API Documentation</a>:</p><ul><li><a href="../api/#KomaMRI.Delay"><code>KomaMRI.Delay</code></a> — Type</li></ul><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, Delay}" href="#Base.show-Tuple{IO, Delay}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">str = show(io::IO, s::Delay)</code></pre><p>Displays the delay time in m[s] of the delay struct <code>s</code> in the julia REPL.</p><p><strong>Arguments</strong></p><ul><li><code>s</code>: (<code>::Delay</code>) the delay struct</li></ul><p><strong>Returns</strong></p><ul><li><code>str</code>: (<code>::String</code>) the output string message</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = Delay(1)
Delay(1000.0ms)

julia&gt; x
Delay(1000.0ms)

julia&gt; show(x)
Delay(1000.0ms)

julia&gt; display(x)
Delay(1000.0ms)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/Delay.jl#L50-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{Sequence, Delay}" href="#Base.:+-Tuple{Sequence, Delay}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seq = +(s::Sequence, d::Delay)
seq = +(d::Delay, s::Sequence)</code></pre><p>Add a delay to sequence struct. It ultimately affects to the duration of the gradients of a sequence.</p><p><strong>Arguments</strong></p><ul><li><code>s</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>d</code>: (<code>::Delay</code>) the delay struct</li></ul><p><strong>Returns</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the delayed sequence</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/datatypes/sequence/Delay.jl#L80-L93">source</a></section></article><h2 id="pulseq"><a class="docs-heading-anchor" href="#pulseq">Pulseq.jl</a><a id="pulseq-1"></a><a class="docs-heading-anchor-permalink" href="#pulseq" title="Permalink"></a></h2><p>Refer to <a href="../api/#read_seq">API Documentation</a>:</p><ul><li><a href="../api/#KomaMRI.read_seq"><code>KomaMRI.read_seq</code></a> — Function</li></ul><h3 id="read_Grad"><a class="docs-heading-anchor" href="#read_Grad"><code>read_Grad</code></a><a id="read_Grad-1"></a><a class="docs-heading-anchor-permalink" href="#read_Grad" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.read_Grad" href="#KomaMRI.read_Grad"><code>KomaMRI.read_Grad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">grad = read_Grad(gradLibrary, shapeLibrary, Δt_gr, i)</code></pre><p>Reads the gradient. It is used internally by <a href="#KomaMRI.get_block"><code>get_block</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>gradLibrary</code>: (<code>::Dict{K, V}</code>) the &quot;gradLibrary&quot; dictionary</li><li><code>shapeLibrary</code>: (<code>::Dict{K, V}</code>) the &quot;shapeLibrary&quot; dictionary</li><li><code>Δt_gr</code>: (<code>::Float64</code>, <code>[s]</code>) the gradient raster time</li><li><code>i</code>: (<code>::Int64</code>) the index of the axis in the block event</li></ul><p><strong>Returns</strong></p><ul><li><code>grad</code>: (::Grad) the gradient struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/io/Pulseq.jl#L448-L461">source</a></section></article><h3 id="read_RF"><a class="docs-heading-anchor" href="#read_RF"><code>read_RF</code></a><a id="read_RF-1"></a><a class="docs-heading-anchor-permalink" href="#read_RF" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.read_RF" href="#KomaMRI.read_RF"><code>KomaMRI.read_RF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rf = read_RF(rfLibrary, shapeLibrary, Δt_rf, i)</code></pre><p>Reads the RF. It is used internally by <a href="#KomaMRI.get_block"><code>get_block</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>rfLibrary</code>: (<code>::Dict{K, V}</code>) the &quot;rfLibrary&quot; dictionary</li><li><code>shapeLibrary</code>: (<code>::Dict{K, V}</code>) the &quot;shapeLibrary&quot; dictionary</li><li><code>Δt_rf</code>: (<code>::Float64</code>, <code>[s]</code>) the RF raster time</li><li><code>i</code>: (<code>::Int64</code>) the index of the RF in the block event</li></ul><p><strong>Returns</strong></p><ul><li><code>rf</code>: (<code>1x1 ::Matrix{RF}</code>) the RF struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/io/Pulseq.jl#L490-L503">source</a></section></article><h3 id="read_ADC"><a class="docs-heading-anchor" href="#read_ADC"><code>read_ADC</code></a><a id="read_ADC-1"></a><a class="docs-heading-anchor-permalink" href="#read_ADC" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.read_ADC" href="#KomaMRI.read_ADC"><code>KomaMRI.read_ADC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adc = read_ADC(adcLibrary, i)</code></pre><p>Reads the ADC. It is used internally by <a href="#KomaMRI.get_block"><code>get_block</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>adcLibrary</code>: (<code>::Dict{String, Any}</code>) the &quot;adcLibrary&quot; dictionary</li><li><code>i</code>: (<code>::Int64</code>) the index of the adc in the block event</li></ul><p><strong>Returns</strong></p><ul><li><code>adc</code>: (<code>1x1 ::Vector{ADC}</code>) the ADC struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/io/Pulseq.jl#L538-L549">source</a></section></article><h3 id="get_block"><a class="docs-heading-anchor" href="#get_block"><code>get_block</code></a><a id="get_block-1"></a><a class="docs-heading-anchor-permalink" href="#get_block" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_block" href="#KomaMRI.get_block"><code>KomaMRI.get_block</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">seq = get_block(obj, i)</code></pre><p>Block sequence definition. Used internally by <a href="../api/#KomaMRI.read_seq"><code>read_seq</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>obj</code>: (<code>::Dict{String, Any}</code>) the main dictionary</li><li><code>i</code>: (<code>::Int64</code>) the index of a block event</li></ul><p><strong>Returns</strong></p><ul><li><code>s</code>: (<code>::Sequence</code>) the block sequence struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/io/Pulseq.jl#L565-L576">source</a></section></article><h2 id="jemris"><a class="docs-heading-anchor" href="#jemris">JEMRIS.jl</a><a id="jemris-1"></a><a class="docs-heading-anchor-permalink" href="#jemris" title="Permalink"></a></h2><h3 id="read_phantom_jemris"><a class="docs-heading-anchor" href="#read_phantom_jemris"><code>read_phantom_jemris</code></a><a id="read_phantom_jemris-1"></a><a class="docs-heading-anchor-permalink" href="#read_phantom_jemris" title="Permalink"></a></h3><p>Refer to <a href="../api/#read_phantom_jemris">API Documentation</a>:</p><ul><li><a href="../api/#KomaMRI.read_phantom_jemris"><code>KomaMRI.read_phantom_jemris</code></a> — Function</li></ul><h2 id="ismrmrd"><a class="docs-heading-anchor" href="#ismrmrd">ISMRMRD.jl</a><a id="ismrmrd-1"></a><a class="docs-heading-anchor-permalink" href="#ismrmrd" title="Permalink"></a></h2><h3 id="signal_to_raw_data"><a class="docs-heading-anchor" href="#signal_to_raw_data"><code>signal_to_raw_data</code></a><a id="signal_to_raw_data-1"></a><a class="docs-heading-anchor-permalink" href="#signal_to_raw_data" title="Permalink"></a></h3><p>Refer to <a href="../api/#signal_to_raw_data">API Documentation</a>:</p><ul><li><a href="../api/#KomaMRI.signal_to_raw_data"><code>KomaMRI.signal_to_raw_data</code></a> — Function</li></ul><h2 id="pulse-designer"><a class="docs-heading-anchor" href="#pulse-designer">PulseDesigner.jl</a><a id="pulse-designer-1"></a><a class="docs-heading-anchor-permalink" href="#pulse-designer" title="Permalink"></a></h2><p>Refer to <a href="../api/#Pulse-Design">API Documentation</a>:</p><ul><li><a href="../api/#KomaMRI.PulseDesigner"><code>KomaMRI.PulseDesigner</code></a> — Function</li><li><a href="../api/#KomaMRI.PulseDesigner.RF_hard"><code>KomaMRI.PulseDesigner.RF_hard</code></a> — Function</li><li><a href="../api/#KomaMRI.PulseDesigner.EPI"><code>KomaMRI.PulseDesigner.EPI</code></a> — Function</li><li><a href="../api/#KomaMRI.PulseDesigner.radial_base"><code>KomaMRI.PulseDesigner.radial_base</code></a> — Function</li></ul><h2 id="key-values-calculation"><a class="docs-heading-anchor" href="#key-values-calculation">KeyValuesCalculation.jl</a><a id="key-values-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#key-values-calculation" title="Permalink"></a></h2><h3 id="get_theo_A"><a class="docs-heading-anchor" href="#get_theo_A"><code>get_theo_A</code></a><a id="get_theo_A-1"></a><a class="docs-heading-anchor-permalink" href="#get_theo_A" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_theo_A" href="#KomaMRI.get_theo_A"><code>KomaMRI.get_theo_A</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">A = get_theo_A(g::Grad; off_val=0)
A = get_theo_A(r::RF; off_val=0, max_rf_samples=Inf)
A = get_theo_A(d::ADC; off_val=0)</code></pre><p>Get the theoretical amplitudes of a rectangle waveform for Grad, RF or ADC structs. This are 5 points: delay, start, rise, stop and fall.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In some cases the array result can have duplicated points, so it is necessary to remove them whenever necessary.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>g</code>: (<code>::Grad</code>) the gradient struct</li><li><code>r</code>: (<code>::RF</code>) the RF struct</li><li><code>d</code>: (<code>::ADC</code>) the ADC truct</li></ul><p><strong>Keywords</strong></p><ul><li><code>off_val</code>: (<code>::Float64</code>, <code>=0</code>) the offset value for amplitude. In general, it is used for   not showing some points in plots by giving an <code>Inf</code> value</li><li><code>max_rf_samples</code>: (<code>::Float64</code>, <code>=Inf</code>) the number of maximum samples for the RF struct.   In general, this parameter is not necessary to set</li></ul><p><strong>Returns</strong></p><ul><li><code>A</code>: (<code>::Vector{Float64}</code>) the vector with the amplitude key points of the rectangle   waveform</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/KeyValuesCalculation.jl#L1-L27">source</a></section></article><h3 id="get_theo_t"><a class="docs-heading-anchor" href="#get_theo_t"><code>get_theo_t</code></a><a id="get_theo_t-1"></a><a class="docs-heading-anchor-permalink" href="#get_theo_t" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_theo_t" href="#KomaMRI.get_theo_t"><code>KomaMRI.get_theo_t</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">t = get_theo_t(g::Grad)
t = get_theo_t(r::RF; max_rf_samples=Inf)
t = get_theo_t(d::ADC)</code></pre><p>Get the theoretical times of a rectangle waveform for Grad, RF or ADC structs. This are 5 points: delay, start, rise, stop and fall.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In some cases the array result can have duplicated points, so it is necessary to remove them whenever necessary.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>g</code>: (<code>::Grad</code>) the gradient struct</li><li><code>r</code>: (<code>::RF</code>) the RF struct</li><li><code>d</code>: (<code>::ADC</code>) the ADC truct</li></ul><p><strong>Keywords</strong></p><ul><li><code>max_rf_samples</code>: (<code>::Float64</code>, <code>=Inf</code>) the number of maximum samples for the RF struct.   In general, this parameter is not necessary to set</li></ul><p><strong>Returns</strong></p><ul><li><code>t</code>: (<code>::Vector{Float64}</code>) the vector with the time key points of the rectangle waveform</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/KeyValuesCalculation.jl#L79-L102">source</a></section></article><h3 id="get_theo_Gi"><a class="docs-heading-anchor" href="#get_theo_Gi"><code>get_theo_Gi</code></a><a id="get_theo_Gi-1"></a><a class="docs-heading-anchor-permalink" href="#get_theo_Gi" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_theo_Gi" href="#KomaMRI.get_theo_Gi"><code>KomaMRI.get_theo_Gi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">t, g = get_theo_Gi(seq, idx)</code></pre><p>Get the theoretical gradient for a sequence in a defined axis.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>idx</code>: (<code>::Int64</code>, opts=[1, 2, 3]) the axis x, y or z for the gradient</li></ul><p><strong>Returns</strong></p><ul><li><code>t</code>: (<code>::Vector{Float64}</code>) the time key points</li><li><code>g</code>: (<code>::Vector{Float64}</code>) the amplitude key points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/KeyValuesCalculation.jl#L148-L160">source</a></section></article><h2 id="trapezoidal-integration"><a class="docs-heading-anchor" href="#trapezoidal-integration">TrapezoidalIntegration.jl</a><a id="trapezoidal-integration-1"></a><a class="docs-heading-anchor-permalink" href="#trapezoidal-integration" title="Permalink"></a></h2><h3 id="trapz"><a class="docs-heading-anchor" href="#trapz"><code>trapz</code></a><a id="trapz-1"></a><a class="docs-heading-anchor-permalink" href="#trapz" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.trapz" href="#KomaMRI.trapz"><code>KomaMRI.trapz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y = trapz(Δt, x)</code></pre><p>Trapezoidal integration for every spin of a phantom.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In practice, this function is used to integrate (Gx * x + Gy * y + Gz * z) * Δt for all the spins. <code>NΔt</code> is the length of <code>Δt</code>. <code>Ns</code> stands for the number of spins of a phantom. <code>x</code> is a matrix which rows represents different spins and columns are different times and the elements are the field Gx * x + Gy * y + Gz * z values.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>Δt</code>: (<code>1 x NΔt ::Matrix{Float64}</code>, <code>[s]</code>) the delta time 1-row array</li><li><code>x</code>: (<code>Ns x (NΔt+1) ::Matrix{Float64}</code>, <code>[T]</code>) the magnitude of field Gx * x + Gy * y +   Gz * z</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>Ns x 1 ::Matrix{Float64}</code>, <code>[T*s]</code>) the vector where every element is the integral   of (Gx * x + Gy * y + Gz * z) * Δt for every spin of a phantom</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/TrapezoidalIntegration.jl#L1-L20">source</a></section></article><h3 id="cumtrapz"><a class="docs-heading-anchor" href="#cumtrapz"><code>cumtrapz</code></a><a id="cumtrapz-1"></a><a class="docs-heading-anchor-permalink" href="#cumtrapz" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.cumtrapz" href="#KomaMRI.cumtrapz"><code>KomaMRI.cumtrapz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y = cumtrapz(Δt, x)</code></pre><p>Trapezoidal cumulative integration over time for every spin of a phantom.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In practice, this function is used to get the cumulative integration of (Gx * x + Gy * y + Gz * z) * Δt for all the spins. <code>NΔt</code> is the length of <code>Δt</code>. <code>Ns</code> stands for the number of spins of a phantom. <code>x</code> is a matrix which rows represents different spins and columns are different times and the elements are the field Gx * x + Gy * y + Gz * z values. Note that the last column of the result of this function <a href="#KomaMRI.cumtrapz"><code>cumtrapz</code></a> is equal to the result of the function <a href="#KomaMRI.trapz"><code>trapz</code></a></p></div></div><p><strong>Arguments</strong></p><ul><li><code>Δt</code>: (<code>1 x NΔt ::Matrix{Float64}</code>, <code>[s]</code>) the delta time 1-row array</li><li><code>x</code>: (<code>Ns x (NΔt+1) ::Matrix{Float64}</code>, <code>[T]</code>) the magnitude of field Gx * x + Gy * y +   Gz * z</li></ul><p><strong>Returns</strong></p><ul><li><code>y</code>: (<code>Ns x NΔt ::Matrix{Float64}</code>, <code>[T*s]</code>) the matrix where every column is the   cumulative integration over time of (Gx * x + Gy * y + Gz * z) * Δt for every spin of a   phantom</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/TrapezoidalIntegration.jl#L27-L49">source</a></section></article><h2 id="time-step-calculation"><a class="docs-heading-anchor" href="#time-step-calculation">TimeStepCalculation.jl</a><a id="time-step-calculation-1"></a><a class="docs-heading-anchor-permalink" href="#time-step-calculation" title="Permalink"></a></h2><h3 id="points_from_key_times"><a class="docs-heading-anchor" href="#points_from_key_times"><code>points_from_key_times</code></a><a id="points_from_key_times-1"></a><a class="docs-heading-anchor-permalink" href="#points_from_key_times" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.points_from_key_times" href="#KomaMRI.points_from_key_times"><code>KomaMRI.points_from_key_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">t = points_from_key_times(times; dt)</code></pre><p>Returns a vector which contains the same points as <code>times</code> but with additional points that have a separation of at most <code>dt</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The last time points could not be present in the output in some cases. Some time points could be duplicated in the output. Duplicated time points should be removed afterwards (done by     <a href="#KomaMRI.get_variable_times"><code>get_variable_times</code></a>). The output represents all time points regarded during the simulation with a &quot;nominal&quot; <code>dt</code> separation between two samples.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>times</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the time array with key points you want to keep</li></ul><p><strong>Keywords</strong></p><ul><li><code>dt</code>: (<code>::Float64</code>, <code>[s]</code>) the maximum delta time separation between two time samples</li></ul><p><strong>Returns</strong></p><ul><li><code>t</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the time array with the same points as the input array but with   additional points that have a separation of at most <code>dt</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; times = [0 1 2 10 11 12 20]
1×7 Matrix{Int64}:
 0  1  2  10  11  12  20

julia&gt; points_from_key_times(times; dt=0.5)&#39;
1×46 adjoint(::Vector{Float64}) with eltype Float64:
 0.0  0.5  1.0  1.0  1.5  2.0  2.0  2.5  3.0  3.5  4.0  4.5  …  16.0  16.5  17.0  17.5
   18.0  18.5  19.0  19.5  20.0

julia&gt; points_from_key_times(times; dt=0.7)&#39;
1×32 adjoint(::Vector{Float64}) with eltype Float64:
 0.0  0.7  1.0  1.7  2.0  2.7  3.4  4.1  4.8  5.5  6.2  6.9  …  14.1  14.8  15.5  16.2
   16.9  17.6  18.3  19.0  19.7

julia&gt; points_from_key_times(times; dt=2.5)&#39;
1×16 adjoint(::Vector{Float64}) with eltype Float64:
 0.0  1.0  1.0  2.0  2.0  4.5  7.0  9.5  10.0  11.0  11.0  12.0  12.0  14.5  17.0  19.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/TimeStepCalculation.jl#L79-L123">source</a></section></article><h3 id="get_variable_times"><a class="docs-heading-anchor" href="#get_variable_times"><code>get_variable_times</code></a><a id="get_variable_times-1"></a><a class="docs-heading-anchor-permalink" href="#get_variable_times" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_variable_times" href="#KomaMRI.get_variable_times"><code>KomaMRI.get_variable_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">t, Δt = get_variable_times(seq; dt=1, dt_rf=1e-4)</code></pre><p>This function returns non-uniform time points that are relevant in the sequence <code>seq</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is important to use a variable time step (instead of constant sampling time) to increase the simulation speed.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>dt</code>: (<code>::Real</code>, <code>=1</code>, <code>[s]</code>) the nominal delta time separation between two time samples   for ADC acquisition and Gradients (by nominal we mean that the time separation should be   at most <code>Δt</code> when the samples are regarded by <a href="#KomaMRI.is_ADC_on"><code>KomaMRI.is_ADC_on</code></a> or   <a href="#KomaMRI.is_GR_on"><code>KomaMRI.is_GR_on</code></a>), otherwise the time points are not necessary and the   separation will be bigger)</li></ul><p><strong>Keywords</strong></p><ul><li><code>Δt_rf</code>: (<code>::Real</code>, <code>=1e-4</code>, <code>[s]</code>) the nominal delta time separation between two time   samples for RF excitation (by nominal we mean that the time separation should be at most   <code>Δt_rf</code> when the samples are regarded by <a href="#KomaMRI.is_RF_on"><code>KomaMRI.is_RF_on</code></a>, otherwise the time   points are not necessary and the separation will be bigger)</li></ul><p><strong>Returns</strong></p><ul><li><code>t</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the time array with non-uniform time values</li><li><code>Δt</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the delta time array with the separation between two   adjacent time points of the <code>t</code> time array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/TimeStepCalculation.jl#L172-L199">source</a></section></article><h3 id="get_uniform_times"><a class="docs-heading-anchor" href="#get_uniform_times"><code>get_uniform_times</code></a><a id="get_uniform_times-1"></a><a class="docs-heading-anchor-permalink" href="#get_uniform_times" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_uniform_times" href="#KomaMRI.get_uniform_times"><code>KomaMRI.get_uniform_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">t, Δt = get_uniform_times(seq, Δt; Δt_rf=1e-4)</code></pre><p>This function, despite its name, actually gets non-uniform time points. Refer to <a href="#KomaMRI.get_variable_times"><code>get_variable_times</code></a> for more details.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function should be deprecated and the simulator should only use the <a href="#KomaMRI.get_variable_times"><code>get_variable_times</code></a> function. Note that in this KomaMRI version, this function is bypassed by <a href="#KomaMRI.get_variable_times"><code>get_variable_times</code></a>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>Δt</code>: (<code>::Real</code>, <code>[s]</code>) the nominal delta time separation between two time samples for ADC   acquisition and Gradients (by nominal we mean that the time separation should be at   most <code>Δt</code> when the samples are regarded by <a href="#KomaMRI.is_ADC_on"><code>KomaMRI.is_ADC_on</code></a> or   <a href="#KomaMRI.is_GR_on"><code>KomaMRI.is_GR_on</code></a>), otherwise the time points are not necessary and the   separation will be bigger)</li></ul><p><strong>Keywords</strong></p><ul><li><code>Δt_rf</code>: (<code>::Real</code>, <code>=1e-4</code>, <code>[s]</code>) the nominal delta time separation between two time   samples for RF excitation (by nominal we mean that the time separation should be at most   <code>Δt_rf</code> when the samples are regarded by <a href="#KomaMRI.is_RF_on"><code>KomaMRI.is_RF_on</code></a>, otherwise the time   points are not necessary and the separation will be bigger)</li></ul><p><strong>Returns</strong></p><ul><li><code>t</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the time array with non-uniform time values</li><li><code>Δt</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the delta time array with the separation between two   adjacent time points of the <code>t</code> time array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/TimeStepCalculation.jl#L138-L167">source</a></section></article><h3 id="kfoldperm"><a class="docs-heading-anchor" href="#kfoldperm"><code>kfoldperm</code></a><a id="kfoldperm-1"></a><a class="docs-heading-anchor-permalink" href="#kfoldperm" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.kfoldperm" href="#KomaMRI.kfoldperm"><code>KomaMRI.kfoldperm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">array_of_ranges = kfoldperm(N, k; type=&quot;random&quot;, breaks=[])</code></pre><p>Divides a list of indices 1:<code>N</code> (which is in your imagination) into <code>k</code> groups.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is possible to predifine some break points at specific indices with the <code>breaks</code> keyword, in this case the number of groups could increase. This is useful to define start and end indices of RF pulses to separate the simulation into excitation and preccesion computations.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>N</code>: (<code>::Int64</code>) the number of elements to be ordered (of an imaginary array 1:<code>N</code>)</li><li><code>k</code>: (<code>::Int64</code>) the number of groups to divide the <code>N</code> elements</li></ul><p><strong>Keywords</strong></p><ul><li><code>type</code>: (<code>::String</code>, <code>=&quot;random&quot;</code>, opts: [<code>&quot;random&quot;</code>, <code>&quot;ordered&quot;</code>]) the order type option.   If random, then the indices of the groups are unordered. If &quot;ordered&quot;, then the indices   of the groups are sorted in an incremental order</li><li><code>breaks</code>: (<code>::Vector{Int64}</code>, <code>=[]</code>) the array of indices where predefined break points   are placed</li></ul><p><strong>Returns</strong></p><ul><li><code>array_of_ranges</code>: (<code>::Vector{UnitRange{Int64}}</code>) the array that contains ranges of   different groups (the aim target are <code>k</code> groups, but this could be increased by adding   elements in the <code>breaks</code> input array)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; kfoldperm(20, 3; type=&quot;ordered&quot;)
3-element Vector{UnitRange{Int64}}:
 1:7
 8:14
 15:20

julia&gt; kfoldperm(20, 3; type=&quot;ordered&quot;, breaks=[3])
4-element Vector{UnitRange{Int64}}:
 1:2
 3:7
 8:14
 15:20

julia&gt; kfoldperm(20, 3; type=&quot;ordered&quot;, breaks=[3, 10])
5-element Vector{UnitRange{Int64}}:
 1:2
 3:7
 8:9
 10:14
 15:20

julia&gt; kfoldperm(20, 3; type=&quot;ordered&quot;, breaks=[3, 10, 17])
6-element Vector{UnitRange{Int64}}:
 1:2
 3:7
 8:9
 10:14
 15:16
 17:20</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/TimeStepCalculation.jl#L1-L60">source</a></section></article><h3 id="get_breaks_in_RF_key_points"><a class="docs-heading-anchor" href="#get_breaks_in_RF_key_points"><code>get_breaks_in_RF_key_points</code></a><a id="get_breaks_in_RF_key_points-1"></a><a class="docs-heading-anchor-permalink" href="#get_breaks_in_RF_key_points" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.get_breaks_in_RF_key_points" href="#KomaMRI.get_breaks_in_RF_key_points"><code>KomaMRI.get_breaks_in_RF_key_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">key_idxs = get_breaks_in_RF_key_points(seq::Sequence, t)</code></pre><p>Return the indices of the <code>t</code> time array where are RF key points from the <code>seq</code> sequence. Thus, it is possible to split the simulation into excitation and preccesion computations.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By <code>RF key points</code> we mean all the start and end points where the RF excitation takes place with the <a href="#KomaMRI.is_RF_on"><code>KomaMRI.is_RF_on</code></a> function.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>t</code>: (<code>::Vector{Int64}</code>, <code>[s]</code>) the non-uniform time array</li></ul><p><strong>Returns</strong></p><ul><li><code>key_idxs</code>: (<code>::Vector{Int64}</code>) array of indices of the <code>t</code> time array where are RF key   points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/TimeStepCalculation.jl#L239-L256">source</a></section></article><h2 id="simulation-core"><a class="docs-heading-anchor" href="#simulation-core">SimulationCore.jl</a><a id="simulation-core-1"></a><a class="docs-heading-anchor-permalink" href="#simulation-core" title="Permalink"></a></h2><p>Refer to <a href="../api/#Simulation">API Documentation</a>:</p><ul><li><a href="../api/#KomaMRI.simulate"><code>KomaMRI.simulate</code></a> — Function</li><li><a href="../api/#KomaMRI.simulate_slice_profile"><code>KomaMRI.simulate_slice_profile</code></a> — Function</li></ul><h3 id="print_gpus"><a class="docs-heading-anchor" href="#print_gpus"><code>print_gpus</code></a><a id="print_gpus-1"></a><a class="docs-heading-anchor-permalink" href="#print_gpus" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.print_gpus" href="#KomaMRI.print_gpus"><code>KomaMRI.print_gpus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_gpus()</code></pre><p>Simple function to print the gpus CUDA devices available in the host.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/SimulatorCore.jl#L6-L10">source</a></section></article><h3 id="run_spin_precession"><a class="docs-heading-anchor" href="#run_spin_precession"><code>run_spin_precession</code></a><a id="run_spin_precession-1"></a><a class="docs-heading-anchor-permalink" href="#run_spin_precession" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.run_spin_precession" href="#KomaMRI.run_spin_precession"><code>KomaMRI.run_spin_precession</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">S, M0 = run_spin_precession(obj, seq, t, Δt; M0, gpu)</code></pre><p>Simulates an MRI sequence <code>seq</code> on the Phantom <code>obj</code> for time points <code>t</code>. It calculates S(t) = ∫ ρ(x,t) exp(- t/T2(x,t) ) exp(- 𝒊 ϕ(x,t)) dx. It performs the simulation in free precession.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is used to simulate a part of the simulation over time given by the variable <code>Nblocks</code> (which is outside of this function, refer to <a href="#KomaMRI.run_sim_time_iter"><code>run_sim_time_iter</code></a>) to reduce the RAM memory utilization. It is also used to simulate a part of the spins in a phantom defined by the variable <code>Nthreads</code> (which is outside of this function too, refer to <a href="#KomaMRI.run_spin_precession_parallel"><code>run_spin_precession_parallel</code></a>) to take advantage of CPU parallel processing.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>obj</code>: (<code>::Phantom</code>) the phantom struct (actually, it&#39;s a part of the complete phantom)</li><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>t</code>: (<code>1-row ::Matrix{Float64}</code>, <code>[s]</code>) the non-uniform time vector (actually it&#39;s a part   of the complete simulation time vector)</li><li><code>Δt</code>: (<code>1-row ::Matrix{Float64}</code>, <code>[s]</code>) the delta time of <code>t</code> (actually it&#39;s a part of   the complete simulation time vector)</li></ul><p><strong>Keywords</strong></p><ul><li><code>M0</code>: (<code>::Vector{Mag}</code>) the initial state of the Mag vector (actually, it&#39;s a part of the   complete Mag vector)</li><li><code>gpu</code>: (<code>::Function</code>) the function that represents the gpu of the host</li></ul><p><strong>Returns</strong></p><ul><li><code>S</code>: (<code>Vector{ComplexF64}</code>) the raw signal over time</li><li><code>M0</code>: (<code>::Vector{Mag}</code>) the final state of the Mag vector (actually, it&#39;s a part of the   complete Mag vector) (it&#39;s not the initial state for the next simulation, since it&#39;s   necessary to add the magnetization of all the parts of the phantom (i.e. sum up all the   spin magnetizations first), refer to <a href="#KomaMRI.run_spin_precession_parallel"><code>run_spin_precession_parallel</code></a>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/SimulatorCore.jl#L71-L105">source</a></section></article><h3 id="run_spin_precession_parallel"><a class="docs-heading-anchor" href="#run_spin_precession_parallel"><code>run_spin_precession_parallel</code></a><a id="run_spin_precession_parallel-1"></a><a class="docs-heading-anchor-permalink" href="#run_spin_precession_parallel" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.run_spin_precession_parallel" href="#KomaMRI.run_spin_precession_parallel"><code>KomaMRI.run_spin_precession_parallel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">S, M0 = run_spin_precession_parallel(obj, seq, t, Δt; M0, Nthreads, gpu)</code></pre><p>Implementation in multiple threads for the simulation in free precession, separating the spins of the phantom <code>obj</code> in <code>Nthreads</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function does not use the complete time vector of the total simulation, it uses instead a piece of the time vector given by a variable called <code>Nblocks</code> (which is outside of this function, refer to <a href="#KomaMRI.run_sim_time_iter"><code>run_sim_time_iter</code></a>) to reduce the RAM memory utilization.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>obj</code>: (<code>::Phantom</code>) the phantom struct</li><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>t</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the non-uniform time vector (actually it&#39;s a part of the   complete simulation time vector)</li><li><code>Δt</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the delta time of <code>t</code> (actually it&#39;s a part of the   complete simulation time vector)</li></ul><p><strong>Keywords</strong></p><ul><li><code>M0</code>: (<code>::Vector{Mag}</code>) the initial state of the Mag vector</li><li><code>Nthreads</code>: (<code>::Int</code>, <code>=Hwloc.num_physical_cores()</code>) the number of process threads for   dividing the simulation into different phantom spin parts</li><li><code>gpu</code>: (<code>::Function</code>) the function that represents the gpu of the host</li></ul><p><strong>Returns</strong></p><ul><li><code>S</code>: (<code>Vector{ComplexF64}</code>) the raw signal over time</li><li><code>M0</code>: (<code>::Vector{Mag}</code>) the final state of the Mag vector (or the initial state for the   next simulation step (the next step can be another precession step or an excitation   step))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/SimulatorCore.jl#L19-L50">source</a></section></article><h3 id="run_spin_excitation"><a class="docs-heading-anchor" href="#run_spin_excitation"><code>run_spin_excitation</code></a><a id="run_spin_excitation-1"></a><a class="docs-heading-anchor-permalink" href="#run_spin_excitation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.run_spin_excitation" href="#KomaMRI.run_spin_excitation"><code>KomaMRI.run_spin_excitation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M0 = run_spin_excitation(obj, seq, t, Δt; M0, gpu)</code></pre><p>It gives rise to a rotation of <code>M0</code> with an angle given by the efective magnetic field (including B1, gradients and off resonance) and with respect to a rotation axis.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is used to simulate a part of the simulation over time given by the variable <code>Nblocks</code> (which is outside of this function, refer to <a href="#KomaMRI.run_sim_time_iter"><code>run_sim_time_iter</code></a>) to reduce the RAM memory utilization. It is also used to simulate a part of the spins in a phantom defined by the variable <code>Nthreads</code> (which is outside of this function too, refer to <a href="#KomaMRI.run_spin_excitation_parallel"><code>run_spin_excitation_parallel</code></a>) to take advantage of CPU parallel processing.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>obj</code>: (<code>::Phantom</code>) the phantom struct (actually, it&#39;s a part of the complete phantom)</li><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>t</code>: (<code>1-row ::Matrix{Float64}</code>, <code>[s]</code>) the non-uniform time vector (actually it&#39;s a part   of the complete simulation time vector)</li><li><code>Δt</code>: (<code>1-row ::Matrix{Float64}</code>, <code>[s]</code>) the delta time of <code>t</code> (actually it&#39;s a part of   the complete simulation time vector)</li></ul><p><strong>Keywords</strong></p><ul><li><code>M0</code>: (<code>::Vector{Mag}</code>) the initial state of the Mag vector (actually, it&#39;s a part of the   complete Mag vector)</li><li><code>gpu</code>: (<code>::Function</code>) the function that represents the gpu of the host</li></ul><p><strong>Returns</strong></p><ul><li><code>M0</code>: (<code>::Vector{Mag}</code>) the final state of the Mag vector after a rotation (actually, it&#39;s   a part of the complete Mag vector and it&#39;s a part of the initial state for the next   precession simulation step)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/SimulatorCore.jl#L221-L252">source</a></section></article><h3 id="run_spin_excitation_parallel"><a class="docs-heading-anchor" href="#run_spin_excitation_parallel"><code>run_spin_excitation_parallel</code></a><a id="run_spin_excitation_parallel-1"></a><a class="docs-heading-anchor-permalink" href="#run_spin_excitation_parallel" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.run_spin_excitation_parallel" href="#KomaMRI.run_spin_excitation_parallel"><code>KomaMRI.run_spin_excitation_parallel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M0 = run_spin_excitation_parallel(obj, seq, t, Δt; M0, Nthreads, gpu)</code></pre><p>It gives rise to a rotation of M0 with an angle given by the efective magnetic field (including B1, gradients and off resonance) and with respect to a rotation axis. It uses different number threads to excecute the process.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function does not use the complete time vector of the total simulation, it uses instead a piece of the time vector given by a variable called <code>Nblocks</code> (which is outside of this function, refer to <a href="#KomaMRI.run_sim_time_iter"><code>run_sim_time_iter</code></a>) to reduce the RAM memory utilization.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>obj</code>: (<code>::Phantom</code>) the phantom struct</li><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>t</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the non-uniform time vector (actually it&#39;s a part of the   complete simulation time vector)</li><li><code>Δt</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the delta time of <code>t</code> (actually it&#39;s a part of the   complete simulation time vector)</li></ul><p><strong>Keywords</strong></p><ul><li><code>M0</code>: (<code>::Vector{Mag}</code>) the initial state of the Mag vector</li><li><code>Nthreads</code>: (<code>::Int</code>, <code>=Hwloc.num_physical_cores()</code>) the number of process threads for   dividing the simulation into different phantom spin parts</li><li><code>gpu</code>: (<code>::Function</code>) the function that represents the gpu of the host</li></ul><p><strong>Returns</strong></p><ul><li><code>M0</code>: (<code>::Vector{Mag}</code>) the final state of the Mag vector after a rotation (or the initial   state for the next precession simulation step)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/SimulatorCore.jl#L175-L205">source</a></section></article><h3 id="run_sim_time_iter"><a class="docs-heading-anchor" href="#run_sim_time_iter"><code>run_sim_time_iter</code></a><a id="run_sim_time_iter-1"></a><a class="docs-heading-anchor-permalink" href="#run_sim_time_iter" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.run_sim_time_iter" href="#KomaMRI.run_sim_time_iter"><code>KomaMRI.run_sim_time_iter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">S_interp, M0 = run_sim_time_iter(obj, seq, t, Δt; Nblocks, Nthreads, gpu, w)</code></pre><p>Performs the simulation over the total time vector <code>t</code> by dividing the time into <code>Nblocks</code> parts to reduce RAM usage and spliting the spins of the phantom <code>obj</code> into <code>Nthreads</code> to take advantage of CPU parallel processing.</p><p><strong>Arguments</strong></p><ul><li><code>obj</code>: (<code>::Phantom</code>) the phantom struct</li><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>t</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the non-uniform time vector</li><li><code>Δt</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the delta time of <code>t</code></li></ul><p><strong>Keywords</strong></p><ul><li><code>Nblocks</code>: (<code>::Int</code>, <code>=16</code>) the number of groups for spliting the simulation over time</li><li><code>Nthreads</code>: (<code>::Int</code>, <code>=Hwloc.num_physical_cores()</code>) the number of process threads for   dividing the simulation into different phantom spin parts</li><li><code>gpu</code>: (<code>::Function</code>) the function that represents the gpu of the host</li><li><code>w</code>: (<code>::Any</code>, <code>=nothing</code>) the flag to regard a progress bar in the blink window UI. If   this variable is differnet from nothing, then the progress bar is considered</li></ul><p><strong>Returns</strong></p><ul><li><code>S_interp</code>: (<code>::Vector{ComplexF64}</code>) the interpolated raw signal</li><li><code>M0</code>: (<code>::Vector{Mag}</code>) the final state of the Mag vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/simulation/SimulatorCore.jl#L288-L312">source</a></section></article><h2 id="display-functions"><a class="docs-heading-anchor" href="#display-functions">DisplayFunctions.jl</a><a id="display-functions-1"></a><a class="docs-heading-anchor-permalink" href="#display-functions" title="Permalink"></a></h2><p>Refer to <a href="../api/#Plots">API Documentation</a>:</p><ul><li><a href="../api/#KomaMRI.plot_seq"><code>KomaMRI.plot_seq</code></a> — Function</li><li><a href="../api/#KomaMRI.plot_image"><code>KomaMRI.plot_image</code></a> — Function</li><li><a href="../api/#KomaMRI.plot_kspace"><code>plot_kspace</code></a> — Function</li><li><a href="../api/#KomaMRI.plot_M0"><code>plot_M0</code></a> — Function</li><li><a href="../api/#KomaMRI.plot_phantom_map"><code>plot_phantom_map</code></a> — Function</li><li><a href="../api/#KomaMRI.plot_signal"><code>plot_signal</code></a> — Function</li></ul><h3 id="theme_chooser"><a class="docs-heading-anchor" href="#theme_chooser"><code>theme_chooser</code></a><a id="theme_chooser-1"></a><a class="docs-heading-anchor-permalink" href="#theme_chooser" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.theme_chooser" href="#KomaMRI.theme_chooser"><code>KomaMRI.theme_chooser</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bgcolor, text_color, plot_bgcolor, grid_color, sep_color = theme_chooser(darkmode)</code></pre><p>Define colors for dark or light mode.</p><p><strong>Arguments</strong></p><ul><li><code>darkmode</code>: (<code>::Bool</code>) the boolean that selects dark or light mode</li></ul><p><strong>Returns</strong></p><ul><li><code>bgcolor</code>: (<code>::String</code>) the backgound color</li><li><code>text_color</code>: (<code>::String</code>) the text color</li><li><code>plot_bgcolor</code>: (<code>::String</code>) the color background for the plots</li><li><code>grid_color</code>: (<code>::String</code>) the color of the grids</li><li><code>sep_color</code>: (<code>::String</code>) the color of separator lines</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/ui/DisplayFunctions.jl#L1-L15">source</a></section></article><h3 id="interp_map"><a class="docs-heading-anchor" href="#interp_map"><code>interp_map</code></a><a id="interp_map-1"></a><a class="docs-heading-anchor-permalink" href="#interp_map" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.interp_map" href="#KomaMRI.interp_map"><code>KomaMRI.interp_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">c_map_interp = interp_map(c_map, t_interp)</code></pre><p>Interpolates a color map. This is used for plotting the kspace (refer to <a href="../api/#KomaMRI.plot_kspace"><code>plot_kspace</code></a>).</p><p><strong>Arguments</strong></p><ul><li><code>c_map</code>: (<code>::Vector{Vector{Any}}</code>) the color map. Every element of this vector has a   vector with a number between 0-1 in its first element and a color string in its second   element. It serves as a reference to create a color map with more elements</li><li><code>t_interp</code>: (<code>::Vector{Float64}</code>) the vector with values between 0-1 that are the   reference for interpolate the color map with more elements</li></ul><p><strong>Returns</strong></p><ul><li><code>c_map_interp</code>: (<code>::Vector{String}</code>) the vector with color strings with interpolated   values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/ui/DisplayFunctions.jl#L33-L49">source</a></section></article><h3 id="plot_dict"><a class="docs-heading-anchor" href="#plot_dict"><code>plot_dict</code></a><a id="plot_dict-1"></a><a class="docs-heading-anchor-permalink" href="#plot_dict" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.plot_dict" href="#KomaMRI.plot_dict"><code>KomaMRI.plot_dict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">str = plot_dict(dict::Dict)</code></pre><p>Generates a string in html format of the dictionary <code>dict</code>.</p><p><strong>Arguments</strong></p><ul><li><code>dict</code>: (<code>::Dict</code>) the dictionary to generate tha html string</li></ul><p><strong>Returns</strong></p><ul><li><code>str</code>: (<code>::String</code>) the string of the dictionary <code>dict</code> which is a table in html format</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/2239b51f1c0c1dd4bf75571f12625d4eac853776/src/ui/DisplayFunctions.jl#L766-L776">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Wednesday 19 October 2022 12:59">Wednesday 19 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
