<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · KomaMRI.jl: General MRI simulation framework</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/extra-styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="KomaMRI.jl: General MRI simulation framework logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="KomaMRI.jl: General MRI simulation framework logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../ui-details/">Graphical User Interface</a></li><li><a class="tocitem" href="../simulation-examples/">Examples</a></li><li><a class="tocitem" href="../mri-theory/">Simulation Method</a></li><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#How-to-read-the-API-docs"><span>How to read the API docs</span></a></li><li><a class="tocitem" href="#Structs"><span>Structs</span></a></li><li><a class="tocitem" href="#Read-Data"><span>Read Data</span></a></li><li><a class="tocitem" href="#Pulse-Design"><span>Pulse Design</span></a></li><li><a class="tocitem" href="#Simulation"><span>Simulation</span></a></li><li><a class="tocitem" href="#Plots"><span>Plots</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cncastillo/KomaMRI.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>This page shows the documentation for the modules, structs, functions, methods and additional components available when importing the <strong>KomaMRI.jl</strong> package. It is very useful for reference when using directly the Julia REPL and when creating custom Julia scripts. Please, don&#39;t miss out the section <a href="#How-to-read-the-API-docs">How to read the API docs</a> which has important considerations to understand general aspects of the docstring structure. The following are the contents of the API Documentation:</p><ul><li class="no-marker"><ul><li><a href="#How-to-read-the-API-docs">How to read the API docs</a></li><li><a href="#Structs">Structs</a></li><li class="no-marker"><ul><li><a href="#Scanner"><code>Scanner</code></a></li><li><a href="#Phantom"><code>Phantom</code></a></li><li><a href="#Sequence"><code>Sequence</code></a></li><li><a href="#Grad"><code>Grad</code></a></li><li><a href="#RF"><code>RF</code></a></li><li><a href="#ADC"><code>ADC</code></a></li><li><a href="#Delay"><code>Delay</code></a></li></ul></li><li><a href="#Read-Data">Read Data</a></li><li class="no-marker"><ul><li><a href="#read_seq"><code>read_seq</code></a></li><li><a href="#read_phantom_jemris"><code>read_phantom_jemris</code></a></li><li><a href="#signal_to_raw_data"><code>signal_to_raw_data</code></a></li></ul></li><li><a href="#Pulse-Design">Pulse Design</a></li><li class="no-marker"><ul><li><a href="#PulseDesigner"><code>PulseDesigner</code></a></li><li><a href="#PulseDesigner.RF_hard"><code>PulseDesigner.RF_hard</code></a></li><li><a href="#PulseDesigner.EPI"><code>PulseDesigner.EPI</code></a></li><li><a href="#PulseDesigner.radial_base"><code>PulseDesigner.radial_base</code></a></li></ul></li><li><a href="#Simulation">Simulation</a></li><li class="no-marker"><ul><li><a href="#simulate"><code>simulate</code></a></li><li><a href="#simulate_slice_profile"><code>simulate_slice_profile</code></a></li></ul></li><li><a href="#Plots">Plots</a></li><li class="no-marker"><ul><li><a href="#plot_phantom_map"><code>plot_phantom_map</code></a></li><li><a href="#plot_seq"><code>plot_seq</code></a></li><li><a href="#plot_kspace"><code>plot_kspace</code></a></li><li><a href="#plot_M0"><code>plot_M0</code></a></li><li><a href="#plot_signal"><code>plot_signal</code></a></li><li><a href="#plot_image"><code>plot_image</code></a></li></ul></li></ul></li></ul><h2 id="How-to-read-the-API-docs"><a class="docs-heading-anchor" href="#How-to-read-the-API-docs">How to read the API docs</a><a id="How-to-read-the-API-docs-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-read-the-API-docs" title="Permalink"></a></h2><p>The API documentation has predefined &quot;template patterns&quot; which are meant to help the user to understand how to use modules, structs, functions, methods and every aspect necessary in order to take advantage of all the possibilities that <strong>KomaMRI.jl</strong> offers.</p><p>These documentation &quot;template patterns&quot; are based from the <a href="https://github.com/invenia/BlueStyle">Julia Blue Style</a> documentation and other github repositories that works with MRI topics. However, some custom considerations were added for a better understanding and a wider perspective.</p><p>Whenever you see a docstring documentation, it will have the following structure:</p><div class="admonition is-category-docstring"><header class="admonition-header">KomaMRI.component_name — Component</header><div class="admonition-body"><pre><code class="nohighlight hljs">out1, out2, ... = component_name(arg1, arg2, ...; kw1, kw2, ...)</code></pre><p>This is a brief description of what <strong>component_name</strong> does.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Here can be placed a note if it is regarded necessary.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>arg1</code>: (<code>::type</code>, <code>=value</code>, <code>[unit]</code>, opts: [<code>opt1</code>, <code>opt2</code>, ...]) the description for the arg1</li><li>...</li></ul><p><strong>Keywords</strong></p><ul><li><code>kw1</code>: (<code>::type</code>, <code>=value</code>, <code>[unit]</code>, opts: [<code>opt1</code>, <code>opt2</code>, ...]) the description for the kw1</li><li>...</li></ul><p><strong>Returns</strong></p><ul><li><code>out1</code>: (<code>::type</code>, <code>=value</code>, <code>[unit]</code>, opts: [<code>opt1</code>, <code>opt2</code>, ...]) the description for the out1</li><li>...</li></ul><p><strong>References</strong></p><ul><li>Sometimes it is a good idea to put some references or links</li><li>...</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; arg1, arg2, valkw1, valkw2 = 3.5, &quot;hello&quot;, 1, true

julia&gt; out1, out2 = component_name(arg1, arg2; kw1=valkw1, kw2=valkw2)</code></pre></div></div><p>The previous docstring block will always have first the way how it is called the component (outputs = component_name(inputs) and next a brief description about what the component does. Then a <strong>note</strong> block will be displayed if necessary. As general rule, the next subsections are optional: <strong>Arguments</strong>, <strong>Keywords</strong>, <strong>Returns</strong>, <strong>References</strong> and <strong>Examples</strong>, however they will be displayed whenever necessary. These subsections are self-explanatory, so it is intuitive to figure out what are they meant for.</p><p>Note that every subitem in the sections <strong>Arguments</strong>, <strong>Keywords</strong> and <strong>Returns</strong> are variables. They have practical information enclosed in parentheses plus a description. They information in parentheses is optional but very useful if it is present:</p><ul><li><code>::type</code>: is the suggested type of the variable. If the input variable is of type <code>::type</code>, then nothing can go wrong, but it is always possible to test other types. If the variable is an output, then it will always try to be forced to the type <code>::type</code>.</li><li><code>=value</code>: sometimes for the inputs the is defined a default value if it is not assigned by the user.</li><li><code>[unit]</code>: this is the suggested physical unit of measure of the variable. Everything it is going to be fine if you are stick with these units of measure.</li><li>opts: [<code>opt1</code>, <code>opt2</code>, ...]: sometimes the input value can only be interpreted if it is part of some predefined values.</li></ul><h2 id="Structs"><a class="docs-heading-anchor" href="#Structs">Structs</a><a id="Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Structs" title="Permalink"></a></h2><h3 id="Scanner"><a class="docs-heading-anchor" href="#Scanner"><code>Scanner</code></a><a id="Scanner-1"></a><a class="docs-heading-anchor-permalink" href="#Scanner" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Scanner" href="#KomaMRI.Scanner"><code>KomaMRI.Scanner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">scanner = Scanner(B0, B1, Gmax, Smax, ADC_Δt, seq_Δt, GR_Δt, RF_Δt,
    RF_ring_down_T, RF_dead_time_T, ADC_dead_time_T)</code></pre><p>The Scanner struct.</p><p><strong>Arguments</strong></p><ul><li><code>B0</code>: (<code>::Real</code>, <code>=1.5</code>, <code>[T]</code>) the main magnetic field</li><li><code>B1</code>: (<code>::Real</code>, <code>=10e-6</code>, <code>[T]</code>) the maximum RF amplitude</li><li><code>Gmax</code>: (<code>::Real</code>, <code>=60e-3</code>, <code>[T/m]</code>) the maximum Gradient</li><li><code>Smax</code>: (<code>::Real</code>, <code>=500</code>, <code>[mT/m/ms]</code>) the maximum slew-rate</li><li><code>ADC_Δt</code>: (<code>::Real</code>, <code>=2e-6</code>, <code>[s]</code>) the ADC raster time</li><li><code>seq_Δt</code>: (<code>::Real</code>, <code>=1e-5</code>, <code>[s]</code>) the sequence-block raster time</li><li><code>GR_Δt</code>: (<code>::Real</code>, <code>=1e-5</code>, <code>[s]</code>) the gradient raster time</li><li><code>RF_Δt</code>: (<code>::Real</code>, <code>=1e-6</code>, <code>[s]</code>) the RF raster time</li><li><code>RF_ring_down_T</code>: (<code>::Real</code>, <code>=20e-6</code>, <code>[s]</code>) the RF ring down time</li><li><code>RF_dead_time_T</code>: (<code>::Real</code>, <code>=100e-6</code>, <code>[s]</code>) the RF dead time</li><li><code>ADC_dead_time_T</code>: (<code>::Real</code>, <code>=10e-6</code>, <code>[s]</code>) the ADC dead time</li></ul><p><strong>Returns</strong></p><ul><li><code>scanner</code>: (<code>::Scanner</code>) the Scanner struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys = Scanner()
Scanner
  B0: Float64 1.5
  B1: Float64 1.0e-5
  Gmax: Float64 0.06
  Smax: Int64 500
  ADC_Δt: Float64 2.0e-6
  seq_Δt: Float64 1.0e-5
  GR_Δt: Float64 1.0e-5
  RF_Δt: Float64 1.0e-6
  RF_ring_down_T: Float64 2.0e-5
  RF_dead_time_T: Float64 0.0001
  ADC_dead_time_T: Float64 1.0e-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/datatypes/Scanner.jl#L1-L39">source</a></section></article><h3 id="Phantom"><a class="docs-heading-anchor" href="#Phantom"><code>Phantom</code></a><a id="Phantom-1"></a><a class="docs-heading-anchor-permalink" href="#Phantom" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Phantom" href="#KomaMRI.Phantom"><code>KomaMRI.Phantom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">phantom = Phantom(name, x, y, z, ρ, T1, T2, T2s, Δw, Dλ1, Dλ2, Dθ, ux, uy, uz)</code></pre><p>The Phantom struct.</p><p><strong>Arguments</strong></p><ul><li><code>name</code>: (<code>::String</code>) the name of the Phantom</li><li><code>x</code>: (<code>::Vector{Float64}</code>, <code>[m]</code>) the vector of x-positions of the spins</li><li><code>y</code>: (<code>::Vector{Float64}</code>, <code>[m]</code>) the vector of y-positions of the spins</li><li><code>z</code>: (<code>::Vector{Float64}</code>, <code>[m]</code>) the vector of z-positions of the spins</li><li><code>ρ</code>: (<code>::Vector{Float64}</code>) the vector of proton density of the spins</li><li><code>T1</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the vector of T1 parameters of the spins</li><li><code>T2</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the vector of T2 parameters of the spins</li><li><code>T2s</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the vector of T2s parameters of the spins</li><li><code>Δw</code>: (<code>::Vector{Float64}</code>, <code>[rad/s]</code>) the vector of off-resonance parameters of the spins</li><li><code>Dλ1</code>: (<code>::Vector{Float64}</code>) the vector of Dλ1 (diffusion) parameters of the spins</li><li><code>Dλ2</code>: (<code>::Vector{Float64}</code>) the vector of Dλ2 (diffusion) parameters of the spins</li><li><code>Dθ</code>: (<code>::Vector{Float64}</code>) the vector of Dθ (diffusion) parameters of the spins</li><li><code>ux</code>: (<code>::Function</code>) the displacement field in the x-axis</li><li><code>uy</code>: (<code>::Function</code>) the displacement field in the y-axis</li><li><code>uz</code>: (<code>::Function</code>) the displacement field in the z-axis</li></ul><p><strong>Returns</strong></p><ul><li><code>phantom</code>: (<code>::Phantom</code>) the Phantom struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; obj = Phantom(x=zeros(5))
Phantom
  name: String &quot;spin&quot;
  x: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]
  y: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]
  z: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]
  ρ: Array{Float64}((5,)) [1.0, 1.0, 1.0, 1.0, 1.0]
  T1: Array{Float64}((5,)) [Inf, Inf, Inf, Inf, Inf]
  T2: Array{Float64}((5,)) [Inf, Inf, Inf, Inf, Inf]
  T2s: Array{Float64}((5,)) [Inf, Inf, Inf, Inf, Inf]
  Δw: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]
  Dλ1: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]
  Dλ2: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]
  Dθ: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]
  ux: #145 (function of type KomaMRI.var&quot;#145#153&quot;)
  uy: #146 (function of type KomaMRI.var&quot;#146#154&quot;)
  uz: #147 (function of type KomaMRI.var&quot;#147#155&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/datatypes/Phantom.jl#L1-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.brain_phantom2D" href="#KomaMRI.brain_phantom2D"><code>KomaMRI.brain_phantom2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phantom = brain_phantom2D(;axis=&quot;axial&quot;, ss=4)</code></pre><p>Creates a two-dimentional brain phantom struct.</p><p><strong>References</strong></p><ul><li>B. Aubert-Broche, D.L. Collins, A.C. Evans: &quot;A new improved version of the realistic   digital brain phantom&quot; NeuroImage, in review - 2006</li><li>B. Aubert-Broche, M. Griffin, G.B. Pike, A.C. Evans and D.L. Collins: &quot;20 new digital   brain phantoms for creation of validation image data bases&quot; IEEE TMI, in review - 2006</li><li>https://brainweb.bic.mni.mcgill.ca/brainweb</li></ul><p><strong>Keywords</strong></p><ul><li><code>axis</code>: (<code>::String</code>, <code>=&quot;axial&quot;</code>, opts=[<code>&quot;axial&quot;</code>]) the orientation of the phantom</li><li><code>ss</code>: (<code>::Real</code>, <code>=4</code>) the brain phantom parameter</li></ul><p><strong>Returns</strong></p><ul><li><code>phantom</code>: (<code>::Phantom</code>) the 2D phantom struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; obj = brain_phantom2D()
Phantom
  name: String &quot;brain2D_axial&quot;
  x: Array{Float64}((6506,)) [-0.084, -0.084  …  0.086]
  y: Array{Float64}((6506,)) [-0.03, -0.028  …  0.002]
  z: Array{Float64}((6506,)) [-0.0, -0.0  …  0.0]
  ρ: Array{Float64}((6506,)) [1.0, 1.0  …  1.0]
  T1: Array{Float64}((6506,)) [0.569, 0.569  …  0.569]
  T2: Array{Float64}((6506,)) [0.329, 0.329  …  0.329]
  T2s: Array{Float64}((6506,)) [0.058, 0.058  …  0.058]
  Δw: Array{Float64}((6506,)) [-0.0, -0.0  …  -0.0]
  Dλ1: Array{Float64}((6506,)) [0.0, 0.0  …  0.0]
  Dλ2: Array{Float64}((6506,)) [0.0, 0.0  …  0.0]
  Dθ: Array{Float64}((6506,)) [0.0, 0.0  …  0.0]
  ux: #386 (function of type KomaMRI.var&quot;#386#394&quot;)
  uy: #387 (function of type KomaMRI.var&quot;#387#395&quot;)
  uz: #388 (function of type KomaMRI.var&quot;#388#396&quot;)

julia&gt; plot_phantom_map(obj, :ρ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/datatypes/Phantom.jl#L223-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.brain_phantom3D" href="#KomaMRI.brain_phantom3D"><code>KomaMRI.brain_phantom3D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phantom = brain_phantom3D(;ss=4)</code></pre><p>Creates a three-dimentional brain phantom struct.</p><p><strong>References</strong></p><ul><li>B. Aubert-Broche, D.L. Collins, A.C. Evans: &quot;A new improved version of the realistic   digital brain phantom&quot; NeuroImage, in review - 2006</li><li>B. Aubert-Broche, M. Griffin, G.B. Pike, A.C. Evans and D.L. Collins: &quot;20 new digital   brain phantoms for creation of validation image data bases&quot; IEEE TMI, in review - 2006</li><li>https://brainweb.bic.mni.mcgill.ca/brainweb</li></ul><p><strong>Keywords</strong></p><ul><li><code>ss</code>: (<code>::Real</code>, <code>=4</code>) the heart phantom parameter</li></ul><p><strong>Returns</strong></p><ul><li><code>phantom</code>: (<code>::Phantom</code>) the 3D phantom struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; obj = brain_phantom3D()
Phantom
  name: String &quot;brain3D&quot;
  x: Array{Float64}((71326,)) [-0.086, -0.086  …  0.084]
  y: Array{Float64}((71326,)) [-0.02, -0.018  …  0.004]
  z: Array{Float64}((71326,)) [-0.01, -0.01  …  0.01]
  ρ: Array{Float64}((71326,)) [1.0, 1.0  …  1.0]
  T1: Array{Float64}((71326,)) [0.569, 0.569  …  0.569]
  T2: Array{Float64}((71326,)) [0.329, 0.329  …  0.329]
  T2s: Array{Float64}((71326,)) [0.058, 0.058  …  0.058]
  Δw: Array{Float64}((71326,)) [-0.0, -0.0  …  -0.0]
  Dλ1: Array{Float64}((71326,)) [0.0, 0.0  …  0.0]
  Dλ2: Array{Float64}((71326,)) [0.0, 0.0  …  0.0]
  Dθ: Array{Float64}((71326,)) [0.0, 0.0  …  0.0]
  ux: #386 (function of type KomaMRI.var&quot;#386#394&quot;)
  uy: #387 (function of type KomaMRI.var&quot;#387#395&quot;)
  uz: #388 (function of type KomaMRI.var&quot;#388#396&quot;)

julia&gt; plot_phantom_map(obj, :ρ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/datatypes/Phantom.jl#L341-L381">source</a></section></article><h3 id="Sequence"><a class="docs-heading-anchor" href="#Sequence"><code>Sequence</code></a><a id="Sequence-1"></a><a class="docs-heading-anchor-permalink" href="#Sequence" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Sequence" href="#KomaMRI.Sequence"><code>KomaMRI.Sequence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">seq = Sequence()
seq = Sequence(GR)
seq = Sequence(GR, RF)
seq = Sequence(GR, RF, ADC)
seq = Sequence(GR, RF, ADC, DUR)
seq = Sequence(GR::Array{Grad,1})
seq = Sequence(GR::Array{Grad,1}, RF::Array{RF,1})
seq = Sequence(GR::Array{Grad,1}, RF::Array{RF,1}, A::ADC, DUR, DEF)</code></pre><p>The Sequence struct.</p><p><strong>Arguments</strong></p><ul><li><code>GR</code>: (<code>::Matrix{Grad}</code>) the gradient matrix, rows are for (x,y,z) and columns are for time</li><li><code>RF</code>: (<code>::Matrix{RF}</code>) the RF matrix, the 1 row is for the coil and columns are for time</li><li><code>ADC</code>: (<code>::Vector{ADC}</code>) the ADC vector in time</li><li><code>DUR</code>: (<code>::Vector{Float64}</code>, <code>[s]</code>) the duration of each sequence-block, this enables   delays after RF pulses to satisfy ring-down times</li><li><code>DEF</code>: (<code>::Dict{String, Any}</code>) the dictionary with relevant information of the sequence.   The possible keys are [<code>&quot;AdcRasterTime&quot;</code>, <code>&quot;GradientRasterTime&quot;</code>, <code>&quot;Name&quot;</code>, <code>&quot;Nz&quot;</code>,   <code>&quot;Num_Blocks&quot;</code>, <code>&quot;Nx&quot;</code>, <code>&quot;Ny&quot;</code>, <code>&quot;PulseqVersion&quot;</code>, <code>&quot;BlockDurationRaster&quot;</code>,   <code>&quot;FileName&quot;</code>, <code>&quot;RadiofrequencyRasterTime&quot;</code>]</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d1, d2, d3 = 0.8, 0.4, 0.8;

julia&gt; fsinc = x -&gt; 2 * sinc(3*pi*(x - d1/2)) * 1e-3;

julia&gt; matrixGrads = [Grad(0, d1) Grad( 0, d2) Grad(1, d3);
                      Grad(0, d1) Grad( 1, d2) Grad(0, d3);
                      Grad(1, d1) Grad(-1, d2) Grad(0, d3)];

julia&gt; matrixRFs = [KomaMRI.RF_fun(fsinc, d1) RF(0, d2) RF(0, d3)];

julia&gt; vectorADCs = [ADC(0, d1); ADC(0, d2); ADC(9, d3)];

julia&gt; seq = Sequence(matrixGrads, matrixRFs, vectorADCs)
Sequence[ τ = 2000.0 ms | blocks: 3 | ADC: 1 | GR: 4 | RF: 1 | DEF: 0 ]

julia&gt; plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/datatypes/Sequence.jl#L1-L43">source</a></section></article><h3 id="Grad"><a class="docs-heading-anchor" href="#Grad"><code>Grad</code></a><a id="Grad-1"></a><a class="docs-heading-anchor-permalink" href="#Grad" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Grad" href="#KomaMRI.Grad"><code>KomaMRI.Grad</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">grad = Grad(A, T)
grad = Grad(A, T, rise)
grad = Grad(A, T, rise, delay)
grad = Grad(A, T, rise, fall, delay)</code></pre><p>The Gradient struct.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: (<code>::Float64</code>, <code>[T]</code>) the amplitude of the gradient</li><li><code>T</code>: (<code>::Float64</code>, <code>[s]</code>) the duration of the flat-top</li><li><code>rise</code>: (<code>::Real</code>, <code>[s]</code>) the duration of the rise</li><li><code>fall</code>: (<code>::Real</code>, <code>[s]</code>) the duration of the fall</li><li><code>delay</code>: (<code>::Real</code>, <code>[s]</code>) the duration of the delay</li></ul><p><strong>Returns</strong></p><ul><li><code>grad</code>: (<code>::Grad</code>) the Gradient struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d1, d2, d3 = 0.8, 0.4, 0.8;

julia&gt; matrixGrads = [Grad(0, d1) Grad( 0, d2) Grad(1, d3);
                      Grad(0, d1) Grad( 1, d2) Grad(0, d3);
                      Grad(1, d1) Grad(-1, d2) Grad(0, d3)];

julia&gt; seq = Sequence(matrixGrads)
Sequence[ τ = 2000.0 ms | blocks: 3 | ADC: 0 | GR: 4 | RF: 0 | DEF: 0 ]

julia&gt; plot_seq(seq)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; d1, d2, d3 = 0.8, 0.4, 0.8;

julia&gt; dr, df, dd = 0.1, 0.05, 1;

julia&gt; matrixGrads = [Grad(0, d1, dr, df, dd) Grad( 0, d2, dr, df, 0) Grad(1, d3, dr, df, 0);
                      Grad(0, d1, dr, df, dd) Grad( 1, d2, dr, df, 0) Grad(0, d3, dr, df, 0);
                      Grad(1, d1, dr, df, dd) Grad(-1, d2, dr, df, 0) Grad(0, d3, dr, df, 0)];

julia&gt; seq = Sequence(matrixGrads)
Sequence[ τ = 3450.0 ms | blocks: 3 | ADC: 0 | GR: 4 | RF: 0 | DEF: 0 ]

julia&gt; plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/datatypes/sequence/Grad.jl#L46-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Grad-Tuple{Function, Real, Int64}" href="#KomaMRI.Grad-Tuple{Function, Real, Int64}"><code>KomaMRI.Grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grad = Grad(f::Function, T::Real, N::Int64; delay::Real)</code></pre><p>Generates an arbitrary gradient waveform defined by function <code>f</code> in the interval t ∈ [0,<code>T</code>]. It uses <code>N</code> square gradients uniformly spaced in the interval.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: (<code>::Function</code>) the gradient waveform</li><li><code>T</code>: (<code>::Real</code>, <code>[s]</code>) the duration of the gradient waveform</li><li><code>N</code>: (<code>::Int64</code>) the number of samples of the gradient waveform</li></ul><p><strong>Keywords</strong></p><ul><li><code>delay</code>: (<code>::Real</code>, <code>=0</code>, <code>[s]</code>) the starting delay for the waveform</li></ul><p><strong>Returns</strong></p><ul><li><code>grad</code>: (<code>::Grad</code>) the Gradient struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d1, d2, d3 = 0.8, 0.4, 0.8;

julia&gt; f1 = t -&gt; sin(pi*t / d1);

julia&gt; f2 = t -&gt; 1 - exp(- 5 * t / d2);

julia&gt; f3 = t -&gt; exp(t / d3 * log(2)) - 1;

julia&gt; matrixGrads = [Grad(f1, d1) Grad( 0, d2) Grad( 0, d3);
                      Grad( 0, d1) Grad(f2, d2) Grad( 0, d3);
                      Grad( 0, d1) Grad( 0, d2) Grad(f3, d3)];

julia&gt; seq = Sequence(matrixGrads)
Sequence[ τ = 2000.0 ms | blocks: 3 | ADC: 0 | GR: 3 | RF: 0 | DEF: 0 ]

julia&gt; plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/datatypes/sequence/Grad.jl#L112-L148">source</a></section></article><h3 id="RF"><a class="docs-heading-anchor" href="#RF"><code>RF</code></a><a id="RF-1"></a><a class="docs-heading-anchor-permalink" href="#RF" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.RF" href="#KomaMRI.RF"><code>KomaMRI.RF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">rf = RF(A, T)
rf = RF(A, T, Δf)
rf = RF(A, T, Δf, delay)</code></pre><p>The RF struct.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: (<code>::Complex{Int64}</code>, <code>[T]</code>) the amplitud-phase B1x + i B1y</li><li><code>T</code>: (<code>::Int64</code>, [<code>s</code>]) the durations of the RF</li><li><code>Δf</code>: (<code>::Float64</code>, [<code>Hz</code>]) the frequency offset of the RF</li><li><code>delay</code>: (<code>::Float64</code>, [<code>s</code>]) the delay time of the RF</li></ul><p><strong>Returns</strong></p><ul><li><code>rf</code>: (<code>::RF</code>) the RF struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d1, d2, d3 = 0.8, 0.4, 0.8;

julia&gt; fsinc = x -&gt; 2 * sinc(3*pi*(x - d1/2)) * 1e-3;

julia&gt; matrixGrads = [Grad(0, d1) Grad(0, d2) Grad(0, d3)];

julia&gt; matrixRFs = [KomaMRI.RF_fun(fsinc, d1) RF(0, d2) RF(0, d3)];

julia&gt; seq = Sequence(matrixGrads, matrixRFs)
Sequence[ τ = 2000.0 ms | blocks: 3 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/datatypes/sequence/RF.jl#L175-L206">source</a></section></article><h3 id="ADC"><a class="docs-heading-anchor" href="#ADC"><code>ADC</code></a><a id="ADC-1"></a><a class="docs-heading-anchor-permalink" href="#ADC" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.ADC" href="#KomaMRI.ADC"><code>KomaMRI.ADC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">adc = ADC(N, T)
adc = ADC(N, T, delay)
adc = ADC(N, T, delay, Δf, ϕ)</code></pre><p>The ADC struct.</p><p><strong>Arguments</strong></p><ul><li><code>N</code>: (<code>::Int64</code>) the number of acquired samples</li><li><code>T</code>: (<code>::Float64</code>, [<code>s</code>]) the duration to acquire the samples</li><li><code>delay</code>: (<code>::Float64</code>, [<code>s</code>]) the delay time to start the acquisition</li><li><code>Δf</code>: (<code>::Float64</code>, [<code>Hz</code>]) the delta frequency. It&#39;s meant to compensate RF pulse phases.   It is used internally by the <a href="../docstrings/#KomaMRI.read_ADC"><code>read_ADC</code></a> function</li><li><code>ϕ</code>: (<code>::Float64</code>, <code>[rad]</code>) the phase. It&#39;s meant to compensate RF pulse phases. It is   used internally by the <a href="../docstrings/#KomaMRI.read_ADC"><code>read_ADC</code></a> function</li></ul><p><strong>Returns</strong></p><ul><li><code>adc</code>: (<code>::ADC</code>) the ADC struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d1, d2, d3 = 0.8, 0.4, 0.8;

julia&gt; matrixGrads = [Grad(0, d1) Grad(0, d2) Grad(0, d3)];

julia&gt; matrixRFs = [RF(0, d1) RF(0, d2) RF(0, d3)];

julia&gt; vectorADCs = [ADC(0, d1); ADC(0, d2); ADC(9, d3)];

julia&gt; seq = Sequence(matrixGrads, matrixRFs, vectorADCs)
Sequence[ τ = 2000.0 ms | blocks: 3 | ADC: 1 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/datatypes/sequence/ADC.jl#L1-L35">source</a></section></article><h3 id="Delay"><a class="docs-heading-anchor" href="#Delay"><code>Delay</code></a><a id="Delay-1"></a><a class="docs-heading-anchor-permalink" href="#Delay" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.Delay" href="#KomaMRI.Delay"><code>KomaMRI.Delay</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">delay = Delay(T)</code></pre><p>The Delay struct. The input delay time <code>T</code> must be non-negative.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This struct is meant to add delays to a sequence struct that ultimately affects to the duration of the gradients of a sequence.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>T</code>: (<code>::Real</code>, <code>[s]</code>) the time delay value</li></ul><p><strong>Returns</strong></p><ul><li><code>delay</code>: (<code>::Delay</code>) the Delay struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d1, d2, d3 = 0.8, 0.4, 0.8;

julia&gt; fsinc = x -&gt; 2 * sinc(3*pi*(x - d1/2)) * 1e-3;

julia&gt; matrixGrads = [Grad(0, d1) Grad( 0, d2) Grad(1, d3);
                      Grad(0, d1) Grad( 1, d2) Grad(0, d3);
                      Grad(1, d1) Grad(-1, d2) Grad(0, d3)];

julia&gt; matrixRFs = [KomaMRI.RF_fun(fsinc, d1) RF(0, d2) RF(0, d3)];

julia&gt; vectorADCs = [ADC(0, d1); ADC(0, d2); ADC(9, d3)];

julia&gt; delay = Delay(1);

julia&gt; seq = Sequence(matrixGrads, matrixRFs, vectorADCs)
Sequence[ τ = 2000.0 ms | blocks: 3 | ADC: 1 | GR: 4 | RF: 1 | DEF: 0 ]

julia&gt; delayed_seq = delay + seq
Sequence[ τ = 3000.0 ms | blocks: 4 | ADC: 1 | GR: 4 | RF: 1 | DEF: 0 ]

julia&gt; plot_seq(seq)

julia&gt; plot_seq(delayed_seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/datatypes/sequence/Delay.jl#L1-L42">source</a></section></article><h2 id="Read-Data"><a class="docs-heading-anchor" href="#Read-Data">Read Data</a><a id="Read-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Read-Data" title="Permalink"></a></h2><h3 id="read_seq"><a class="docs-heading-anchor" href="#read_seq"><code>read_seq</code></a><a id="read_seq-1"></a><a class="docs-heading-anchor-permalink" href="#read_seq" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.read_seq" href="#KomaMRI.read_seq"><code>KomaMRI.read_seq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">seq = read_seq(filename)</code></pre><p>Returns the Sequence struct from a sequence file <code>.seq</code>.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: (<code>::String</code>) the absolute or relative path of the sequence file <code>.seq</code></li></ul><p><strong>Returns</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; seq = read_seq(&quot;examples/1.sequences/epi.seq&quot;)
Successfully loaded epi.seq!
Sequence[ τ = 332.16 ms | blocks: 609 | ADC: 300 | GR: 615 | RF: 3 | DEF: 10 ]

julia&gt; plot_seq(seq)

julia&gt; plot_kspace(seq)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; seq = read_seq(&quot;examples/1.sequences/spiral.seq&quot;)
Successfully loaded spiral.seq!
Sequence[ τ = 42.89 ms | blocks: 4 | ADC: 1 | GR: 8 | RF: 2 | DEF: 12 ]

julia&gt; plot_seq(seq)

julia&gt; plot_kspace(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/io/Pulseq.jl#L278-L308">source</a></section></article><h3 id="read_phantom_jemris"><a class="docs-heading-anchor" href="#read_phantom_jemris"><code>read_phantom_jemris</code></a><a id="read_phantom_jemris-1"></a><a class="docs-heading-anchor-permalink" href="#read_phantom_jemris" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.read_phantom_jemris" href="#KomaMRI.read_phantom_jemris"><code>KomaMRI.read_phantom_jemris</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phantom = read_phantom_jemris(filename)</code></pre><p>Returns the Phantom struct from JEMRIS phantoms a file <code>.h5</code>.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: (<code>::String</code>) the absolute or relative path of the phantom file <code>.h5</code></li></ul><p><strong>Returns</strong></p><ul><li><code>phantom</code>: (<code>::Phantom</code>) the phantom struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; obj = read_phantom_jemris(&quot;examples/2.phantoms/brain.h5&quot;)
Phantom
  name: String &quot;brain.h5&quot;
  x: Array{Float64}((25841,)) [-0.0085, -0.0075  …  0.0035]
  y: Array{Float64}((25841,)) [-0.0985, -0.0985  …  0.1055]
  z: Array{Float64}((25841,)) [0.0, 0.0  …  0.0]
  ρ: Array{Float64}((25841,)) [1.0, 1.0  …  1.0]
  T1: Array{Float64}((25841,)) [2.569, 2.569  …  2.569]
  T2: Array{Float64}((25841,)) [0.329, 0.329  …  0.329]
  T2s: Array{Float64}((25841,)) [Inf, Inf  …  Inf]
  Δw: Array{Float64}((25841,)) [0.0, 0.0  …  0.0]
  Dλ1: Array{Float64}((25841,)) [0.0, 0.0  …  0.0]
  Dλ2: Array{Float64}((25841,)) [0.0, 0.0  …  0.0]
  Dθ: Array{Float64}((25841,)) [0.0, 0.0  …  0.0]
  ux: #161 (function of type KomaMRI.var&quot;#161#162&quot;{Int64})
  uy: #387 (function of type KomaMRI.var&quot;#387#395&quot;)
  uz: #388 (function of type KomaMRI.var&quot;#388#396&quot;)

julia&gt; plot_phantom_map(obj, :ρ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/io/JEMRIS.jl#L1-L34">source</a></section></article><h3 id="signal_to_raw_data"><a class="docs-heading-anchor" href="#signal_to_raw_data"><code>signal_to_raw_data</code></a><a id="signal_to_raw_data-1"></a><a class="docs-heading-anchor-permalink" href="#signal_to_raw_data" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.signal_to_raw_data" href="#KomaMRI.signal_to_raw_data"><code>KomaMRI.signal_to_raw_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">raw_ismrmrd = signal_to_raw_data(signal, seq; phantom, sys, simParams)</code></pre><p>Transforms the raw signal into ISMRMRD format.</p><p><strong>Arguments</strong></p><ul><li><code>signal</code>: (<code>::Vector{ComplexF64}</code>) the raw signal</li><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Keywords</strong></p><ul><li><code>phantom</code>: (<code>::Phantom</code>, <code>=Phantom(name=&quot;Phantom&quot;,x=[0])</code>) the phantom struct</li><li><code>sys</code>: (<code>::Scanner</code>, <code>=Scanner()</code>) the scanner struct</li><li><code>simParams</code>: (<code>::Dict{String,Any}()</code>, <code>=Dict{String,Any}()</code>) the dictionary with   simulation parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>raw_ismrmrd</code>: (<code>::RawAcquisitionData</code>) the raw signal in ISMRMRD format</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys = Scanner();

julia&gt; FOV, N = 23e-2, 101;

julia&gt; durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse

julia&gt; ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)
Sequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; epi = PulseDesigner.EPI(FOV, N, sys)
Sequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]

julia&gt; seq = ex + epi
Sequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 4 ]

julia&gt; plot_seq(seq)

julia&gt; obj = brain_phantom2D();

julia&gt; signal = simulate(obj, seq, sys);

julia&gt; ismrmrd = signal_to_raw_data([signal;;], seq; phantom=obj, sys=sys);

julia&gt; plot_signal(ismrmrd)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/io/ISMRMRD.jl#L3-L48">source</a></section></article><h2 id="Pulse-Design"><a class="docs-heading-anchor" href="#Pulse-Design">Pulse Design</a><a id="Pulse-Design-1"></a><a class="docs-heading-anchor-permalink" href="#Pulse-Design" title="Permalink"></a></h2><h3 id="PulseDesigner"><a class="docs-heading-anchor" href="#PulseDesigner"><code>PulseDesigner</code></a><a id="PulseDesigner-1"></a><a class="docs-heading-anchor-permalink" href="#PulseDesigner" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.PulseDesigner" href="#KomaMRI.PulseDesigner"><code>KomaMRI.PulseDesigner</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">PulseDesigner</code></pre><p>A module to define different pulse sequences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/sequences/PulseDesigner.jl#L1-L5">source</a></section></article><h3 id="PulseDesigner.RF_hard"><a class="docs-heading-anchor" href="#PulseDesigner.RF_hard"><code>PulseDesigner.RF_hard</code></a><a id="PulseDesigner.RF_hard-1"></a><a class="docs-heading-anchor-permalink" href="#PulseDesigner.RF_hard" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.PulseDesigner.RF_hard" href="#KomaMRI.PulseDesigner.RF_hard"><code>KomaMRI.PulseDesigner.RF_hard</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ex = RF_hard(B1, T, sys::Scanner; G=[0,0,0], Δf=0)</code></pre><p>Definition of the RF hard sequence.</p><p><strong>Arguments</strong></p><ul><li><code>B1</code>: (<code>Float64</code>, <code>[T]</code>) the amplitude of the RF pulse</li><li><code>T</code>: (<code>Float64</code>, <code>[s]</code>) the duration of the RF pulse</li><li><code>sys</code>: (<code>::Scanner</code>) the scanner struct</li></ul><p><strong>Keywords</strong></p><ul><li><code>G</code>: (<code>Vector{Float64}</code>, <code>=[0, 0, 0]</code>, <code>[T]</code>) the gradient amplitudes for x, y, z</li><li><code>Δf</code>: (<code>Float64</code>, <code>=0</code>, <code>[Hz]</code>) the frequency offset of the RF pulse</li></ul><p><strong>Returns</strong></p><ul><li><code>ex</code>: (<code>::Sequence</code>) the excitation sequence struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys = Scanner();

julia&gt; durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse

julia&gt; ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)
Sequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; plot_seq(ex)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/sequences/PulseDesigner.jl#L10-L38">source</a></section></article><h3 id="PulseDesigner.EPI"><a class="docs-heading-anchor" href="#PulseDesigner.EPI"><code>PulseDesigner.EPI</code></a><a id="PulseDesigner.EPI-1"></a><a class="docs-heading-anchor-permalink" href="#PulseDesigner.EPI" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.PulseDesigner.EPI" href="#KomaMRI.PulseDesigner.EPI"><code>KomaMRI.PulseDesigner.EPI</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">epi = EPI(FOV::Float64, N::Int, sys::Scanner)</code></pre><p>Definition of the EPI sequence.</p><p><strong>Arguments</strong></p><ul><li><code>FOV</code>: (<code>::Float64</code>, <code>[m]</code>) the field of view</li><li><code>N</code>: (<code>::Int</code>) the number of pixels in the x and y axis</li><li><code>sys</code>: (<code>::Scanner</code>) the scanner struct</li></ul><p><strong>Returns</strong></p><ul><li><code>epi</code>: (<code>::Sequence</code>) the epi sequence struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys = Scanner();

julia&gt; FOV, N = 23e-2, 101;

julia&gt; epi = PulseDesigner.EPI(FOV, N, sys)
Sequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]

julia&gt; plot_seq(epi)

julia&gt; plot_kspace(epi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/sequences/PulseDesigner.jl#L87-L113">source</a></section></article><h3 id="PulseDesigner.radial_base"><a class="docs-heading-anchor" href="#PulseDesigner.radial_base"><code>PulseDesigner.radial_base</code></a><a id="PulseDesigner.radial_base-1"></a><a class="docs-heading-anchor-permalink" href="#PulseDesigner.radial_base" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.PulseDesigner.radial_base" href="#KomaMRI.PulseDesigner.radial_base"><code>KomaMRI.PulseDesigner.radial_base</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">seq = radial_base(FOV::Float64, Nr::Int, sys::Scanner)</code></pre><p>Definition of the radial base sequence.</p><p><strong>Arguments</strong></p><ul><li><code>FOV</code>: (<code>::Float64</code>, <code>[m]</code>) the field of view</li><li><code>N</code>: (<code>::Int</code>) number of pixel in the radious</li><li><code>sys</code>: (<code>::Scanner</code>) the scanner struct</li></ul><p><strong>Returns</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the radial base sequence struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/sequences/PulseDesigner.jl#L150-L162">source</a></section></article><h2 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h2><h3 id="simulate"><a class="docs-heading-anchor" href="#simulate"><code>simulate</code></a><a id="simulate-1"></a><a class="docs-heading-anchor-permalink" href="#simulate" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.simulate" href="#KomaMRI.simulate"><code>KomaMRI.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">out = simulate(obj::Phantom, seq::Sequence, sys::Scanner; simParams, w)</code></pre><p>Returns the raw signal or the last state of the magnetization according to the value of the <code>&quot;return_type&quot;</code> key of the <code>simParams</code> dictionary.</p><p><strong>Arguments</strong></p><ul><li><code>obj</code>: (<code>::Phantom</code>) the phantom struct</li><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li><li><code>sys</code>: (<code>::Scanner</code>) the scanner struct</li></ul><p><strong>Keywords</strong></p><ul><li><code>simParams</code>: (<code>::Dict{String,Any}</code>, <code>=Dict{String,Any}()</code>) the dictionary with simulation   parameters</li><li><code>w</code>: (<code>::Any</code>, <code>=nothing</code>) the flag to regard a progress bar in the blink window UI. If   this variable is differnet from nothing, then the progress bar is considered</li></ul><p><strong>Returns</strong></p><ul><li><code>out</code>: (<code>::Vector{ComplexF64}</code> or <code>::Vector{Mag}</code> or <code>RawAcquisitionData</code>) depending if &quot;return_type&quot; is   &quot;mat&quot; or &quot;mag&quot; or &quot;raw&quot; (default) respectively.</li></ul><p><strong>Examples</strong></p><p>Preparation (define scanner and sequence):</p><pre><code class="language-julia-repl hljs">julia&gt; sys = Scanner();

julia&gt; FOV, N = 23e-2, 101;

julia&gt; durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse

julia&gt; ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)
Sequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; epi = PulseDesigner.EPI(FOV, N, sys)
Sequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]

julia&gt; seq = ex + epi
Sequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 4 ]

julia&gt; plot_seq(seq)

julia&gt; plot_kspace(seq)</code></pre><p>Simulate:</p><pre><code class="language-julia-repl hljs">julia&gt; obj = brain_phantom2D()

julia&gt; signal = simulate(obj, seq, sys);

julia&gt; ismrmrd = signal_to_raw_data([signal;;], seq; phantom=obj, sys=sys);

julia&gt; plot_signal(ismrmrd)</code></pre><p>Reconstruct:</p><pre><code class="language-julia-repl hljs">julia&gt; Nx, Ny = ismrmrd.params[&quot;reconSize&quot;][1:2];

julia&gt; params = Dict{Symbol,Any}(:reco=&gt;&quot;direct&quot;, :reconSize=&gt;(Nx, Ny), :densityWeighting=&gt;true);

julia&gt; acq = AcquisitionData(ismrmrd);

julia&gt; recon = reconstruction(acq, params);

julia&gt; image = reshape(recon.data, Nx, Ny, :)
102×102×1 Array{ComplexF64, 3}:
[:, :, 1] =
 0.0+0.0im  0.0+0.0im  …  0.0+0.0im
 0.0+0.0im  0.0+0.0im     0.0+0.0im
    ⋮           ⋮       ⋱      ⋮
 0.0+0.0im  0.0+0.0im  …  0.0+0.0im

julia&gt; slice_abs = abs.(image[:, :, 1])
102×102 Matrix{Float64}:
 0.0  0.0  …  0.0
 0.0  0.0     0.0
  ⋮        ⋱   ⋮
 0.0  0.0  …  0.0

julia&gt; plot_image(slice_abs)</code></pre><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/simulation/SimulatorCore.jl#L356-L440">source</a></section></article><h3 id="simulate_slice_profile"><a class="docs-heading-anchor" href="#simulate_slice_profile"><code>simulate_slice_profile</code></a><a id="simulate_slice_profile-1"></a><a class="docs-heading-anchor-permalink" href="#simulate_slice_profile" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.simulate_slice_profile" href="#KomaMRI.simulate_slice_profile"><code>KomaMRI.simulate_slice_profile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M = simulate_slice_profile(seq; z, simParams)</code></pre><p>Returns magnetization of spins distributed along <code>z</code> after running the Sequence <code>seq</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is not being used in this KomaMRI version.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Keywords</strong></p><ul><li><code>z</code>: (<code>=range(-2e-2,2e-2,200)</code>) a range for the z axe</li><li><code>simParams</code>: (<code>::Dict{String, Any}</code>, <code>=Dict{String,Any}(&quot;Δt_rf&quot;=&gt;1e-6)</code>) a dictionary with   simulation parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>M</code>: (<code>::Vector{Mag}</code>) the final state of the Mag vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/simulation/SimulatorCore.jl#L482-L500">source</a></section></article><h2 id="Plots"><a class="docs-heading-anchor" href="#Plots">Plots</a><a id="Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Plots" title="Permalink"></a></h2><h3 id="plot_phantom_map"><a class="docs-heading-anchor" href="#plot_phantom_map"><code>plot_phantom_map</code></a><a id="plot_phantom_map-1"></a><a class="docs-heading-anchor-permalink" href="#plot_phantom_map" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.plot_phantom_map" href="#KomaMRI.plot_phantom_map"><code>KomaMRI.plot_phantom_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">p = plot_phantom_map(ph, key; t0=0, height=700, width=nothing, darkmode=false)</code></pre><p>Plots a phantom map for a specific spin parameter given by <code>key</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ph</code>: (<code>::Phantom</code>) the phantom struct</li><li><code>key</code>: (<code>::Symbol</code>, opts: [<code>:ρ</code>, <code>:T1</code>, <code>:T2</code>, <code>:T2s</code>, <code>:x</code>, <code>:y</code>, <code>:z</code>]) the symbol for   displaying different parameters of the phantom spins</li></ul><p><strong>Keywords</strong></p><ul><li><code>t0</code>: (<code>::Float64</code>, <code>=0</code>, <code>[ms]</code>) the time to see displacement of the phantom</li><li><code>height</code>: (<code>::Int64</code>, <code>=nothing</code>) the height of the plot</li><li><code>width</code>: (<code>::Int64</code>, <code>=nothing</code>) the width of the plot</li><li><code>darkmode</code>: (<code>::Bool</code>, <code>=false</code>) the boolean to define colors for darkmode</li></ul><p><strong>Returns</strong></p><ul><li><code>p</code>: (<code>::PlotlyJS.SyncPlot</code>) the plot of the phantom map for a specific spin parameter</li></ul><p><strong>References</strong></p><p>Colormaps from https://github.com/markgriswold/MRFColormaps Towards Unified Colormaps for Quantitative MRF Data, Mark Griswold, et al. (2018).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; obj2D, obj3D = brain_phantom2D(), brain_phantom3D();

julia&gt; plot_phantom_map(obj2D, :ρ)

julia&gt; plot_phantom_map(obj3D, :ρ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/ui/DisplayFunctions.jl#L522-L553">source</a></section></article><h3 id="plot_seq"><a class="docs-heading-anchor" href="#plot_seq"><code>plot_seq</code></a><a id="plot_seq-1"></a><a class="docs-heading-anchor-permalink" href="#plot_seq" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.plot_seq" href="#KomaMRI.plot_seq"><code>KomaMRI.plot_seq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">p = plot_seq(seq; width, height, slider, show_seq_blocks, darkmode, max_rf_samples, range)</code></pre><p>Plots a sequence struct.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Keywords</strong></p><ul><li><code>width</code>: (<code>::Int64</code>, <code>=nothing</code>) the width of the plot</li><li><code>height</code>: (<code>::Int64</code>, <code>=nothing</code>) the height of the plot</li><li><code>slider</code>: (<code>::Bool</code>, <code>=true</code>) the boolean to display a slider</li><li><code>show_seq_blocks</code>: (<code>::Bool</code>, <code>=false</code>) the boolean to show sequence blocks</li><li><code>darkmode</code>: (<code>::Bool</code>, <code>=false</code>) the boolean to define colors for darkmode</li><li><code>max_rf_samples</code>: (<code>::Int64</code>, <code>=100</code>) the maximum number of RF samples</li><li><code>range</code>: (<code>::Vector{Float64}</code>, <code>=[]</code>) the time range to be displayed initially</li></ul><p><strong>Returns</strong></p><ul><li><code>p</code>: (<code>::PlotlyJS.SyncPlot</code>) the plot of the sequence struct</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys = Scanner();

julia&gt; FOV, N = 23e-2, 101;

julia&gt; durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse

julia&gt; ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)
Sequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; epi = PulseDesigner.EPI(FOV, N, sys)
Sequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]

julia&gt; seq = ex + epi
Sequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 4 ]

julia&gt; plot_seq(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/ui/DisplayFunctions.jl#L62-L101">source</a></section></article><h3 id="plot_kspace"><a class="docs-heading-anchor" href="#plot_kspace"><code>plot_kspace</code></a><a id="plot_kspace-1"></a><a class="docs-heading-anchor-permalink" href="#plot_kspace" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.plot_kspace" href="#KomaMRI.plot_kspace"><code>KomaMRI.plot_kspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">p = plot_kspace(seq; width=nothing, height=nothing, darkmode=false)</code></pre><p>Plots the k-space of a sequence struct.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Keywords</strong></p><ul><li><code>width</code>: (<code>::Int64</code>, <code>=nothing</code>) the width of the plot</li><li><code>height</code>: (<code>::Int64</code>, <code>=nothing</code>) the height of the plot</li><li><code>darkmode</code>: (<code>::Bool</code>, <code>=false</code>) the boolean to define colors for darkmode</li></ul><p><strong>Returns</strong></p><ul><li><code>p</code>: (<code>::PlotlyJS.SyncPlot</code>) the plot of the k-space of the sequence struct <code>seq</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys = Scanner();

julia&gt; FOV, N = 23e-2, 101;

julia&gt; durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse

julia&gt; ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)
Sequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; epi = PulseDesigner.EPI(FOV, N, sys)
Sequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]

julia&gt; seq = ex + epi
Sequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 4 ]

julia&gt; plot_kspace(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/ui/DisplayFunctions.jl#L328-L363">source</a></section></article><h3 id="plot_M0"><a class="docs-heading-anchor" href="#plot_M0"><code>plot_M0</code></a><a id="plot_M0-1"></a><a class="docs-heading-anchor-permalink" href="#plot_M0" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.plot_M0" href="#KomaMRI.plot_M0"><code>KomaMRI.plot_M0</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">p = plot_M0(seq; height=nothing, width=nothing, slider=true, darkmode=false)</code></pre><p>Plots the magnetization M0 of a sequence struct.</p><p><strong>Arguments</strong></p><ul><li><code>seq</code>: (<code>::Sequence</code>) the sequence struct</li></ul><p><strong>Keywords</strong></p><ul><li><code>height</code>: (<code>::Int64</code>, <code>=nothing</code>) the height of the plot</li><li><code>width</code>: (<code>::Int64</code>, <code>=nothing</code>) the width of the plot</li><li><code>slider</code>: (<code>::Bool</code>, <code>=true</code>) the boolean to display a slider</li><li><code>darkmode</code>: (<code>::Bool</code>, <code>=false</code>) the boolean to define colors for darkmode</li></ul><p><strong>Returns</strong></p><ul><li><code>p</code>: (<code>::PlotlyJS.SyncPlot</code>) the plot of the magnetization M0 of the sequence struct <code>seq</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys = Scanner();

julia&gt; FOV, N = 23e-2, 101;

julia&gt; durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse

julia&gt; ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)
Sequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; epi = PulseDesigner.EPI(FOV, N, sys)
Sequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]

julia&gt; seq = ex + epi
Sequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 4 ]

julia&gt; plot_M0(seq)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/ui/DisplayFunctions.jl#L424-L460">source</a></section></article><h3 id="plot_signal"><a class="docs-heading-anchor" href="#plot_signal"><code>plot_signal</code></a><a id="plot_signal-1"></a><a class="docs-heading-anchor-permalink" href="#plot_signal" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.plot_signal" href="#KomaMRI.plot_signal"><code>KomaMRI.plot_signal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">p = plot_signal(raw::RawAcquisitionData; height, width, darkmode, range)</code></pre><p>Plots a raw signal in ISMRMRD format.</p><p><strong>Arguments</strong></p><ul><li><code>raw</code>: (<code>::RawAcquisitionData</code>) the RawAcquisitionData struct which is the raw signal in   ISMRMRD format</li></ul><p><strong>Keywords</strong></p><ul><li><code>width</code>: (<code>::Int64</code>, <code>=nothing</code>) the width of the plot</li><li><code>height</code>: (<code>::Int64</code>, <code>=nothing</code>) the height of the plot</li><li><code>darkmode</code>: (<code>::Bool</code>, <code>=false</code>) the boolean to define colors for darkmode</li><li><code>range</code>: (<code>::Vector{Float64}</code>, <code>=[]</code>) the time range to be displayed initially</li></ul><p><strong>Returns</strong></p><ul><li><code>p</code>: (<code>::PlotlyJS.SyncPlot</code>) the plot of the raw signal</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sys = Scanner();

julia&gt; FOV, N = 23e-2, 101;

julia&gt; durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse

julia&gt; ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)
Sequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; epi = PulseDesigner.EPI(FOV, N, sys)
Sequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]

julia&gt; seq = ex + epi
Sequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 4 ]

julia&gt; plot_seq(seq)

julia&gt; obj = brain_phantom2D();

julia&gt; signal = simulate(obj, seq, sys);

julia&gt; ismrmrd = signal_to_raw_data([signal;;], seq; phantom=obj, sys=sys);

julia&gt; plot_signal(ismrmrd)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/ui/DisplayFunctions.jl#L636-L681">source</a></section></article><h3 id="plot_image"><a class="docs-heading-anchor" href="#plot_image"><code>plot_image</code></a><a id="plot_image-1"></a><a class="docs-heading-anchor-permalink" href="#plot_image" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="KomaMRI.plot_image" href="#KomaMRI.plot_image"><code>KomaMRI.plot_image</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">p = plot_image(image; height, width, zmin, zmax, darkmode, title)</code></pre><p>Plots an image matrix.</p><p><strong>Arguments</strong></p><ul><li><code>image</code>: (<code>::Matrix{Float64}</code>) the image matrix</li></ul><p><strong>Keywords</strong></p><ul><li><code>height</code>: (<code>::Int64</code>, <code>=750</code>) the height of the plot</li><li><code>width</code>: (<code>::Int64</code>, <code>=nothing</code>) the width of the plot</li><li><code>zmin</code>: (<code>::Float64</code>, <code>=minimum(abs.(image[:]))</code>) the reference value for minimum color</li><li><code>zmax</code>: (<code>::Float64</code>, <code>=maximum(abs.(image[:]))</code>) the reference value for maximum color</li><li><code>darkmode</code>: (<code>::Bool</code>, <code>=false</code>) the boolean to define colors for darkmode</li><li><code>title</code>: (<code>::String</code>, <code>=&quot;&quot;</code>) the title of the plot</li></ul><p><strong>Returns</strong></p><ul><li><code>p</code>: (<code>::PlotlyJS.SyncPlot</code>) the plot of the image matrix</li></ul><p><strong>Examples</strong></p><p>Preparation (define scanner and sequence):</p><pre><code class="language-julia-repl hljs">julia&gt; sys = Scanner();

julia&gt; FOV, N = 23e-2, 101;

julia&gt; durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse

julia&gt; ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)
Sequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]

julia&gt; epi = PulseDesigner.EPI(FOV, N, sys)
Sequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]

julia&gt; seq = ex + epi
Sequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 4 ]

julia&gt; plot_seq(seq)

julia&gt; plot_kspace(seq)</code></pre><p>Simulate:</p><pre><code class="language-julia-repl hljs">julia&gt; obj = brain_phantom2D()

julia&gt; signal = simulate(obj, seq, sys);

julia&gt; ismrmrd = signal_to_raw_data([signal;;], seq; phantom=obj, sys=sys);

julia&gt; plot_signal(ismrmrd)</code></pre><p>Reconstruct:</p><pre><code class="language-julia-repl hljs">julia&gt; Nx, Ny = ismrmrd.params[&quot;reconSize&quot;][1:2];

julia&gt; params = Dict{Symbol,Any}(:reco=&gt;&quot;direct&quot;, :reconSize=&gt;(Nx, Ny), :densityWeighting=&gt;true);

julia&gt; acq = AcquisitionData(ismrmrd);

julia&gt; recon = reconstruction(acq, params);

julia&gt; image = reshape(recon.data, Nx, Ny, :)
102×102×1 Array{ComplexF64, 3}:
[:, :, 1] =
 0.0+0.0im  0.0+0.0im  …  0.0+0.0im
 0.0+0.0im  0.0+0.0im     0.0+0.0im
    ⋮           ⋮       ⋱      ⋮
 0.0+0.0im  0.0+0.0im  …  0.0+0.0im

julia&gt; slice_abs = abs.(image[:, :, 1])
102×102 Matrix{Float64}:
 0.0  0.0  …  0.0
 0.0  0.0     0.0
  ⋮        ⋱   ⋮
 0.0  0.0  …  0.0

julia&gt; plot_image(slice_abs)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cncastillo/KomaMRI.jl/blob/88a60504d5b0bcb9f7524b1a567f4039bbd1fc6a/src/ui/DisplayFunctions.jl#L214-L295">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mri-theory/">« Simulation Method</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Tuesday 18 October 2022 19:32">Tuesday 18 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
