var documenterSearchIndex = {"docs":
[{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"EditURL = \"https://github.com/cncastillo/KomaMRI.jl/blob/master/examples/lit-03-ChemicalShiftEPI.jl\"","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/#Chemical-Shift-in-an-EPI-sequence","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"","category":"section"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"(Image: )","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"filename = last(splitpath(@__FILE__)) # hide\nisFileMD = occursin(\".md\", filename) # hide\nisFileJL = occursin(\".jl\", filename) # hide\n\nusing KomaMRI # hide\nsys = Scanner() # hide","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"For a more realistic example, we will use a brain phantom.","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"obj = brain_phantom2D() # a slice of a brain\np1 = plot_phantom_map(obj, :T2 ; height=400)\np2 = plot_phantom_map(obj, :Œîw ; height=400)\nif isFileMD savefig(p1, \"../assets/2-phantom1.html\") end # hide\nif isFileMD savefig(p2, \"../assets/2-phantom2.html\") end # hide\nif isFileJL display(p1) end # hide\nif isFileJL display(p2) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"At the left, you can see the T_2 map of the phantom, and at the right, the off-resonance Deltaomega. In this example, the fat is the only source of off-resonance (with Delta f =  -220mathrmHz) and you can see it in black in the off-resonance map.","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"<object type=\"text/html\" data=\"../../assets/2-phantom1.html\" style=\"width:50%; height:420px;\"></object><object type=\"text/html\" data=\"../../assets/2-phantom2.html\" style=\"width:50%; height:420px;\"></object>","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"Then, we will load an EPI sequence, that is well known for being affected by off-resonance. With this sequence, we will be able visualize the effect of the chemical shift.","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"seqFile = joinpath(dirname(pathof(KomaMRI)), \"../examples/3.koma_paper/comparison_accuracy/sequences/EPI/epi_100x100_TE100_FOV230.seq\")\nseq = read_seq(seqFile)\np3 = plot_seq(seq; range=[0 40], slider=true, height=300)\nif isFileMD savefig(p3, \"../assets/2-seq.html\") end # hide\nif isFileJL display(p3) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"Feel free to explore the sequence's plot üîç below!","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"<object type=\"text/html\" data=\"../../assets/2-seq.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"If we simulate this sequence we will end up with the following signal.","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"raw = simulate(obj, seq, sys)\np4 = plot_signal(raw; range=[98.4 103.4] , height=300)\nif isFileMD savefig(p4, \"../assets/2-signal.html\") end # hide\nif isFileJL display(p4) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"<object type=\"text/html\" data=\"../../assets/2-signal.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"Now, we need to inspect what effect the off-resonance had in the reconstructed image. As you can see, the fat layer is now shifted to a different position ü§Ø, this is why the effect is called chemical shift!","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"# Get the acquisition data\nacq = AcquisitionData(raw)\nacq.traj[1].circular = false #This is to remove a circular mask\n\n# Setting up the reconstruction parameters\nNx, Ny = raw.params[\"reconSize\"][1:2]\nreconParams = Dict{Symbol,Any}(:reco=>\"direct\", :reconSize=>(Nx, Ny))\nimage = reconstruction(acq, reconParams)\n\n# Plotting the recon\nslice_abs = abs.(image[:, :, 1])\np5 = plot_image(slice_abs; height=400)\nif isFileMD savefig(p5, \"../assets/2-recon.html\") end # hide\nif isFileJL display(p5) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"<center><object type=\"text/html\" data=\"../../assets/2-recon.html\" style=\"width:65%; height:420px;\"></object></center>","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"","category":"page"},{"location":"generated/lit-03-ChemicalShiftEPI/","page":"Chemical Shift in an EPI sequence","title":"Chemical Shift in an EPI sequence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"EditURL = \"https://github.com/cncastillo/KomaMRI.jl/blob/master/examples/lit-01-FID.jl\"","category":"page"},{"location":"generated/lit-01-FID/#Free-Induction-Decay","page":"Free Induction Decay","title":"Free Induction Decay","text":"","category":"section"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"(Image: )","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"filename = last(splitpath(@__FILE__)) # hide\nisFileMD = occursin(\".md\", filename) # hide\nisFileJL = occursin(\".jl\", filename) # hide","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"First of all, let's use the KomaMRI package and define the default scanner.","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"using KomaMRI\nsys = Scanner() # default hardware definition\nnothing # hide","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"The free induction decay is the simplest observable NMR signal. This signal is the one that follows a single tipping RF pulse. To recreate this experiment, we will need to define a Sequence with 2 blocks.","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"The first block containing an RF pulse with a flip-angle of 90 deg,","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"ampRF = 2e-6                        # 2 uT RF amplitude\ndurRF = œÄ / 2 / (2œÄ * Œ≥ * ampRF)    # required duration for a 90 deg RF pulse\nexc = RF(ampRF,durRF)\nnothing # hide","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"and the second block containing the ADC.","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"nADC = 8192         # number of acquisition samples\ndurADC = 250e-3     # duration of the acquisition\ndelay =  1e-3       # small delay\nacq = ADC(nADC, durADC, delay)\nnothing # hide","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"Finally, we concatenate the sequence blocks to create the final sequence (for more info. refer to Sequence Structure).","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"seq = Sequence()  # empty sequence\nseq += exc        # adding RF-only block\nseq += acq        # adding ADC-only block\np1 = plot_seq(seq; slider=false, height=300)\nif isFileMD savefig(p1, \"../assets/1-seq.html\") end # hide\nif isFileJL display(p1) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"<object type=\"text/html\" data=\"../../assets/1-seq.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"Now, we will define a Phantom with a single spin at x=0 with T_1=1000mathrmms and T_2=100mathrmms.","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"obj = Phantom{Float64}(x=[0.], T1=[1000e-3], T2=[100e-3])\nnothing # hide","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"Finally, to simulate we will need to use the function simulate.","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"raw = simulate(obj, seq, sys)","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"To plot the results we will need to use the plot_signal function","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"p2 = plot_signal(raw; slider=false, height=300)\nif isFileMD savefig(p2, \"../assets/1-signal.html\") end # hide\nif isFileJL display(p2) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"<object type=\"text/html\" data=\"../../assets/1-signal.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"Nice!, we can see that S(t) follows an exponential decay exp(-tT_2) as expected.","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"For a little bit of spiciness, let's add off-resonance to our example. We will use Delta f=-100mathrmHz. For this, we will need to add a definition for Œîw in our Phantom","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"obj = Phantom{Float64}(x=[0.], T1=[1000e-3], T2=[100e-3], Œîw=[-2œÄ*100])\nnothing # hide","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"and simulate again.","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"raw = simulate(obj, seq, sys)\np3 = plot_signal(raw; slider=false, height=300)\nif isFileMD savefig(p3, \"../assets/1-signal2.html\") end # hide\nif isFileJL display(p3) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"<object type=\"text/html\" data=\"../../assets/1-signal2.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"The signal now follows an exponential of the form exp(-tT_2)cdotexp(-iDeltaomega t). The addition of exp(-iDeltaomega t) to the signal will generate a shift in the image space (Fourier shifting property). This effect will be better visualized and explained in later examples.","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"","category":"page"},{"location":"generated/lit-01-FID/","page":"Free Induction Decay","title":"Free Induction Decay","text":"This page was generated using Literate.jl.","category":"page"},{"location":"mri-theory-informal/#MRI-Theory","page":"MRI Theory","title":"MRI Theory","text":"","category":"section"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"This section is meant to be a general overview or summary of the main MRI concepts and insights. It is a good starting point to show up the most relevant components involved and how they are related for raw signal acquisition and image reconstruction. The idea is to have a fresh and clear understanding of what is happening behind the scenes when using the KomaMRI.jl package. Some light background in Differential Equations, Signal Processing and Fourier Theory is advisable to follow along.   ","category":"page"},{"location":"mri-theory-informal/#Raw-Signal-Generation","page":"MRI Theory","title":"Raw Signal Generation","text":"","category":"section"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"In order to generate an image from a phantom object with a scanner system and sequence signals, its necessary to acquire a raw signal s(t). This signal can be though as the sum of all spin magnetizations M of the object:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"s(t) =\nint_x int_y int_z\nunderbrace\nM(x y z t)\n_approx  alpha  image(xyz) \n mathrmdz  mathrmdy  mathrmdx","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Note that the magnitude of the magnetization is kind of proportional to the image. In real life it's not possible to get directly all the spin magnetizations, however it's possible to obtain the sum of all of them in the raw signal. To avoid losing image information in the sum operation, every spin magnetization resonates with different Larmor frequencies which values depend on the position (xyz) (i.e. modulated or encoded with the basis of the spatial frequency domain). Thus the raw signal can be thought as:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"beginalign tag1\n\ns(t) approx\nint_x int_y int_z\nunderbrace\nm(x y z)\n_alpha  image(xyz)\nunderbrace\ne^-j 2 pi k_x(t) x + k_y(t) y + k_z(t) z\n_modulation  basis \n mathrmdz  mathrmdy  mathrmdx\n\nendalign","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"where:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"veck(t) =\nbeginpmatrix\nk_x(t) \nk_y(t) \nk_z(t)\nendpmatrix =\nfrac2pigamma\nbeginpmatrix\nint_0^t G_x(tau) mathrmd tau\nint_0^t G_y(tau) mathrmd tau\nint_0^t G_z(tau) mathrmd tau\nendpmatrix\n  \nbeginmatrix*l\ngamma  gyromagnetic  ratio \nG_i(t)  input  gradient  signals\nendmatrix*","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"In the above expressions, we can see that the frequency of each spin can be manipulated by applying input gradient signals (or a gradient field). In practice, this gradient field is applied in the longitudinal axis hatz (but it is always dependent on the (xyz) position), which makes the spins able to resonate (or precess) at different Larmor frequencies after another input RF pulse excite them in the transverse direction. Both inputs, the gradient signal and the RF pulse, are part of the effective magnetic field vecB(t):","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"vecB(t) = \nbeginpmatrix\nB_1x(t) \nB_1y(t) \nG_x(t) x + G_y(t) y + G_z(t) z\nendpmatrix\n  \nbeginmatrix*l\nB_1i(t)  input  RF  pulse  (transverse) \nG_i(t)      input  gradients  (longitudinal)\nendmatrix*","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"It's important to highlight that the coil that senses the raw signal can only detects magnetization components oriented in the transverse direction. For this reason is necessary to apply the short RF signal orthogonally to the longitudinal hatz axe.","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"One of the primary concerns, to generate an image is to design proper input signals for the effective magnetic field vecB(t). In particular, by inspecting equation (1), it's possible to manipulate the spacial frequencies k_x(t), k_y(t) and k_z(t) by applying the gradients G_x(t), G_y(t) and G_z(t). Thus, we have information of the raw signal s(t) an the basis e^-j 2 pi k_x(t) x + k_y(t) y + k_z(t) z. Mathematically speaking, every sample of the raw signal is the Fourier transform of the magnetization m(xyz) for a specific point of the spacial frequency domain:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"s(t) = Fourierm  (k_x(t) k_y(t) k_z(t))","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Therefore, to get the magnetization m(xyz) for all the points in the spacial domain its necessary to solve the inverse problem with enough points to cover the complete spacial frequency domain, which can be achieved by following a trajectory over time applying different gradient signals (i.e. a trajectory to complete the k-space).","category":"page"},{"location":"mri-theory-informal/#K-Space-and-Acquisition","page":"MRI Theory","title":"K-Space and Acquisition","text":"","category":"section"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Note that the trajectory to cover the k-space eventually can have any continuos shape, however it cannot fill the complete space. Furthermore, due to natural hardware restrictions, the continuos trajectory is sampled during the acquisition of the raw signal st. Thus, every discrete point of st represents a discrete point in the k-space.","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Intuitively, it is desirable to get many points as possible and homogeneously distributed in the k-space. In particular, since the theory behind the raw signal generation is intimately related with the Fourier Transform, a natural way to cover the k-space is by taken a discrete mesh grid of points (trajectories and samples separated by small cubes). In this case, it is possible to apply Fourier theory to define the minimal k-space resolution (separation of the samples in the k-space) to set space dimensions (Field of Views) and prevent aliasing in the image, and define maximal limits in the k-space to set space resolution in the image.","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"underbrace\nDelta k_i\n_k-space  resolution\nlongrightarrow\nunderbrace\nFOV_i\n_space  width  bounds ","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"underbrace\nW_k_i\n_k-space  width  bounds\nlongrightarrow\nunderbrace\nDelta i\n_space  resolution ","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"forall i in x y  z","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Even though a mesh grid of discrete points is the natural way of thinking to cover the k-space, it is always possible possible to apply more exotic k-space trajectories, which could be helpful, for instance, to reduce the complete acquisition time. Keep in mind though, this fact must be regarded when solving the inverse problem for obtaining the image, for example by applying and interpolation function before taking the inverse Fourier Transform.","category":"page"},{"location":"mri-theory-informal/#Spin-Dynamics","page":"MRI Theory","title":"Spin Dynamics","text":"","category":"section"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"It's important to point out that all the magnetization spins are independent from each other, so we could separate the phantom object into multiple spins and solve the Bloch Equations for every magnetization vector vecM independently:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"fracmathrmd vecMmathrmd t =\n  gamma vecM times vecB\n- fracM_x hatx + M_y hatyT_2\n- fracM_z hatx + M_0 hatyT_1","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"or:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"beginalign tag2\n\nfracmathrmdmathrmdt vecM =\nunderbrace\ngamma\nbeginbmatrix\n 0     B_z  -B_y \n-B_z   0     B_x \n B_y  -B_x   0\nendbmatrix\nvecM\n_textrotation \n-\nunderbrace\nbeginbmatrix\ntfrac1T_2  0  0 \n0  tfrac1T_2  0 \n0  0  tfrac1T_1\nendbmatrix\nvecM\n_textrelaxation \n+\nunderbrace\nbeginbmatrix\n0 \n0 \ntfracM_0T_1\nendbmatrix\n_textsteady-state \n\nendalign","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"beginmatrix*l\ngamma  gyromagnetic  ratio \nT_2     transverse  relaxation  time  constant \nT_1     longitudinal  relaxation  time  constant\nendmatrix*","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"vecM(t) =\nbeginpmatrix\nM_x(t) \nM_y(t) \nM_z(t)\nendpmatrix\n  \nvecB(t) = \nbeginpmatrix\nB_x(t) \nB_y(t) \nB_z(t)\nendpmatrix =\nbeginpmatrix\nB_1x(t) \nB_1y(t) \nG_x(t) x + G_y(t) y + G_z(t) z\nendpmatrix","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"beginmatrix*l\nB_1i(t)  input  RF  pulse  (transverse) \nG_i(t)      input  gradients  (longitudinal)\nendmatrix*","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Note that equation (2) can be separated into three parts:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Rotation: governed by the inputs RF pulse and gradient signals. It gives an initial excitation and the oscillatory behavior for different Larmor frequencies, respectively. \nRelaxation: gives the decay behavior (the magnetization envelope) after the excitation of the spins.\nSteady-State: spins points towards the longitudinal direction after a while.","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Thus, to get the raw signal s(t) it's necessary to solve the Bloch equations (equation (2)) for every spin of the phantom object, then sum up the contributions of all of them and finally consider just the components of the transverse plane:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"s(t) = s_xy(t)\n  \ns_xy(t) = s_x(t) + j s_y(t)","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"beginpmatrix\ns_x(t) \ns_y(t) \ns_z(t)\nendpmatrix =\nint_x int_y int_z\nvecM(x y z t)\n mathrmdz  mathrmdy  mathrmdx","category":"page"},{"location":"docstrings/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"docstrings/#dataflow-graph","page":"API Documentation","title":"Dataflow Graph","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"(Image: )","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Pages = [\"docstrings.md\"]\nDepth = 3","category":"page"},{"location":"docstrings/#datatypes","page":"API Documentation","title":"DataTypes","text":"","category":"section"},{"location":"docstrings/#Mag","page":"API Documentation","title":"Mag","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Mag\nshow(::IO, ::Mag)\ngetproperty(::Vector{Mag}, ::Symbol)","category":"page"},{"location":"docstrings/#KomaMRI.Mag","page":"API Documentation","title":"KomaMRI.Mag","text":"mag = Mag(xy::Complex, z::Real)\n\nThe Magnetization struct.\n\nArguments\n\nxy: (::Complex{Float64}) magnetization of a spin in the xy plane\nz: (::Real) magnetization of a spin in the z plane\n\nReturns\n\nmag: (::Mag) Magnetization struct\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Phantom","page":"API Documentation","title":"Phantom","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.Phantom ‚Äî Type\nKomaMRI.brain_phantom2D ‚Äî Function\nKomaMRI.brain_phantom3D ‚Äî Function","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.heart_phantom","category":"page"},{"location":"docstrings/#KomaMRI.heart_phantom","page":"API Documentation","title":"KomaMRI.heart_phantom","text":"phantom = heart_phantom(Œ±=1, Œ≤=1, Œ≥=1, fat_bool::Bool=false)\n\nHeart-like LV phantom. The variable Œ± is for streching, Œ≤ for contraction, and Œ≥ for rotation.\n\nArguments\n\nŒ±: (::Real, =1) streching parameter\nŒ≤: (::Real, =1) contraction parameter\nŒ≥: (::Real, =1) rotation parameter\nfat_bool: (::Bool, =false) fat boolean parameter\n\nReturns\n\nphantom: (::Phantom) Heart-like LV phantom struct\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Scanner","page":"API Documentation","title":"Scanner","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.Scanner ‚Äî Type","category":"page"},{"location":"docstrings/#Sequence","page":"API Documentation","title":"Sequence","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.Sequence ‚Äî Type","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"show(::IO, ::Sequence)\nKomaMRI.is_ADC_on\nKomaMRI.is_RF_on\nKomaMRI.is_GR_on\nKomaMRI.is_Gx_on\nKomaMRI.is_Gy_on\nKomaMRI.is_Gz_on\nKomaMRI.is_Delay\nKomaMRI.durs(::Sequence)\ndur(::Sequence)\nKomaMRI.‚è¢\nKomaMRI.get_grads\nKomaMRI.get_rfs\nKomaMRI.get_flip_angles\nKomaMRI.get_ADC_on\nKomaMRI.get_kspace\nKomaMRI.get_RF_types\n\nKomaMRI.Œ¥2N","category":"page"},{"location":"docstrings/#Base.show-Tuple{IO, Sequence}","page":"API Documentation","title":"Base.show","text":"str = show(io::IO, s::Sequence)\n\nDisplays information about the Sequence struct s in the julia REPL.\n\nArguments\n\ns: (::Sequence) Sequence struct\n\nReturns\n\nstr (::String) output string message\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.is_ADC_on","page":"API Documentation","title":"KomaMRI.is_ADC_on","text":"y = is_ADC_on(x::Sequence)\ny = is_ADC_on(x::Sequence, t::Union{Array{Float64,1}, Array{Float64,2}})\n\nTells if the sequence seq has elements with ADC active, or active during time t.\n\nArguments\n\nx: (::Sequence) sequence struct\nt: (::Union{Array{Float64,1}, Array{Float64,2}}, [s]) time to check\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the ADC in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.is_RF_on","page":"API Documentation","title":"KomaMRI.is_RF_on","text":"y = is_RF_on(x::Sequence)\ny = is_RF_on(x::Sequence, t::Vector{Float64})\n\nTells if the sequence seq has elements with RF active, or active during time t.\n\nArguments\n\nx: (::Sequence) Sequence struct\nt: (::Vector{Float64}, [s]) time to check\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the RF in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.is_GR_on","page":"API Documentation","title":"KomaMRI.is_GR_on","text":"y = is_GR_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GR in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.is_Gx_on","page":"API Documentation","title":"KomaMRI.is_Gx_on","text":"y = is_Gx_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in x direction.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GRx in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.is_Gy_on","page":"API Documentation","title":"KomaMRI.is_Gy_on","text":"y = is_Gy_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in y direction.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GRy in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.is_Gz_on","page":"API Documentation","title":"KomaMRI.is_Gz_on","text":"y = is_Gz_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in z direction.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Bool) boolean that tells whether or not the GRz in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.is_Delay","page":"API Documentation","title":"KomaMRI.is_Delay","text":"y = is_Delay(x::Sequence)\n\nTells if the sequence seq is a delay.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny::Bool: boolean that tells whether or not the sequence is a delay\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.durs-Tuple{Sequence}","page":"API Documentation","title":"KomaMRI.durs","text":"ŒîT = durs(x::Sequence)\n\nReturns the array of durations of sequence's blocks in [s].\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\nŒîT: (::Vector{Real}, [s]) array of durations of sequence's blocks\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.dur-Tuple{Sequence}","page":"API Documentation","title":"KomaMRI.dur","text":"T = dur(x::Sequence)\n\nThe total duration of the sequence in [s].\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\nT: (::Real, [s]) total duration of the sequence\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.‚è¢","page":"API Documentation","title":"KomaMRI.‚è¢","text":"y = ‚è¢(A, t, ŒîT, Œ∂1, Œ∂2, delay)\n\nGenerates a trapezoidal waveform vector.\n\nArguments\n\nA: (::Real) amplitude\nt: (::Vector{Float64}, [s]) times to evaluate (actually it's a 1-row   ::Matrix{Float64})\nŒîT: (::Real, [s]) time duration of the top-flat\nŒ∂1: (::Real, [s]) rise time duration\nŒ∂2: (::Real, [s]) fall time duration\ndelay: (::Real, [s]) delay time\n\nReturns\n\ny: (::Vector{Float64}) trapezoidal waveform (actually it's a 1-row   ::Matrix{Float64})\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_grads","page":"API Documentation","title":"KomaMRI.get_grads","text":"Gx, Gy, Gz = get_grads(seq, t::Vector)\nGx, Gy, Gz = get_grads(seq, t::Matrix)\n\nGet the gradient array from sequence seq evaluated in time points t.\n\nArguments\n\nseq: (::Sequence) Sequence struct\nt: (::Vector{Float64} or 1-row ::Matrix{Float64}, [s]) times to evaluate\n\nReturns\n\nGx: (Vector{Float64} or 1-row ::Matrix{Float64}, [T]) gradient vector values   in the x direction\nGy: (Vector{Float64} or 1-row ::Matrix{Float64}, [T]) gradient vector values   in the y direction\nGz: (Vector{Float64} or 1-row ::Matrix{Float64}, [T]) gradient vector values   in the z direction\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_rfs","page":"API Documentation","title":"KomaMRI.get_rfs","text":"B1, Œîf_rf  = get_rfs(seq::Sequence, t)\n\nReturns the RF pulses and the delta frequency.\n\nArguments\n\nseq: (::Sequence) Sequence struct\nt: (1-row ::Matrix{Float64}, [s]) time points\n\nReturns\n\nB1: (1-row ::Matrix{ComplexF64}, [T]) vector of RF pulses\nŒîf_rf: (1-row ::Matrix{Float64}, [Hz]) delta frequency vector\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_flip_angles","page":"API Documentation","title":"KomaMRI.get_flip_angles","text":"y = get_flip_angles(x::Sequence)\n\nReturns all the flip angles of the RF pulses in the sequence x.\n\nArguments\n\nx: (::Sequence) Sequence struct\n\nReturns\n\ny: (::Vector{Float64}, [deg]) flip angles\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_ADC_on","page":"API Documentation","title":"KomaMRI.get_ADC_on","text":"y = get_ADC_on(seq::Sequence, t::Array{Float64,1})\n\nGet the ADC struct that are active.\n\nnote: Note\nThis function is not being used.\n\nArguments\n\nseq: (::Sequence) Sequence struct\nt: (::Vector{Float64}, [s]) the time vector\n\nReturns\n\ny: (::Vector{Bool}) ADC struct that are active\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_kspace","page":"API Documentation","title":"KomaMRI.get_kspace","text":"kspace, kspace_adc = get_kspace(seq::Sequence; Œît=1)\n\nOutputs designed k-space trajectory from sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\nŒît: (::Real, =1, [s]) nominal delta time separation between two time samples   for ADC acquisition and Gradients\n\nReturns\n\nkspace: (3-column ::Matrix{Float64}) kspace\nkspace_adc: (3-column ::Matrix{Float64}) adc kspace\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_RF_types","page":"API Documentation","title":"KomaMRI.get_RF_types","text":"rf_idx, rf_type = get_RF_types(seq, t)\n\nGet RF centers and types (excitation or precession). Useful for k-space calculations.\n\nArguments\n\nseq: (::Sequence) Sequence struct\nt: (::Vector{Float64}, [s]) time values\n\nReturns\n\nrf_idx: (::Vector{Int64}) indices of the RF centers\nrf_type: (::Vector{Int64}, opts: [0, 1]) RF type (0: excitation, 1:   precession)\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Grad","page":"API Documentation","title":"Grad","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.Grad ‚Äî Type\nKomaMRI.Grad(::Function, ::Real, ::Int64) ‚Äî Method","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"rotx\nroty\nrotz\nshow(::IO, ::Grad)\ngetproperty(::Vector{Grad}, ::Symbol)\ndur(::Grad)","category":"page"},{"location":"docstrings/#KomaMRI.rotx","page":"API Documentation","title":"KomaMRI.rotx","text":"Rx = rotx(Œ∏::Real)\n\nRotates vector counter-clockwise with respect to the x-axis.\n\nArguments\n\nŒ∏: (::Real, [rad]) rotation angle\n\nReturns\n\nRx: (::Matrix{Int64}) rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.roty","page":"API Documentation","title":"KomaMRI.roty","text":"Ry = roty(Œ∏::Real)\n\nRotates vector counter-clockwise with respect to the y-axis.\n\nArguments\n\nŒ∏: (::Real, [rad]) rotation angle\n\nReturns\n\nRy: (::Matrix{Int64}) rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.rotz","page":"API Documentation","title":"KomaMRI.rotz","text":"Rz = rotz(Œ∏::Real)\n\nRotates vector counter-clockwise with respect to the z-axis.\n\nArguments\n\nŒ∏: (::Real, [rad]) rotation angle\n\nReturns\n\nRz: (::Matrix{Int64}) rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Base.show-Tuple{IO, Grad}","page":"API Documentation","title":"Base.show","text":"str = show(io::IO, x::Grad)\n\nDisplays information about the Grad struct x in the julia REPL.\n\nArguments\n\nx: (::Grad) Grad struct\n\nReturns\n\nstr (::String) output string message\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.getproperty-Tuple{Vector{Grad}, Symbol}","page":"API Documentation","title":"Base.getproperty","text":"y = getproperty(x::Vector{Grad}, f::Symbol)\ny = getproperty(x::Matrix{Grad}, f::Symbol)\n\nOverloads Base.getproperty(). It is meant to access properties of the Grad vector x directly without the need to iterate elementwise.\n\nArguments\n\nx: (::Vector{Grad} or ::Matrix{Grad}) vector or matrix of Grad structs\nf: (::Symbol, opts: [:x, :y, :z, :T, :delay, :rise, :delay, :dur,   :A, f]) input symbol that represents a property of the vector or matrix of Grad   structs\n\nReturns\n\ny: (::Vector{Any} or ::Matrix{Any}) vector or matrix with the property defined   by the symbol f for all elements of the Grad vector or matrix x\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.dur-Tuple{Grad}","page":"API Documentation","title":"KomaMRI.dur","text":"y = dur(x::Grad)\ny = dur(x::Vector{Grad})\n\nDuration time in [s] of Grad struct or Grad array. When the input is a gradient vector, then the duration is the maximum duration of all the elements of the gradient vector.\n\nArguments\n\nx: (::Grad or ::Vector{Grad}) RF struct or RF array\n\nReturns\n\ny: (::Float64, [s]) duration of the RF struct or RF array\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#RF","page":"API Documentation","title":"RF","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.RF ‚Äî Type","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Spinor\nshow(::IO,::Spinor)\n*(::Spinor, ::Spinor)\nRz\nRy\nRx\nKomaMRI.Rg\nKomaMRI.RœÜ\nQ\nabs(::Spinor)\n\nshow(::IO, ::RF)\ngetproperty(::Vector{RF}, ::Symbol)\ndur(::RF)\nKomaMRI.RF_fun\nKomaMRI.get_flip_angle\nKomaMRI.get_RF_center","category":"page"},{"location":"docstrings/#KomaMRI.Spinor","page":"API Documentation","title":"KomaMRI.Spinor","text":"spinor = Spinor(Œ±, Œ≤)\n\nSpinor(Œ±, Œ≤) with Cayley-Klein parameters Œ± and Œ≤. Based on \"Introduction to the Shinnar-Le Roux algorithm\", Patrick Le Roux (1995). A spinor is a way to represent 3D rotations, the underlying representation is a 2 X 2 complex unitary matrix (alphabetainmathbbC):\n\nR=leftbeginarraycc\nalpha  -beta^*\nbeta  alpha^*\nendarrayright\n\nwith alpha^2+beta^2 = 1.\n\nThis later operates on the 2times2 representation of (xyz) as follows V^+ = R V R^*.\n\nArguments\n\nŒ±: (::Complex{Float64}) Cayley-Klein parameter Œ±\nŒ≤: (::Complex{Float64}) Cayley-Klein parameter Œ≤\n\nReturns\n\nspinor: (::Spinor) Spinor struct\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Base.show-Tuple{IO, Spinor}","page":"API Documentation","title":"Base.show","text":"str = show(io::IO, s::Spinor)\n\nDisplays the spinor parameters in the julia REPL.\n\nArguments\n\ns: (::Spinor) Spinor struct\n\nReturns\n\nstr: (::String) output string message\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:*-Tuple{Spinor, Spinor}","page":"API Documentation","title":"Base.:*","text":"s = *(s1::Spinor, s2::Spinor)\n\nSpinor multiplication identity: (Œ±1,Œ≤1)√ó(Œ±2,Œ≤2) = (Œ±1 Œ±2 - Œ≤2‚ãÜ Œ≤1 , Œ≤2 Œ±1 + Œ±2‚ãÜ Œ≤1)\n\nArguments\n\ns1: (::Spinor) first spinor struct\ns2: (::Spinor) second spinor struct\n\nReturns\n\ns: (::Spinor) multiplication spinnor identity result\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.Rz","page":"API Documentation","title":"KomaMRI.Rz","text":"s = Rz(œÜ)\n\nSpinor clockwise rotation matrix with angle œÜ with respect to z-axis.\n\nArguments\n\nœÜ: (::Real, [rad]) angle with respect to z-axis\n\nReturns\n\ns: (::Spinor) spinnor struct that represents the Rz rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.Ry","page":"API Documentation","title":"KomaMRI.Ry","text":"s = Ry(Œ∏)\n\nSpinor clockwise rotation matrix with angle Œ∏ with respect to y-axis.\n\nArguments\n\nŒ∏: (::Real, [rad]) angle with respect to y-axis\n\nReturns\n\ns: (::Spinor) spinor struct that represents the Ry rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.Rx","page":"API Documentation","title":"KomaMRI.Rx","text":"s = Rx(Œ∏)\n\nSpinor clockwise rotation matrix with angle Œ∏ with respect to x-axis.\n\nArguments\n\nŒ∏: (::Real, [rad]) angle with respect to x-axis\n\nReturns\n\ns: (::Spinor) spinor struct that represents the Rx rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.Rg","page":"API Documentation","title":"KomaMRI.Rg","text":"s = Rg(œÜ1, Œ∏, œÜ2)\n\nSpinor rotation matrix: Rg(œÜ1, Œ∏, œÜ2) = Rz(œÜ2) Ry(Œ∏) Rz(œÜ1)\n\nArguments\n\nœÜ1: (::Real, [rad]) œÜ1 angle\nŒ∏: (::Real, [rad]) Œ∏ angle\nœÜ2: (::Real, [rad]) œÜ2 angle\n\nReturns\n\ns: (::Spinor) spinor struct that represents the Rg rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.RœÜ","page":"API Documentation","title":"KomaMRI.RœÜ","text":"s = RœÜ(œÜ, Œ∏)\n\nSpinor rotation matrix with angle Œ∏ with axis in the xy plane u=(cosœÜ, sinœÜ).\n\nRœÜ(œÜ,Œ∏) = Rg(-œÜ,Œ∏,œÜ) = Rz(œÜ) Ry(Œ∏) Rz(-œÜ)\n\nArguments\n\nœÜ: (::Real, [rad]) œÜ angle\nŒ∏: (::Real, [rad]) Œ∏ angle\n\nReturns\n\ns: (::Spinor) spinnor struct that represents the RœÜ rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.Q","page":"API Documentation","title":"KomaMRI.Q","text":"s = Q(œÜ, nxy, nz)\n\nSpinor rotation matrix. Rotation of œÜ with respect to the axis of rotation n=(nx, ny, nz).\n\nPauly, J., Le Roux, P., Nishimura, D., & Macovski, A. (1991). Parameter relations for the Shinnar-Le Roux selective excitation pulse design algorithm (NMR imaging). IEEE Transactions on Medical Imaging, 10(1), 53-65. doi:10.1109/42.75611\n\nvarphi=-gammaDelta tsqrtleftB_1right^2+left(boldsymbolGcdotboldsymbolx\nright)^2=-gammaDelta tleftVert boldsymbolBrightVert\n\nboldsymboln=boldsymbolBleftVert boldsymbolBrightVert\n\nArguments\n\nœÜ: (::Real, [rad]) œÜ angle\nnxy: (::Real) nxy factor\nnz: (::Real) nz factor\n\nReturns\n\ns: (::Spinor) spinnor struct that represents the Q rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Base.abs-Tuple{Spinor}","page":"API Documentation","title":"Base.abs","text":"y = abs(s::Spinor)\n\nIt calculates |Œ±|^2 + |Œ≤|^2 of the Cayley-Klein parameters.\n\nArguments\n\ns: (::Spinor) spinnor struct\n\nReturns\n\ny: (::Real) result of the abs operator\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.show-Tuple{IO, RF}","page":"API Documentation","title":"Base.show","text":"str = show(io::IO, x::RF)\n\nDisplays information about the RF struct x in the julia REPL.\n\nArguments\n\nx: (::RF) RF struct\n\nReturns\n\nstr: (::String) output string message\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.getproperty-Tuple{Vector{RF}, Symbol}","page":"API Documentation","title":"Base.getproperty","text":"y = getproperty(x::Vector{RF}, f::Symbol)\ny = getproperty(x::Matrix{RF}, f::Symbol)\n\nOverloads Base.getproperty(). It is meant to access properties of the RF vector x directly without the need to iterate elementwise.\n\nArguments\n\nx: (::Vector{RF} or ::Matrix{RF}) vector or matrix of RF structs\nf: (::Symbol, opts: [:A, :Bx, :By, :T, :Œîf, :delay and :dur]) input   symbol that represents a property of the vector or matrix of RF structs\n\nReturns\n\ny: (::Vector{Any} or ::Matrix{Any}) vector with the property defined by the   symbol f for all elements of the RF vector or matrix x\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.dur-Tuple{RF}","page":"API Documentation","title":"KomaMRI.dur","text":"y = dur(x::RF)\ny = dur(x::Array{RF,1})\ny = dur(x::Array{RF,2})\n\nDuration time in [s] of RF struct or RF array.\n\nArguments\n\nx: (::RF or ::Array{RF,1} or ::Array{RF,2}) RF struct or RF array\n\nReturns\n\ny: (::Float64, [s]) duration of the RF struct or RF array\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.get_flip_angle","page":"API Documentation","title":"KomaMRI.get_flip_angle","text":"Œ± = get_flip_angle(x::RF)\n\nCalculates the flip angle Œ± [deg] of an RF struct. Œ± = Œ≥ ‚à´ B1(œÑ) dœÑ\n\nArguments\n\nx: (::RF) RF struct\n\nReturns\n\nŒ±: (::Int64, [deg]) flip angle RF struct x\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_RF_center","page":"API Documentation","title":"KomaMRI.get_RF_center","text":"t = get_RF_center(x::RF)\n\nCalculates the time where is the center of the RF pulse x. This calculation includes the RF delay.\n\nArguments\n\nx: (::RF) RF struct\n\nReturns\n\nt: (::Int64, [s]) time where is the center of the RF pulse x\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#ADC","page":"API Documentation","title":"ADC","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.ADC ‚Äî Type","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"getproperty(::Vector{ADC}, ::Symbol)\nKomaMRI.get_adc_sampling_times\nKomaMRI.get_adc_phase_compensation","category":"page"},{"location":"docstrings/#Base.getproperty-Tuple{Vector{ADC}, Symbol}","page":"API Documentation","title":"Base.getproperty","text":"y = getproperty(x::Vector{ADC}, f::Symbol)\n\nOverloads Base.getproperty(). It is meant to access properties of the ADC vector x directly without the need to iterate elementwise.\n\nArguments\n\nx: (::Vector{ADC}) vector of ADC structs\nf: (::Symbol, opts: [:N, :T, :delay, :Œîf, :œï, :dur]) input symbol that   represents a property of the ACD structs\n\nReturns\n\ny: (::Vector{Any}) vector with the property defined by the f for all elements of   the ADC vector x\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.get_adc_sampling_times","page":"API Documentation","title":"KomaMRI.get_adc_sampling_times","text":"times = get_adc_sampling_times(seq)\n\nReturns an array of times when the samples of the sequence seq are acquired.\n\nArguments\n\nseq: (::Sequence) sequence struct\n\nReturns\n\ntimes: (::Vector{Float64}, [s]) time array when samples are acquired\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_adc_phase_compensation","page":"API Documentation","title":"KomaMRI.get_adc_phase_compensation","text":"phase = get_adc_phase_compensation(seq)\n\nReturns the array of phases for every acquired sample in the sequence seq.\n\nnote: Note\nThis function is useful to compensate the phase when the RF pulse has a phase too. Refer to the end of the run_sim_time_iter function to see its usage.\n\nArguments\n\nseq: (::Sequence) sequence struct\n\nReturns\n\nphase: (::Vector{Complex{Int64}}, [rad]) array of phases for every acquired sample\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Delay","page":"API Documentation","title":"Delay","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.Delay ‚Äî Type","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"show(::IO, ::Delay)\n+(::Sequence, ::Delay)","category":"page"},{"location":"docstrings/#Base.show-Tuple{IO, Delay}","page":"API Documentation","title":"Base.show","text":"str = show(io::IO, s::Delay)\n\nDisplays the delay time in m[s] of the delay struct s in the julia REPL.\n\nArguments\n\ns: (::Delay) delay struct\n\nReturns\n\nstr: (::String) output string message\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:+-Tuple{Sequence, Delay}","page":"API Documentation","title":"Base.:+","text":"seq = +(s::Sequence, d::Delay)\nseq = +(d::Delay, s::Sequence)\n\nAdd a delay to sequence struct. It ultimately affects to the duration of the gradients of a sequence.\n\nArguments\n\ns: (::Sequence) sequence struct\nd: (::Delay) delay struct\n\nReturns\n\nseq: (::Sequence) delayed sequence\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#pulseq","page":"API Documentation","title":"Pulseq.jl","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.read_seq ‚Äî Function","category":"page"},{"location":"docstrings/#read_Grad","page":"API Documentation","title":"read_Grad","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.read_Grad","category":"page"},{"location":"docstrings/#KomaMRI.read_Grad","page":"API Documentation","title":"KomaMRI.read_Grad","text":"grad = read_Grad(gradLibrary, shapeLibrary, Œît_gr, i)\n\nReads the gradient. It is used internally by get_block.\n\nArguments\n\ngradLibrary: (::Dict{K, V}) the \"gradLibrary\" dictionary\nshapeLibrary: (::Dict{K, V}) the \"shapeLibrary\" dictionary\nŒît_gr: (::Float64, [s]) gradient raster time\ni: (::Int64) index of the axis in the block event\n\nReturns\n\ngrad: (::Grad) Gradient struct\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#read_RF","page":"API Documentation","title":"read_RF","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.read_RF","category":"page"},{"location":"docstrings/#KomaMRI.read_RF","page":"API Documentation","title":"KomaMRI.read_RF","text":"rf = read_RF(rfLibrary, shapeLibrary, Œît_rf, i)\n\nReads the RF. It is used internally by get_block.\n\nArguments\n\nrfLibrary: (::Dict{K, V}) the \"rfLibrary\" dictionary\nshapeLibrary: (::Dict{K, V}) the \"shapeLibrary\" dictionary\nŒît_rf: (::Float64, [s]) RF raster time\ni: (::Int64) index of the RF in the block event\n\nReturns\n\nrf: (1x1 ::Matrix{RF}) RF struct\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#read_ADC","page":"API Documentation","title":"read_ADC","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.read_ADC","category":"page"},{"location":"docstrings/#KomaMRI.read_ADC","page":"API Documentation","title":"KomaMRI.read_ADC","text":"adc = read_ADC(adcLibrary, i)\n\nReads the ADC. It is used internally by get_block.\n\nArguments\n\nadcLibrary: (::Dict{String, Any}) the \"adcLibrary\" dictionary\ni: (::Int64) index of the adc in the block event\n\nReturns\n\nadc: (1x1 ::Vector{ADC}) ADC struct\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#get_block","page":"API Documentation","title":"get_block","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.get_block","category":"page"},{"location":"docstrings/#KomaMRI.get_block","page":"API Documentation","title":"KomaMRI.get_block","text":"seq = get_block(obj, i)\n\nBlock sequence definition. Used internally by read_seq.\n\nArguments\n\nobj: (::Dict{String, Any}) main dictionary\ni: (::Int64) index of a block event\n\nReturns\n\ns: (::Sequence) block Sequence struct\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#jemris","page":"API Documentation","title":"JEMRIS.jl","text":"","category":"section"},{"location":"docstrings/#read_phantom_jemris","page":"API Documentation","title":"read_phantom_jemris","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.read_phantom_jemris ‚Äî Function","category":"page"},{"location":"docstrings/#ismrmrd","page":"API Documentation","title":"ISMRMRD.jl","text":"","category":"section"},{"location":"docstrings/#signal_to_raw_data","page":"API Documentation","title":"signal_to_raw_data","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.signal_to_raw_data ‚Äî Function","category":"page"},{"location":"docstrings/#pulse-designer","page":"API Documentation","title":"PulseDesigner.jl","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.PulseDesigner ‚Äî Function\nKomaMRI.PulseDesigner.RF_hard ‚Äî Function\nKomaMRI.PulseDesigner.EPI ‚Äî Function\nKomaMRI.PulseDesigner.radial_base ‚Äî Function","category":"page"},{"location":"docstrings/#key-values-calculation","page":"API Documentation","title":"KeyValuesCalculation.jl","text":"","category":"section"},{"location":"docstrings/#get_theo_A","page":"API Documentation","title":"get_theo_A","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.get_theo_A","category":"page"},{"location":"docstrings/#KomaMRI.get_theo_A","page":"API Documentation","title":"KomaMRI.get_theo_A","text":"A = get_theo_A(g::Grad; off_val=0)\nA = get_theo_A(r::RF; off_val=0, max_rf_samples=Inf)\nA = get_theo_A(d::ADC; off_val=0)\n\nGet the theoretical amplitudes of a rectangle waveform for Grad, RF or ADC structs. This are 5 points: delay, start, rise, stop and fall.\n\nnote: Note\nIn some cases the array result can have duplicated points, so it is necessary to remove them whenever necessary.\n\nArguments\n\ng: (::Grad) Gradient struct\nr: (::RF) RF struct\nd: (::ADC) ADC truct\n\nKeywords\n\noff_val: (::Float64, =0) offset value for amplitude. In general, it is used for   not showing some points in plots by giving an Inf value\nmax_rf_samples: (::Float64, =Inf) number of maximum samples for the RF struct.   In general, this parameter is not necessary to set\n\nReturns\n\nA: (::Vector{Float64}) vector with the amplitude key points of the rectangle   waveform\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#get_theo_t","page":"API Documentation","title":"get_theo_t","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.get_theo_t","category":"page"},{"location":"docstrings/#KomaMRI.get_theo_t","page":"API Documentation","title":"KomaMRI.get_theo_t","text":"t = get_theo_t(g::Grad)\nt = get_theo_t(r::RF; max_rf_samples=Inf)\nt = get_theo_t(d::ADC)\n\nGet the theoretical times of a rectangle waveform for Grad, RF or ADC structs. This are 5 points: delay, start, rise, stop and fall.\n\nnote: Note\nIn some cases the array result can have duplicated points, so it is necessary to remove them whenever necessary.\n\nArguments\n\ng: (::Grad) Gradient struct\nr: (::RF) RF struct\nd: (::ADC) ADC truct\n\nKeywords\n\nmax_rf_samples: (::Float64, =Inf) number of maximum samples for the RF struct.   In general, this parameter is not necessary to set\n\nReturns\n\nt: (::Vector{Float64}) vector with the time key points of the rectangle waveform\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#get_theo_Gi","page":"API Documentation","title":"get_theo_Gi","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.get_theo_Gi","category":"page"},{"location":"docstrings/#KomaMRI.get_theo_Gi","page":"API Documentation","title":"KomaMRI.get_theo_Gi","text":"t, g = get_theo_Gi(seq, idx)\n\nGet the theoretical gradient for a sequence in a defined axis.\n\nArguments\n\nseq: (::Sequence) Sequence struct\nidx: (::Int64, opts=[1, 2, 3]) axis x, y or z for the gradient\n\nReturns\n\nt: (::Vector{Float64}) time key points\ng: (::Vector{Float64}) amplitude key points\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#trapezoidal-integration","page":"API Documentation","title":"TrapezoidalIntegration.jl","text":"","category":"section"},{"location":"docstrings/#trapz","page":"API Documentation","title":"trapz","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.trapz","category":"page"},{"location":"docstrings/#KomaMRI.trapz","page":"API Documentation","title":"KomaMRI.trapz","text":"y = trapz(Œît, x)\n\nTrapezoidal integration for every spin of a phantom.\n\nnote: Note\nIn practice, this function is used to integrate (Gx * x + Gy * y + Gz * z) * Œît for all the spins. NŒît is the length of Œît. Ns stands for the number of spins of a phantom. x is a matrix which rows represents different spins and columns are different times and the elements are the field Gx * x + Gy * y + Gz * z values.\n\nArguments\n\nŒît: (1 x NŒît ::Matrix{Float64}, [s]) delta time 1-row array\nx: (Ns x (NŒît+1) ::Matrix{Float64}, [T]) magnitude of the field Gx * x + Gy * y +   Gz * z\n\nReturns\n\ny: (Ns x 1 ::Matrix{Float64}, [T*s]) vector where every element is the integral   of (Gx * x + Gy * y + Gz * z) * Œît for every spin of a phantom\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#cumtrapz","page":"API Documentation","title":"cumtrapz","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.cumtrapz","category":"page"},{"location":"docstrings/#KomaMRI.cumtrapz","page":"API Documentation","title":"KomaMRI.cumtrapz","text":"y = cumtrapz(Œît, x)\n\nTrapezoidal cumulative integration over time for every spin of a phantom.\n\nArguments\n\nŒît: (1 x NŒît ::Matrix{Float64}, [s]) delta time 1-row array\nx: (Ns x (NŒît+1) ::Matrix{Float64}, [T]) magnitude of the field Gx * x + Gy * y +   Gz * z\n\nReturns\n\ny: (Ns x NŒît ::Matrix{Float64}, [T*s]) matrix where every column is the   cumulative integration over time of (Gx * x + Gy * y + Gz * z) * Œît for every spin of a   phantom\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#time-step-calculation","page":"API Documentation","title":"TimeStepCalculation.jl","text":"","category":"section"},{"location":"docstrings/#points_from_key_times","page":"API Documentation","title":"points_from_key_times","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.points_from_key_times","category":"page"},{"location":"docstrings/#KomaMRI.points_from_key_times","page":"API Documentation","title":"KomaMRI.points_from_key_times","text":"t = points_from_key_times(times; dt)\n\nReturns a vector which contains the same points as times but with additional points that have a separation of at most dt.\n\nnote: Note\nThe last time points could not be present in the output in some cases. Some time points could be duplicated in the output. Duplicated time points should be removed afterwards (done by     get_variable_times). The output represents all time points regarded during the simulation with a \"nominal\" dt separation between two samples.\n\nArguments\n\ntimes: (::Vector{Float64}, [s]) time array with key points you want to keep\n\nKeywords\n\ndt: (::Float64, [s]) maximum delta time separation between two time samples\n\nReturns\n\nt: (::Vector{Float64}, [s]) time array with the same points as the input array but with   additional points that have a separation of at most dt.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#get_variable_times","page":"API Documentation","title":"get_variable_times","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.get_variable_times","category":"page"},{"location":"docstrings/#KomaMRI.get_variable_times","page":"API Documentation","title":"KomaMRI.get_variable_times","text":"t, Œît = get_variable_times(seq; dt=1, dt_rf=1e-4)\n\nThis function returns non-uniform time points that are relevant in the sequence seq.\n\nnote: Note\nIt is important to use a variable time step (instead of constant sampling time) to increase the simulation speed.\n\nArguments\n\nseq: (::Sequence) Sequence struct\ndt: (::Real, =1, [s]) nominal delta time separation between two time samples   for ADC acquisition and Gradients (by nominal we mean that the time separation should be   at most Œît when the samples are regarded by KomaMRI.is_ADC_on or   KomaMRI.is_GR_on), otherwise the time points are not necessary and the   separation will be bigger)\n\nKeywords\n\nŒît_rf: (::Real, =1e-4, [s]) nominal delta time separation between two time   samples for RF excitation (by nominal we mean that the time separation should be at most   Œît_rf when the samples are regarded by KomaMRI.is_RF_on, otherwise the time   points are not necessary and the separation will be bigger)\n\nReturns\n\nt: (::Vector{Float64}, [s]) time array with non-uniform time values\nŒît: (::Vector{Float64}, [s]) delta time array with the separation between two   adjacent time points of the t time array\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#get_uniform_times","page":"API Documentation","title":"get_uniform_times","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.get_uniform_times","category":"page"},{"location":"docstrings/#KomaMRI.get_uniform_times","page":"API Documentation","title":"KomaMRI.get_uniform_times","text":"t, Œît = get_uniform_times(seq, Œît; Œît_rf=1e-4)\n\nThis function, despite its name, actually gets non-uniform time points. Refer to get_variable_times for more details.\n\nnote: Note\nThis function should be deprecated and the simulator should only use the get_variable_times function. Note that in this KomaMRI version, this function is bypassed by get_variable_times.\n\nArguments\n\nseq: (::Sequence) Sequence struct\nŒît: (::Real, [s]) nominal delta time separation between two time samples for ADC   acquisition and Gradients (by nominal we mean that the time separation should be at   most Œît when the samples are regarded by KomaMRI.is_ADC_on or   KomaMRI.is_GR_on), otherwise the time points are not necessary and the   separation will be bigger)\n\nKeywords\n\nŒît_rf: (::Real, =1e-4, [s]) nominal delta time separation between two time   samples for RF excitation (by nominal we mean that the time separation should be at most   Œît_rf when the samples are regarded by KomaMRI.is_RF_on, otherwise the time   points are not necessary and the separation will be bigger)\n\nReturns\n\nt: (::Vector{Float64}, [s]) time array with non-uniform time values\nŒît: (::Vector{Float64}, [s]) delta time array with the separation between two   adjacent time points of the t time array\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#kfoldperm","page":"API Documentation","title":"kfoldperm","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.kfoldperm","category":"page"},{"location":"docstrings/#KomaMRI.kfoldperm","page":"API Documentation","title":"KomaMRI.kfoldperm","text":"array_of_ranges = kfoldperm(N, k; type=\"random\", breaks=[])\n\nDivides a list of indices 1:N (which is in your imagination) into k groups.\n\nnote: Note\nIt is possible to predifine some break points at specific indices with the breaks keyword, in this case the number of groups could increase. This is useful to define start and end indices of RF pulses to separate the simulation into excitation and preccesion computations.\n\nArguments\n\nN: (::Int64) the number of elements to be ordered (of an imaginary array 1:N)\nk: (::Int64) the number of groups to divide the N elements\n\nKeywords\n\ntype: (::String, =\"random\", opts: [\"random\", \"ordered\"]) the order type option.   If random, then the indices of the groups are unordered. If \"ordered\", then the indices   of the groups are sorted in an incremental order\nbreaks: (::Vector{Int64}, =[]) the array of indices where predefined break points   are placed\n\nReturns\n\narray_of_ranges: (::Vector{UnitRange{Int64}}) the array that contains ranges of   different groups (the aim target are k groups, but this could be increased by adding   elements in the breaks input array)\n\nExamples\n\njulia> kfoldperm(20, 3; type=\"ordered\")\n3-element Vector{UnitRange{Int64}}:\n 1:7\n 8:14\n 15:20\n\njulia> kfoldperm(20, 3; type=\"ordered\", breaks=[3])\n4-element Vector{UnitRange{Int64}}:\n 1:2\n 3:7\n 8:14\n 15:20\n\njulia> kfoldperm(20, 3; type=\"ordered\", breaks=[3, 10])\n5-element Vector{UnitRange{Int64}}:\n 1:2\n 3:7\n 8:9\n 10:14\n 15:20\n\njulia> kfoldperm(20, 3; type=\"ordered\", breaks=[3, 10, 17])\n6-element Vector{UnitRange{Int64}}:\n 1:2\n 3:7\n 8:9\n 10:14\n 15:16\n 17:20\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#get_breaks_in_RF_key_points","page":"API Documentation","title":"get_breaks_in_RF_key_points","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.get_breaks_in_RF_key_points","category":"page"},{"location":"docstrings/#KomaMRI.get_breaks_in_RF_key_points","page":"API Documentation","title":"KomaMRI.get_breaks_in_RF_key_points","text":"key_idxs = get_breaks_in_RF_key_points(seq::Sequence, t)\n\nReturn the indices of the t time array where are RF key points from the seq sequence. Thus, it is possible to split the simulation into excitation and preccesion computations.\n\nnote: Note\nBy RF key points we mean all the start and end points where the RF excitation takes place with the KomaMRI.is_RF_on function.\n\nArguments\n\nseq: (::Sequence) Sequence struct\nt: (::Vector{Int64}, [s]) non-uniform time array\n\nReturns\n\nkey_idxs: (::Vector{Int64}) array of indices of the t time array where are RF key   points\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#simulation-core","page":"API Documentation","title":"SimulationCore.jl","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.simulate ‚Äî Function\nKomaMRI.simulate_slice_profile ‚Äî Function","category":"page"},{"location":"docstrings/#print_gpus","page":"API Documentation","title":"print_gpus","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.print_gpus","category":"page"},{"location":"docstrings/#KomaMRI.print_gpus","page":"API Documentation","title":"KomaMRI.print_gpus","text":"print_gpus()\n\nSimple function to print the CUDA devices available in the host.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#run_spin_precession","page":"API Documentation","title":"run_spin_precession","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.run_spin_precession","category":"page"},{"location":"docstrings/#run_spin_precession_parallel","page":"API Documentation","title":"run_spin_precession_parallel","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.run_spin_precession_parallel","category":"page"},{"location":"docstrings/#run_spin_excitation","page":"API Documentation","title":"run_spin_excitation","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.run_spin_excitation","category":"page"},{"location":"docstrings/#run_spin_excitation_parallel","page":"API Documentation","title":"run_spin_excitation_parallel","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.run_spin_excitation_parallel","category":"page"},{"location":"docstrings/#run_sim_time_iter","page":"API Documentation","title":"run_sim_time_iter","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.run_sim_time_iter","category":"page"},{"location":"docstrings/#display-functions","page":"API Documentation","title":"DisplayFunctions.jl","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.plot_seq ‚Äî Function\nKomaMRI.plot_image ‚Äî Function\nplot_kspace ‚Äî Function\nplot_M0 ‚Äî Function\nplot_phantom_map ‚Äî Function\nplot_signal ‚Äî Function","category":"page"},{"location":"docstrings/#theme_chooser","page":"API Documentation","title":"theme_chooser","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.theme_chooser","category":"page"},{"location":"docstrings/#KomaMRI.theme_chooser","page":"API Documentation","title":"KomaMRI.theme_chooser","text":"bgcolor, text_color, plot_bgcolor, grid_color, sep_color = theme_chooser(darkmode)\n\nDefine colors for dark or light mode.\n\nArguments\n\ndarkmode: (::Bool) boolean that selects dark or light mode\n\nReturns\n\nbgcolor: (::String) backgound color\ntext_color: (::String) text color\nplot_bgcolor: (::String) color background for the plots\ngrid_color: (::String) color of the grids\nsep_color: (::String) color of separator lines\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#interp_map","page":"API Documentation","title":"interp_map","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.interp_map","category":"page"},{"location":"docstrings/#KomaMRI.interp_map","page":"API Documentation","title":"KomaMRI.interp_map","text":"c_map_interp = interp_map(c_map, t_interp)\n\nInterpolates a color map. This is used for plotting the kspace (refer to plot_kspace).\n\nArguments\n\nc_map: (::Vector{Vector{Any}})color map. Every element of this vector has a   vector with a number between 0-1 in its first element and a color string in its second   element. It serves as a reference to create a color map with more elements\nt_interp: (::Vector{Float64}) the vector with values between 0-1 that are the   reference for interpolate the color map with more elements\n\nReturns\n\nc_map_interp: (::Vector{String}) vector with color strings with interpolated   values\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#plot_dict","page":"API Documentation","title":"plot_dict","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.plot_dict","category":"page"},{"location":"docstrings/#KomaMRI.plot_dict","page":"API Documentation","title":"KomaMRI.plot_dict","text":"str = plot_dict(dict::Dict)\n\nGenerates a string in html format of the dictionary dict.\n\nArguments\n\ndict: (::Dict) dictionary to generate the html string\n\nReturns\n\nstr: (::String) string of the dictionary dict which is a table in html format\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"KomaMRI was written in Julia, so the first thing you should do is to install it! The latest version of Julia can be downloaded at the Julia Downloads page. It is advisable you add julia to the PATH, which can be done during the installation process.","category":"page"},{"location":"getting-started/#Installing-KomaMRI","page":"Getting Started","title":"Installing KomaMRI","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Once Julia is installed, open the Julia REPL and add the KomaMRI package. To bring up Julia's package manager enter ], and then add the KomaMRI package. This process should take about 5 minutes in a fresh Julia installation. ","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n\n(@v1.8) pkg> add KomaMRI","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Then press Ctrl+C or backspace to return to the julia> prompt.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"getting-started/#My-First-MRI-Simulation","page":"Getting Started","title":"My First MRI Simulation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For our first simulation we will use Koma's graphical user interface (GUI). For this, you will first need to load KomaMRI by typing using KomaMRI, and then lauch the GUI with KomaUI().","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> using KomaMRI\n\njulia> KomaUI()","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The first time you use this command it may take more time than usual, but a window with the Koma GUI will pop up:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The user interface has some basic definitions for the scanner, phantom, and sequence already preloaded. So you can immediately interact with the simulation and reconstruction processes, and then visualize the results.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"As a simple demonstration, press the button Simulate! and wait until the simulation is ready. Then click on the Raw Data dropdown and then click on the View Raw Data button. You should see the following:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Then, press the button Reconstruct! and wait until the reconstruction ends. Then click on the Reconstruction dropdown and then click on the |Image| button to see the image reconstruction: ","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Congratulations, you successfully simulated an MRI acquisition! üéä","category":"page"},{"location":"sequence/#Sequence-Definition","page":"-","title":"Sequence Definition","text":"","category":"section"},{"location":"sequence/","page":"-","title":"-","text":"This subsection dives into some details about how a sequence is constructed. Let's introduce the following simple sequence figure to extend the ideas from a visual example to a more general sequence definition:","category":"page"},{"location":"sequence/","page":"-","title":"-","text":"<p align=\"center\">\n<img width=\"90%\" src=\"assets/sequence-diagram.svg\"/>\n</p>","category":"page"},{"location":"sequence/","page":"-","title":"-","text":"A sequence can be thought as and ordered concatenation of blocks over time. Every block is composed by an RF pulse, the (xyz) gradients,  and the acquisition of the samples. There is also a time duration associated to each block. For short, we are going to refer to these components like so:","category":"page"},{"location":"sequence/","page":"-","title":"-","text":"beginmatrix*l\ni            textsequence block ID \nRFi        textRF pulse at the i block \nG_ji       textgradients at the i block  forall j in xyz \nADCi       textacquisition at the i block \nDURi       textduration at the i block\nendmatrix*","category":"page"},{"location":"sequence/","page":"-","title":"-","text":"Additionally, there are associated some uniform time resolution parameters or raster times for the RF, gradients and adquistion:","category":"page"},{"location":"sequence/","page":"-","title":"-","text":"beginmatrix*l\nDelta t_RF     textraster time for RF pulses\nDelta t_G      textraster time for gradients\nDelta t_ADC    textraster time for acquisition\nendmatrix*","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"This page shows the documentation for the modules, structs, functions, methods and additional components available when importing the KomaMRI.jl package. It is very useful for reference when using directly the Julia REPL and when creating custom Julia scripts. Please, don't miss out the section How to read the API docs which has important considerations to understand general aspects of the docstring structure. The following are the contents of the API Documentation:","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Pages = [\"api.md\"]\nDepth = 3","category":"page"},{"location":"api/#How-to-read-the-API-docs","page":"API Documentation","title":"How to read the API docs","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"The API documentation has predefined \"template patterns\" which are meant to help the user to understand how to use modules, structs, functions, methods and every aspect necessary in order to take advantage of all the possibilities that KomaMRI.jl offers.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"These documentation \"template patterns\" are based from the Julia Blue Style documentation and other github repositories that works with MRI topics. However, some custom considerations were added for a better understanding and a wider perspective.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Whenever you see a docstring documentation, it will have the following structure:","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"docstring: KomaMRI.component_name ‚Äî Component\nout1, out2, ... = component_name(arg1, arg2, ...; kw1, kw2, ...)This is a brief description of what component_name does.note: Note\nHere can be placed a note if it is regarded necessary.Argumentsarg1: (::type, =value, [unit], opts: [opt1, opt2, ...]) the description for the arg1\n...Keywordskw1: (::type, =value, [unit], opts: [opt1, opt2, ...]) the description for the kw1\n...Returnsout1: (::type, =value, [unit], opts: [opt1, opt2, ...]) the description for the out1\n...ReferencesSometimes it is a good idea to put some references or links\n...Examplesjulia> arg1, arg2, valkw1, valkw2 = 3.5, \"hello\", 1, true\n\njulia> out1, out2 = component_name(arg1, arg2; kw1=valkw1, kw2=valkw2)","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"The previous docstring block will always have first the way how it is called the component (outputs = component_name(inputs) and next a brief description about what the component does. Then a note block will be displayed if necessary. As general rule, the next subsections are optional: Arguments, Keywords, Returns, References and Examples, however they will be displayed whenever necessary. These subsections are self-explanatory, so it is intuitive to figure out what are they meant for.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Note that every subitem in the sections Arguments, Keywords and Returns are variables. They have practical information enclosed in parentheses plus a description. They information in parentheses is optional but very useful if it is present:","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"::type: is the suggested type of the variable. If the input variable is of type ::type, then nothing can go wrong, but it is always possible to test other types. If the variable is an output, then it will always try to be forced to the type ::type.\n=value: sometimes for the inputs the is defined a default value if it is not assigned by the user.\n[unit]: this is the suggested physical unit of measure of the variable. Everything it is going to be fine if you are stick with these units of measure.\nopts: [opt1, opt2, ...]: sometimes the input value can only be interpreted if it is part of some predefined values.","category":"page"},{"location":"api/#Structs","page":"API Documentation","title":"Structs","text":"","category":"section"},{"location":"api/#Scanner","page":"API Documentation","title":"Scanner","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Scanner","category":"page"},{"location":"api/#KomaMRI.Scanner","page":"API Documentation","title":"KomaMRI.Scanner","text":"scanner = Scanner(B0, B1, Gmax, Smax, ADC_Œît, seq_Œît, GR_Œît, RF_Œît,\n    RF_ring_down_T, RF_dead_time_T, ADC_dead_time_T)\n\nThe Scanner struct.\n\nArguments\n\nB0: (::Real, =1.5, [T]) main magnetic field\nB1: (::Real, =10e-6, [T]) maximum RF amplitude\nGmax: (::Real, =60e-3, [T/m]) maximum Gradient\nSmax: (::Real, =500, [mT/m/ms]) maximum slew-rate\nADC_Œît: (::Real, =2e-6, [s]) ADC raster time\nseq_Œît: (::Real, =1e-5, [s]) sequence-block raster time\nGR_Œît: (::Real, =1e-5, [s]) gradient raster time\nRF_Œît: (::Real, =1e-6, [s]) RF raster time\nRF_ring_down_T: (::Real, =20e-6, [s]) RF ring down time\nRF_dead_time_T: (::Real, =100e-6, [s]) RF dead time\nADC_dead_time_T: (::Real, =10e-6, [s]) ADC dead time\n\nReturns\n\nscanner: (::Scanner) Scanner struct\n\n\n\n\n\n","category":"type"},{"location":"api/#Phantom","page":"API Documentation","title":"Phantom","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Phantom\nbrain_phantom2D\nbrain_phantom3D","category":"page"},{"location":"api/#KomaMRI.Phantom","page":"API Documentation","title":"KomaMRI.Phantom","text":"phantom = Phantom(name, x, y, z, œÅ, T1, T2, T2s, Œîw, DŒª1, DŒª2, DŒ∏, ux, uy, uz)\n\nThe Phantom struct.\n\nArguments\n\nname: (::String) name of the Phantom\nx: (::Vector{Float64}, [m]) vector of x-positions of the spins\ny: (::Vector{Float64}, [m]) vector of y-positions of the spins\nz: (::Vector{Float64}, [m]) vector of z-positions of the spins\nœÅ: (::Vector{Float64}) vector of proton density of the spins\nT1: (::Vector{Float64}, [s]) vector of T1 parameters of the spins\nT2: (::Vector{Float64}, [s]) vector of T2 parameters of the spins\nT2s: (::Vector{Float64}, [s]) vector of T2s parameters of the spins\nŒîw: (::Vector{Float64}, [rad/s]) vector of off-resonance parameters of the spins\nDŒª1: (::Vector{Float64}) vector of DŒª1 (diffusion) parameters of the spins\nDŒª2: (::Vector{Float64}) vector of DŒª2 (diffusion) parameters of the spins\nDŒ∏: (::Vector{Float64}) vector of DŒ∏ (diffusion) parameters of the spins\nux: (::Function) displacement field in the x-axis\nuy: (::Function) displacement field in the y-axis\nuz: (::Function) displacement field in the z-axis\n\nReturns\n\nphantom: (::Phantom) Phantom struct\n\n\n\n\n\n","category":"type"},{"location":"api/#KomaMRI.brain_phantom2D","page":"API Documentation","title":"KomaMRI.brain_phantom2D","text":"phantom = brain_phantom2D(;axis=\"axial\", ss=4)\n\nCreates a two-dimentional brain phantom struct.\n\nReferences\n\nB. Aubert-Broche, D.L. Collins, A.C. Evans: \"A new improved version of the realistic   digital brain phantom\" NeuroImage, in review - 2006\nB. Aubert-Broche, M. Griffin, G.B. Pike, A.C. Evans and D.L. Collins: \"20 new digital   brain phantoms for creation of validation image data bases\" IEEE TMI, in review - 2006\nhttps://brainweb.bic.mni.mcgill.ca/brainweb\n\nKeywords\n\naxis: (::String, =\"axial\", opts=[\"axial\"]) orientation of the phantom\nss: (::Real, =4) subsampling parameter in all axis\n\nReturns\n\nphantom: (::Phantom) 2D Phantom struct\n\nExamples\n\njulia> obj = brain_phantom2D()\n\njulia> plot_phantom_map(obj, :œÅ)\n\n\n\n\n\n","category":"function"},{"location":"api/#KomaMRI.brain_phantom3D","page":"API Documentation","title":"KomaMRI.brain_phantom3D","text":"phantom = brain_phantom3D(;ss=4)\n\nCreates a three-dimentional brain phantom struct.\n\nReferences\n\nB. Aubert-Broche, D.L. Collins, A.C. Evans: \"A new improved version of the realistic   digital brain phantom\" NeuroImage, in review - 2006\nB. Aubert-Broche, M. Griffin, G.B. Pike, A.C. Evans and D.L. Collins: \"20 new digital   brain phantoms for creation of validation image data bases\" IEEE TMI, in review - 2006\nhttps://brainweb.bic.mni.mcgill.ca/brainweb\n\nKeywords\n\nss: (::Real, =4) subsampling parameter in all axis\n\nReturns\n\nphantom: (::Phantom) 3D Phantom struct\n\nExamples\n\njulia> obj = brain_phantom3D()\n\njulia> plot_phantom_map(obj, :œÅ)\n\n\n\n\n\n","category":"function"},{"location":"api/#Sequence","page":"API Documentation","title":"Sequence","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Sequence","category":"page"},{"location":"api/#KomaMRI.Sequence","page":"API Documentation","title":"KomaMRI.Sequence","text":"seq = Sequence()\nseq = Sequence(GR)\nseq = Sequence(GR, RF)\nseq = Sequence(GR, RF, ADC)\nseq = Sequence(GR, RF, ADC, DUR)\nseq = Sequence(GR::Array{Grad,1})\nseq = Sequence(GR::Array{Grad,1}, RF::Array{RF,1})\nseq = Sequence(GR::Array{Grad,1}, RF::Array{RF,1}, A::ADC, DUR, DEF)\n\nThe Sequence struct.\n\nArguments\n\nGR: (::Matrix{Grad}) gradient matrix, rows are for (x,y,z) and columns are for time\nRF: (::Matrix{RF}) RF matrix, the 1 row is for the coil and columns are for time\nADC: (::Vector{ADC}) ADC vector in time\nDUR: (::Vector{Float64}, [s]) duration of each sequence-block, this enables   delays after RF pulses to satisfy ring-down times\nDEF: (::Dict{String, Any}) dictionary with relevant information of the sequence.   The possible keys are [\"AdcRasterTime\", \"GradientRasterTime\", \"Name\", \"Nz\",   \"Num_Blocks\", \"Nx\", \"Ny\", \"PulseqVersion\", \"BlockDurationRaster\",   \"FileName\", \"RadiofrequencyRasterTime\"]\n\nReturns\n\nseq: (::Sequence) Sequence struct\n\n\n\n\n\n","category":"type"},{"location":"api/#Grad","page":"API Documentation","title":"Grad","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Grad\nGrad(::Function, ::Real, ::Int64)","category":"page"},{"location":"api/#KomaMRI.Grad","page":"API Documentation","title":"KomaMRI.Grad","text":"grad = Grad(A, T)\ngrad = Grad(A, T, rise)\ngrad = Grad(A, T, rise, delay)\ngrad = Grad(A, T, rise, fall, delay)\n\nThe Gradient struct.\n\nArguments\n\nA: (::Float64, [T]) amplitude of the gradient\nT: (::Float64, [s]) duration of the flat-top\nrise: (::Real, [s]) duration of the rise\nfall: (::Real, [s]) duration of the fall\ndelay: (::Real, [s]) duration of the delay\n\nReturns\n\ngrad: (::Grad) gradient struct\n\n\n\n\n\n","category":"type"},{"location":"api/#KomaMRI.Grad-Tuple{Function, Real, Int64}","page":"API Documentation","title":"KomaMRI.Grad","text":"grad = Grad(f::Function, T::Real, N::Int64; delay::Real)\n\nGenerates an arbitrary gradient waveform defined by function f in the interval t ‚àà [0,T]. It uses N square gradients uniformly spaced in the interval.\n\nArguments\n\nf: (::Function) function that describes the gradient waveform\nT: (::Real, [s]) duration of the gradient waveform\nN: (::Int64) number of samples of the gradient waveform\n\nKeywords\n\ndelay: (::Real, =0, [s]) starting delay for the waveform\n\nReturns\n\ngrad: (::Grad) gradient struct\n\nExamples\n\njulia> f1 = t -> sin(œÄ*t / 0.8)\n\njulia> seq = Sequence([Grad(f1, 0.8)])\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"method"},{"location":"api/#RF","page":"API Documentation","title":"RF","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"RF","category":"page"},{"location":"api/#KomaMRI.RF","page":"API Documentation","title":"KomaMRI.RF","text":"rf = RF(A, T)\nrf = RF(A, T, Œîf)\nrf = RF(A, T, Œîf, delay)\n\nThe RF struct.\n\nArguments\n\nA: (::Complex{Int64}, [T]) the amplitud-phase B1x + i B1y\nT: (::Int64, [s]) the duration of the RF\nŒîf: (::Float64, [Hz]) the frequency offset of the RF\ndelay: (::Float64, [s]) the delay time of the RF\n\nReturns\n\nrf: (::RF) the RF struct\n\n\n\n\n\n","category":"type"},{"location":"api/#ADC","page":"API Documentation","title":"ADC","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"ADC","category":"page"},{"location":"api/#KomaMRI.ADC","page":"API Documentation","title":"KomaMRI.ADC","text":"adc = ADC(N, T)\nadc = ADC(N, T, delay)\nadc = ADC(N, T, delay, Œîf, œï)\n\nThe ADC struct.\n\nArguments\n\nN: (::Int64) number of acquired samples\nT: (::Float64, [s]) duration to acquire the samples\ndelay: (::Float64, [s]) delay time to start the acquisition\nŒîf: (::Float64, [Hz]) delta frequency. It's meant to compensate RF pulse phases.   It is used internally by the read_ADC function\nœï: (::Float64, [rad]) phase. It's meant to compensate RF pulse phases. It is   used internally by the read_ADC function\n\nReturns\n\nadc: (::ADC) ADC struct\n\n\n\n\n\n","category":"type"},{"location":"api/#Delay","page":"API Documentation","title":"Delay","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Delay","category":"page"},{"location":"api/#KomaMRI.Delay","page":"API Documentation","title":"KomaMRI.Delay","text":"delay = Delay(T)\n\nThe Delay struct. The input delay time T must be non-negative.\n\nnote: Note\nThis struct is meant to add delays to a sequence struct.\n\nArguments\n\nT: (::Real, [s]) time delay value\n\nReturns\n\ndelay: (::Delay) delay struct\n\n\n\n\n\n","category":"type"},{"location":"api/#Read-Data","page":"API Documentation","title":"Read Data","text":"","category":"section"},{"location":"api/#read_seq","page":"API Documentation","title":"read_seq","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.read_seq","category":"page"},{"location":"api/#KomaMRI.read_seq","page":"API Documentation","title":"KomaMRI.read_seq","text":"seq = read_seq(filename)\n\nReturns the Sequence struct from a sequence file .seq.\n\nArguments\n\nfilename: (::String) the absolute or relative path of the sequence file .seq\n\nReturns\n\nseq: (::Sequence) Sequence struct\n\nExamples\n\njulia> seq = read_seq(\"examples/1.sequences/spiral.seq\")\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"api/#read_phantom_jemris","page":"API Documentation","title":"read_phantom_jemris","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"read_phantom_jemris","category":"page"},{"location":"api/#KomaMRI.read_phantom_jemris","page":"API Documentation","title":"KomaMRI.read_phantom_jemris","text":"phantom = read_phantom_jemris(filename)\n\nReturns the Phantom struct from a JEMRIS phantom file .h5.\n\nArguments\n\nfilename: (::String) the absolute or relative path of the phantom file .h5\n\nReturns\n\nphantom: (::Phantom) Phantom struct\n\nExamples\n\njulia> obj = read_phantom_jemris(\"examples/2.phantoms/brain.h5\")\n\njulia> plot_phantom_map(obj, :œÅ)\n\n\n\n\n\n","category":"function"},{"location":"api/#signal_to_raw_data","page":"API Documentation","title":"signal_to_raw_data","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"signal_to_raw_data","category":"page"},{"location":"api/#KomaMRI.signal_to_raw_data","page":"API Documentation","title":"KomaMRI.signal_to_raw_data","text":"raw_ismrmrd = signal_to_raw_data(signal, seq; phantom, sys, simParams)\n\nTransforms the raw signal into ISMRMRD format.\n\nArguments\n\nsignal: (::Vector{ComplexF64}) raw signal\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nphantom: (::Phantom, =Phantom(name=\"Phantom\",x=[0])) Phantom struct\nsys: (::Scanner, =Scanner()) Scanner struct\nsimParams: (::Dict{String,Any}(), =Dict{String,Any}()) dictionary with   simulation parameters\n\nReturns\n\nraw_ismrmrd: (::RawAcquisitionData) raw signal in ISMRMRD format\n\nExamples\n\njulia> signal = simulate(obj, seq, sys; simParams=Dict{String,Any}(\"return_type\"=>\"mat\"));\n\njulia> ismrmrd = signal_to_raw_data(signal, seq; phantom=obj, sys=sys);\n\njulia> plot_signal(ismrmrd)\n\n\n\n\n\n","category":"function"},{"location":"api/#Pulse-Design","page":"API Documentation","title":"Pulse Design","text":"","category":"section"},{"location":"api/#PulseDesigner","page":"API Documentation","title":"PulseDesigner","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"PulseDesigner","category":"page"},{"location":"api/#KomaMRI.PulseDesigner","page":"API Documentation","title":"KomaMRI.PulseDesigner","text":"PulseDesigner\n\nA module to define different pulse sequences.\n\n\n\n\n\n","category":"module"},{"location":"api/#PulseDesigner.RF_hard","page":"API Documentation","title":"PulseDesigner.RF_hard","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"PulseDesigner.RF_hard","category":"page"},{"location":"api/#KomaMRI.PulseDesigner.RF_hard","page":"API Documentation","title":"KomaMRI.PulseDesigner.RF_hard","text":"ex = RF_hard(B1, T, sys::Scanner; G=[0,0,0], Œîf=0)\n\nDefinition of the RF hard sequence.\n\nArguments\n\nB1: (Float64, [T]) amplitude of the RF pulse\nT: (Float64, [s]) duration of the RF pulse\nsys: (::Scanner) Scanner struct\n\nKeywords\n\nG: (Vector{Float64}, =[0, 0, 0], [T]) gradient amplitudes for x, y, z\nŒîf: (Float64, =0, [Hz]) frequency offset of the RF pulse\n\nReturns\n\nex: (::Sequence) excitation Sequence struct\n\nExamples\n\njulia> sys = Scanner();\n\njulia> durRF = œÄ/2/(2œÄ*Œ≥*sys.B1); #90-degree hard excitation pulse\n\njulia> ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)\nSequence[ œÑ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(ex)\n\n\n\n\n\n","category":"function"},{"location":"api/#PulseDesigner.EPI","page":"API Documentation","title":"PulseDesigner.EPI","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"PulseDesigner.EPI","category":"page"},{"location":"api/#KomaMRI.PulseDesigner.EPI","page":"API Documentation","title":"KomaMRI.PulseDesigner.EPI","text":"epi = EPI(FOV::Float64, N::Int, sys::Scanner)\n\nDefinition of the EPI sequence.\n\nArguments\n\nFOV: (::Float64, [m]) field of view\nN: (::Int) number of pixels in the x and y axis\nsys: (::Scanner) Scanner struct\n\nReturns\n\nepi: (::Sequence) epi Sequence struct\n\nExamples\n\njulia> sys = Scanner();\n\njulia> FOV, N = 23e-2, 101;\n\njulia> epi = PulseDesigner.EPI(FOV, N, sys)\nSequence[ œÑ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]\n\njulia> plot_seq(epi)\n\n\n\n\n\n","category":"function"},{"location":"api/#PulseDesigner.radial_base","page":"API Documentation","title":"PulseDesigner.radial_base","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"PulseDesigner.radial_base","category":"page"},{"location":"api/#KomaMRI.PulseDesigner.radial_base","page":"API Documentation","title":"KomaMRI.PulseDesigner.radial_base","text":"seq = radial_base(FOV::Float64, Nr::Int, sys::Scanner)\n\nDefinition of the radial base sequence.\n\nArguments\n\nFOV: (::Float64, [m]) field of view\nN: (::Int) number of pixels along the radious\nsys: (::Scanner) Scanner struct\n\nReturns\n\nseq: (::Sequence) radial base Sequence struct\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation","page":"API Documentation","title":"Simulation","text":"","category":"section"},{"location":"api/#simulate","page":"API Documentation","title":"simulate","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"simulate","category":"page"},{"location":"api/#KomaMRI.simulate","page":"API Documentation","title":"KomaMRI.simulate","text":"out = simulate(obj::Phantom, seq::Sequence, sys::Scanner; simParams, w)\n\nReturns the raw signal or the last state of the magnetization according to the value of the \"return_type\" key of the simParams dictionary.\n\nArguments\n\nobj: (::Phantom) Phantom struct\nseq: (::Sequence) Sequence struct\nsys: (::Scanner) Scanner struct\n\nKeywords\n\nsimParams: (::Dict{String,Any}, =Dict{String,Any}()) the dictionary with simulation   parameters\nw: (::Any, =nothing) the flag to regard a progress bar in the blink window UI. If   this variable is differnet from nothing, then the progress bar is considered\n\nReturns\n\nout: (::Vector{ComplexF64} or ::S <: SpinStateRepresentation or RawAcquisitionData) depending if   \"return_type\" is \"mat\" or \"state\" or \"raw\" (default) respectively.\n\nExamples\n\njulia> sys, obj, seq = Scanner(), brain_phantom2D(), read_seq(\"examples/1.sequences/spiral.seq\");\n\njulia> ismrmrd = simulate(obj, seq, sys);\n\njulia> plot_signal(ismrmrd)\n\n\n\n\n\n","category":"function"},{"location":"api/#simulate_slice_profile","page":"API Documentation","title":"simulate_slice_profile","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"simulate_slice_profile","category":"page"},{"location":"api/#KomaMRI.simulate_slice_profile","page":"API Documentation","title":"KomaMRI.simulate_slice_profile","text":"M = simulate_slice_profile(seq; z, simParams)\n\nReturns magnetization of spins distributed along z after running the Sequence seq.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nz: (=range(-2e-2,2e-2,200)) range for the z axis\nsimParams: (::Dict{String, Any}, =Dict{String,Any}(\"Œît_rf\"=>1e-6)) dictionary with   simulation parameters\n\nReturns\n\nM: (::Vector{Mag}) final state of the Mag vector\n\n\n\n\n\n","category":"function"},{"location":"api/#Plots","page":"API Documentation","title":"Plots","text":"","category":"section"},{"location":"api/#plot_phantom_map","page":"API Documentation","title":"plot_phantom_map","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"plot_phantom_map","category":"page"},{"location":"api/#KomaMRI.plot_phantom_map","page":"API Documentation","title":"KomaMRI.plot_phantom_map","text":"p = plot_phantom_map(ph, key; t0=0, height=600, width=nothing, darkmode=false)\n\nPlots a phantom map for a specific spin parameter given by key.\n\nArguments\n\nph: (::Phantom) Phantom struct\nkey: (::Symbol, opts: [:œÅ, :T1, :T2, :T2s, :x, :y, :z]) symbol for   displaying different parameters of the phantom spins\n\nKeywords\n\nt0: (::Float64, =0, [ms]) time to see displacement of the phantom\nheight: (::Int64, =600) height of the plot\nwidth: (::Int64, =nothing) width of the plot\ndarkmode: (::Bool, =false) boolean to define colors for darkmode\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the phantom map for a specific spin parameter\n\nReferences\n\nColormaps from https://github.com/markgriswold/MRFColormaps Towards Unified Colormaps for Quantitative MRF Data, Mark Griswold, et al. (2018).\n\nExamples\n\njulia> obj2D, obj3D = brain_phantom2D(), brain_phantom3D();\n\njulia> plot_phantom_map(obj2D, :œÅ)\n\njulia> plot_phantom_map(obj3D, :œÅ)\n\n\n\n\n\n","category":"function"},{"location":"api/#plot_seq","page":"API Documentation","title":"plot_seq","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"plot_seq","category":"page"},{"location":"api/#KomaMRI.plot_seq","page":"API Documentation","title":"KomaMRI.plot_seq","text":"p = plot_seq(seq; width, height, slider, show_seq_blocks, show_sim_blocks, Nblocks,\n        darkmode, max_rf_samples, range)\n\nPlots a sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Int64, =nothing) width of the plot\nheight: (::Int64, =nothing) height of the plot\nslider: (::Bool, =true) boolean to display a slider\nshow_seq_blocks: (::Bool, =false) boolean to show sequence blocks\nshow_sim_blocks: (::Bool, =false) boolean to show simulation blocks\nNblocks: (::Int64, =0) number of simulation blocks to display\ndarkmode: (::Bool, =false) boolean to define colors for darkmode\nmax_rf_samples: (::Int64, =100) maximum number of RF samples\nrange: (::Vector{Float64}, =[]) time range to be displayed initially\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the Sequence struct\n\nExamples\n\njulia> seq = read_seq(\"examples/1.sequences/spiral.seq\")\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"api/#plot_kspace","page":"API Documentation","title":"plot_kspace","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"plot_kspace","category":"page"},{"location":"api/#KomaMRI.plot_kspace","page":"API Documentation","title":"KomaMRI.plot_kspace","text":"p = plot_kspace(seq; width=nothing, height=nothing, darkmode=false)\n\nPlots the k-space of a sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nwidth: (::Int64, =nothing) width of the plot\nheight: (::Int64, =nothing) height of the plot\ndarkmode: (::Bool, =false) boolean to define colors for darkmode\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the k-space of the sequence struct seq\n\nExamples\n\njulia> seq = read_seq(\"examples/1.sequences/spiral.seq\")\n\njulia> plot_kspace(seq)\n\n\n\n\n\n","category":"function"},{"location":"api/#plot_M0","page":"API Documentation","title":"plot_M0","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"plot_M0","category":"page"},{"location":"api/#KomaMRI.plot_M0","page":"API Documentation","title":"KomaMRI.plot_M0","text":"p = plot_M0(seq; height=nothing, width=nothing, slider=true, darkmode=false)\n\nPlots the magnetization M0 of a sequence struct.\n\nArguments\n\nseq: (::Sequence) Sequence struct\n\nKeywords\n\nheight: (::Int64, =nothing) height of the plot\nwidth: (::Int64, =nothing) width of the plot\nslider: (::Bool, =true) boolean to display a slider\ndarkmode: (::Bool, =false) boolean to define colors for darkmode\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the magnetization M0 of the sequence struct seq\n\nExamples\n\njulia> seq = read_seq(\"examples/1.sequences/spiral.seq\")\n\njulia> plot_M0(seq)\n\n\n\n\n\n","category":"function"},{"location":"api/#plot_signal","page":"API Documentation","title":"plot_signal","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"plot_signal","category":"page"},{"location":"api/#KomaMRI.plot_signal","page":"API Documentation","title":"KomaMRI.plot_signal","text":"p = plot_signal(raw::RawAcquisitionData; height, width, slider, show_sim_blocks,\n        darkmode, range)\n\nPlots a raw signal in ISMRMRD format.\n\nArguments\n\nraw: (::RawAcquisitionData) RawAcquisitionData struct which is the raw signal in   ISMRMRD format\n\nKeywords\n\nwidth: (::Int64, =nothing) width of the plot\nheight: (::Int64, =nothing) height of the plot\nslider: (::Bool, =true) boolean to display a slider\nshow_sim_blocks: (::Bool, =false) boolean to show simulation blocks\ndarkmode: (::Bool, =false) boolean to define colors for darkmode\nrange: (::Vector{Float64}, =[]) time range to be displayed initially\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the raw signal\n\nExamples\n\njulia> sys, obj, seq = Scanner(), brain_phantom2D(), read_seq(\"examples/1.sequences/spiral.seq\");\n\njulia> ismrmrd = simulate(obj, seq, sys);\n\njulia> plot_signal(ismrmrd)\n\n\n\n\n\n","category":"function"},{"location":"api/#plot_image","page":"API Documentation","title":"plot_image","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"plot_image","category":"page"},{"location":"api/#KomaMRI.plot_image","page":"API Documentation","title":"KomaMRI.plot_image","text":"p = plot_image(image; height, width, zmin, zmax, darkmode, title)\n\nPlots an image matrix.\n\nArguments\n\nimage: (::Matrix{Float64}) image matrix\n\nKeywords\n\nheight: (::Int64, =750) height of the plot\nwidth: (::Int64, =nothing) width of the plot\nzmin: (::Float64, =minimum(abs.(image[:]))) reference value for minimum color\nzmax: (::Float64, =maximum(abs.(image[:]))) reference value for maximum color\ndarkmode: (::Bool, =false) boolean to define colors for darkmode\ntitle: (::String, =\"\") title of the plot\n\nReturns\n\np: (::PlotlyJS.SyncPlot) plot of the image matrix\n\n\n\n\n\n","category":"function"},{"location":"ui-details/#Graphical-User-Interface","page":"Graphical User Interface","title":"Graphical User Interface","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"This section is meant to explain some details about how to use the user interface of the KomaMRI.jl package and the processes that happen internally while interacting with it.","category":"page"},{"location":"ui-details/#Launch-the-UI","page":"Graphical User Interface","title":"Launch the UI","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"Open the Julia REPL and issue the following commands to include the KomaMRI.jl package and launch the user interface:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"julia> using KomaMRI\n\njulia> KomaUI()","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../assets/gui-dashboard.png\"/></p>","category":"page"},{"location":"ui-details/#Inputs","page":"Graphical User Interface","title":"Inputs","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"The user interface has already preloaded some inputs (stored in RAM). In particular, it has predefined the Scanner, the Phantom and the Sequence structs. In the following subsections, we will show how to visualize these inputs.","category":"page"},{"location":"ui-details/#Scanner","page":"Graphical User Interface","title":"Scanner","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"So far, it is not possible to see the Scanner struct in the user interface. However, the preloaded Scanner struct is the default one, so it is possible to know its attributes by creating a new default Scanner struct in the Julia REPL like so:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"julia> sys = Scanner()\nScanner\n  B0: Float64 1.5\n  B1: Float64 1.0e-5\n  Gmax: Float64 0.06\n  Smax: Int64 500\n  ADC_Œît: Float64 2.0e-6\n  seq_Œît: Float64 1.0e-5\n  GR_Œît: Float64 1.0e-5\n  RF_Œît: Float64 1.0e-6\n  RF_ring_down_T: Float64 2.0e-5\n  RF_dead_time_T: Float64 0.0001\n  ADC_dead_time_T: Float64 1.0e-5","category":"page"},{"location":"ui-details/#Phantom","page":"Graphical User Interface","title":"Phantom","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"To see the phantom already stored in RAM, simply click on the Phantom dropdown an then press the View Phantom button. The preloaded phantom is a slice of a brain:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../assets/gui-phantom-view.png\"/></p>","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"It is also possible to load .h5 phantom files. The KomaMRI.jl has some examples stored at ~/.julia/packages/KomaMRI/<id-string>/examples/2.phantoms/. For instance, let's load the sphere_chemical_shift.h5 file:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../assets/gui-phantom-load.png\"/></p>","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"Note that you can select different spin parameters to visualize like rho, T_1, T_2, among others. ","category":"page"},{"location":"ui-details/#Sequence","page":"Graphical User Interface","title":"Sequence","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"There are two options to visualize the sequence already preloaded in RAM: in the time domain or in the k-space. The preloaded sequence is a single-shot EPI.","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"For visualization of the sequence in the time domain, click on the Sequence dropdown and then press the Sequence (MPS) button:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../assets/gui-seq-time-view.png\"/></p>","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"For visualization of the sequence in the k-space, click on the Sequence dropdown and then press the k-space button:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../assets/gui-seq-kspace-view.png\"/></p>","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"It is also possible to load .seq sequence files. The KomaMRI.jl has some examples stored at ~/.julia/packages/KomaMRI/<id-string>/examples/1.sequences/. For instance, let's load the spiral.seq file and view it the time domain and k-space:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../assets/gui-seq-time-load.png\"/></p>","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../assets/gui-seq-kspace-load.png\"/></p>","category":"page"},{"location":"ui-details/#Simulation","page":"Graphical User Interface","title":"Simulation","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"Once the inputs are loaded in RAM, it is possible to perform the simulation to get the Raw Signal.","category":"page"},{"location":"ui-details/#Simulation-Parameters","page":"Graphical User Interface","title":"Simulation Parameters","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"To visualize the default simulation parameters, click on the Simulate! dropdown and then press the View Options button:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../assets/gui-sim-params-view.png\"/></p>","category":"page"},{"location":"ui-details/#Visualization-of-the-Raw-Signal","page":"Graphical User Interface","title":"Visualization of the Raw Signal","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"Press the Simulate! button to perform the simulation (this may take a while). Then, to view the generated Raw Signal, click on the Raw Data dropdown and then press the View Raw Data button:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../assets/gui-rawsignal-view.png\"/></p>","category":"page"},{"location":"ui-details/#Reconstruction","page":"Graphical User Interface","title":"Reconstruction","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"Once the Raw Signal is loaded in RAM, it is possible to reconstruct the image.","category":"page"},{"location":"ui-details/#Reconstruction-Parameters","page":"Graphical User Interface","title":"Reconstruction Parameters","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"To visualize the default reconstruction parameters, click on the Reconstruct! dropdown and then press the View Options button:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../assets/gui-recon-params-view.png\"/></p>","category":"page"},{"location":"ui-details/#Visualization-of-the-Image","page":"Graphical User Interface","title":"Visualization of the Image","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"Press the Reconstruct! button to perform the reconstruction (this may take a while). Then, to view the generated Image, click on the he Reconstruct! dropdown and then press the |Image| button:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"../assets/gui-image-view.png\"/></p>","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"EditURL = \"https://github.com/cncastillo/KomaMRI.jl/blob/master/examples/lit-04-3DSliceSelective.jl\"","category":"page"},{"location":"generated/lit-04-3DSliceSelective/#Slice-Selective-Acquisition-of-3D-Phantom","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"","category":"section"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"(Image: )","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"filename = last(splitpath(@__FILE__)) # hide\nisFileMD = occursin(\".md\", filename) # hide\nisFileJL = occursin(\".jl\", filename) # hide\n\nusing KomaMRI # hide\nsys = Scanner() # hide","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"While in the previous examples we simulated using hard RF pulses, in this demonstration we will illustrate the principles of slice selection. First, let's import a 3D phantom, in this case a brain slab (thickness of 2mathrmcm), by calling the function brain_phantom3D.","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"obj = brain_phantom3D()\nobj.Œîw .= 0 # Removes the off-resonance\np1 = plot_phantom_map(obj, :T2 ; height=400)\nif isFileMD savefig(p1, \"../assets/3-phantom.html\") end # hide\nif isFileJL display(p1) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"<center><object type=\"text/html\" data=\"../../assets/3-phantom.html\" style=\"width:50%; height:420px;\"></object></center>","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"Now, we are going to import a sequence which acquires 3 slices in the longitudinal axis. Note that the sequence contains three EPIs to acquire 3 slices of the phantom.","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"seqFile = joinpath(dirname(pathof(KomaMRI)), \"../examples/1.sequences/epi_multislice.seq\")\nseq = read_seq(seqFile)\np2 = plot_seq(seq; range=[0,10], height=400)\nif isFileMD savefig(p2, \"../assets/3-seq.html\") end # hide\nif isFileJL display(p2) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"<object type=\"text/html\" data=\"../../assets/3-seq.html\" style=\"width:100%; height:420px;\"></object>","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"We can take a look to the slice profiles by using the function simulate_slice_profile:","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"z = range(-2., 2., 200) * 1e-2; # -2 to 2 cm\nrf1, rf2, rf3 = findall(KomaMRI.is_RF_on.(seq))\nM1 = simulate_slice_profile(seq[rf1]; z)\nM2 = simulate_slice_profile(seq[rf2]; z)\nM3 = simulate_slice_profile(seq[rf3]; z)\n\nusing PlotlyJS # hide\npa = scatter(x=z*1e2, y=abs.(M1.xy), name=\"Slice 1\") # hide\npb = scatter(x=z*1e2, y=abs.(M2.xy), name=\"Slice 2\") # hide\npc = scatter(x=z*1e2, y=abs.(M3.xy), name=\"Slice 3\") # hide\npd = plot([pa,pb,pc], Layout(xaxis=attr(title=\"z [cm]\"), height=300,margin=attr(t=40,l=0,r=0), title=\"Slice profiles for the slice-selective sequence\")) # hide\nif isFileMD savefig(pd, \"../assets/3-profile.html\") end # hide\nif isFileJL display(pd) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"<object type=\"text/html\" data=\"../../assets/3-profile.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"Now let's simulate the acquisition. Notice the three echoes, one for every slice excitation.","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"raw = simulate(obj, seq, sys; simParams=Dict{String,Any}(\"Nblocks\"=>20))\np3 = plot_signal(raw; slider=false, height=300)\nif isFileMD savefig(p3, \"../assets/3-signal.html\") end # hide\nif isFileJL display(p3) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"<object type=\"text/html\" data=\"../../assets/3-signal.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"Finally, we reconstruct the acquiered images.","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"# Get the acquisition data\nacq = AcquisitionData(raw)\n\n# Setting up the reconstruction parameters and perform reconstruction\nNx, Ny = raw.params[\"reconSize\"][1:2]\nreconParams = Dict{Symbol,Any}(:reco=>\"direct\", :reconSize=>(Nx, Ny))\nimage = reconstruction(acq, reconParams)\n\n# Plotting the slices\np4 = plot_image(abs.(image[:, :, 1]); height=360, title=\"Slice 1\")\np5 = plot_image(abs.(image[:, :, 2]); height=360, title=\"Slice 2\")\np6 = plot_image(abs.(image[:, :, 3]); height=360, title=\"Slice 3\")\nif isFileMD savefig(p4, \"../assets/3-recon1.html\") end # hide\nif isFileMD savefig(p5, \"../assets/3-recon2.html\") end # hide\nif isFileMD savefig(p6, \"../assets/3-recon3.html\") end # hide\nif isFileJL display(p4) end # hide\nif isFileJL display(p5) end # hide\nif isFileJL display(p6) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"<object type=\"text/html\" data=\"../../assets/3-recon1.html\" style=\"width:50%; height:380px;\"></object><object type=\"text/html\" data=\"../../assets/3-recon2.html\" style=\"width:50%; height:380px;\"></object>","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"<center><object type=\"text/html\" data=\"../../assets/3-recon3.html\" style=\"width:50%; height:380px;\"></object></center>","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"","category":"page"},{"location":"generated/lit-04-3DSliceSelective/","page":"Slice Selective Acquisition of 3D Phantom","title":"Slice Selective Acquisition of 3D Phantom","text":"This page was generated using Literate.jl.","category":"page"},{"location":"mri-theory/#Koma's-Simulation-Method","page":"Simulation Method","title":"Koma's Simulation Method","text":"","category":"section"},{"location":"mri-theory/#Physical-and-Mathematical-Background","page":"Simulation Method","title":"Physical and Mathematical Background","text":"","category":"section"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"Koma simulates the magnetization of each spin by solving the Bloch equations in the rotating frame:","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"beginalign tag1\n\nfracmathrmd boldsymbolMmathrmd t =\n  gamma boldsymbolM times boldsymbolB\n- fracM_x hatx + M_y hatyT_2\n- fracM_z hatx + M_0 hatyT_1 \n\nendalign","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"with gamma the gyromagnetic ratio, boldsymbolM = M_x M_y M_z^T the magnetization vector, and","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"boldsymbolB = B_1x(t) B_1y(t) boldsymbolG(t) cdot boldsymbolx + Delta omega(t)^T","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"the effective magnetic field. M_0 is the proton density, T_1 and T_2 are the relaxation times, and Delta omega is the off-resonance, for each position.","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"The solution of Equation (1) for a single spin is independent of the state of the other spins in the system, a key feature that enables parallelization (look at GPU/CPU Parallelization).","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"Our simulator also uses the method of operator splitting to simplify the solution of Equation (1). This reflects mathematically the intuition of separating the Bloch equations in a rotation operator described by","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"beginalign tag2\n\nfracmathrmdmathrmdt boldsymbolM =\nbeginbmatrix\n 0            gamma B_z  -gamma B_y \n-gamma B_z   0            gamma B_x \n gamma B_y  -gamma B_x   0\nendbmatrix\nboldsymbolM \n\nendalign","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"and a relaxation operator described by","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"beginalign tag3\n\nfracmathrmdmathrmdt boldsymbolM =\nbeginbmatrix\n-tfrac1T_2  0  0 \n0  -tfrac1T_2  0 \n0  0  -tfrac1T_1\nendbmatrix\nboldsymbolM\n+\nbeginbmatrix\n0 \n0 \ntfracM_0T_1\nendbmatrix \n\nendalign","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"The evolution of the magnetization can then be described as a two-step process for each time step Delta t (Figure 1).","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"<p align=\"center\">\n<figure>\n  <img width=\"60%\" src=\"../assets/block-equation-intuition.svg\">\n  <figcaption><b>Figure 1</b>: Solution of the Bloch equations for one time step can be described by (2) a rotation and (3) a relaxation step.</figcaption>\n</figure>\n</p>","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"Furthermore, we define two regimes in the pulse sequence: excitation and precession. During the latter, the excitation fields are nulled: B_x = B_y = 0 in Equation (2). In the precession regime, the operator splitting method gives an exact solution, whereas during the excitation regime the method has O(Delta t^3) convergence.","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"From this point forward, we will drop the vectorial notation for boldsymbolM and boldsymbolB_1, and we will use M_xy = M_x + i M_y and B_1 = B_1x + i B_1y to describe the simplifications made in each regime.","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"The rotations during the excitation regime are stored in their spin-domain or SU(2) representation","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"boldQ =\nbeginbmatrix\nalpha -beta^* \nbeta  -alpha^*\nendbmatrix quadquad\ntextwith\nalpha^2 + beta^2 = 1 ","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"characterized by the Cayley-Klein complex parameters or Spinors for short (alphabeta). Spinors can represent any 3D rotation as","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"alpha = cos left( tfracvarphi2 right)  - i  n_z sin left( tfracvarphi2 right) \nbeta = -i n_xy sin left( tfracvarphi2 right) ","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"To solve Equation (2) the parameters for the Spinors are n_xy = tfracB_1lVert boldsymbolB rVert, n_z = tfracB_zlVert boldsymbolB rVert, and","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"beginalign tag4\n\nvarphi = - gamma lVert boldsymbolB rVert Delta t \n\nendalign","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"Then, the application of a Spinor rotation to a magnetization element is described by the operation","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"beginalign tag5\n\nbeginbmatrix\nM_xy^+ \nM_z^+\nendbmatrix = \nbeginbmatrix\n2alpha^* beta M_z + alpha^*^2 M_xy - beta^2 M_xy^* \n(alpha^2 - beta^2)M_z - 2Releft( alpha beta M_xy^* right)\nendbmatrix\n\nendalign","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"For the precession regime, all the rotations are with respect to z, and therefore they can be described with a complex exponential applied to the transverse magnetization","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"beginalign tag6\n\nM_xy^+ = M_xy e^ivarphi \n\nendalign","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"where varphi is defined in Equation (4).","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"Finally, to solve the relaxation step described in Equation (3) the magnetization is updated by","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"beginbmatrix\nM_xy^+ \nM_z^+\nendbmatrix =\nbeginbmatrix\nM_xy e^-tfracDelta tT_2 \nM_z e^-tfracDelta tT_1 + M_0left(1-e^-tfracDelta tT_1right)\nendbmatrix ","category":"page"},{"location":"mri-theory/#Simulation-Blocks,-Regime-Switching,-and-Sequence-Aware-Time-Stepping","page":"Simulation Method","title":"Simulation Blocks, Regime Switching, and Sequence-Aware Time Stepping","text":"","category":"section"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"To reduce the memory usage of our simulator, we subdivided time into Nblocks (Figure 2). KomaMRI classifies each block in either the excitation regime or the precession regime before the simulation.","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"For precession blocks, we can improve the accuracy of the simulations by using the integral representation of Equation (6), obtained by applying the limit as Delta t rightarrow 0 of iterated applications of Equation (6), giving a phase of","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"varphi = - gamma int_t_i^t_i+1 boldsymbolG(tau) cdot boldsymbolx(tau)  mathrmdtau - int_t_i^t_i+1 Delta omega(tau)  mathrmdtau ","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"Assuming that during the i-th simulation block (t in t_it_i+1) the gradients boldsymbolG(t) are piece-wise linear functions, and boldsymbolx(t) and Delta omega (t) are approximately constant, then, if we use the trapezoidal rule to obtain the value of this integral, we will obtain an exact result by sampling just the vertices of boldsymbolG(t), greatly reducing the number of points required by the simulation. We will only need intermediate points in the case of motion and for recording the sampling points as required by the Analog to Digital Converter (ADC). The user can control the time between intermediate gradient samples with the parameter Œît (Figure 2).","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"We can do something similar with B_1(t) in the excitation regime. If we assume B_1(t) is a piece-wise constant function (or concatenation of hard pulses), then Equation (5) will give an exact solution to Equation (2). The parameter Œît_rf manages the time between RF samples (Figure 2), and can be relatively large for 2D imaging where the slice profile is less relevant.","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"Thus, KomaMRI uses the rationale mentioned above to: (1) call different methods based on the regime of each block, while also (2) obtaining a variable time stepping schedule that adapts to the sequence needs. We named the latter sequence-aware time stepping (Figure 2).","category":"page"},{"location":"mri-theory/#GPU/CPU-Parallelization","page":"Simulation Method","title":"GPU/CPU Parallelization","text":"","category":"section"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"We further increase the simulation speed by separating the Bloch calculations into Nthreads and then performing the GPU operations with CUDA.jl (Figure 2). This separation is possible as all magnetization vectors are independent of one another.","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"<p align=\"center\">\n<figure>\n  <img width=\"100%\" src=\"../assets/koma-solution.svg\">\n  <figcaption><b>Figure 2</b>: This is a summary of the functions called to perform the simulation. The sequence <b>seq</b> is discretized after calculating the required time points in the wrapper function <b>simulate</b>. The time points are then divided into <b>Nblocks</b> to reduce the amount of memory used. The phantom <b>obj</b> is divided into <b>Nthreads</b>, and <b>KomaMRI</b> will use either <b>run_spin_excitation</b> or <b>run_spin_precession</b> depending on the regime. If an ADC object is present, the simulator will add the signal contributions of each thread to construct the acquired signal <b>S[t]</b>. All the parameters: <b>Nthreads</b>, <b>Nblocks</b>, <b>Œît_rf</b>, and <b>Œît</b>, are passed through a dictionary called <b>simParams</b> as an optional parameter of the <b>simulate</b> function.\n</figure>\n</p>","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KomaMRI.jl is a Julia package meant to simulate general Magnetic Resonance Imaging (MRI) scenarios. Its name comes from the Japanese word for spinning-top „Åì„Åæ (ko-ma) as they precess due to gravity like spins in a magnetic field.","category":"page"},{"location":"","page":"Home","title":"Home","text":"KomaMRI generates raw data by solving the Bloch equations using the specified scanner, phantom and sequence. It also provides a Graphical User Interface (GUI) that encapsulates the whole imaging pipeline (simulation and reconstruction).","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\"><img class=\"display-light-only\" width=\"100%\" src=\"assets/koma-schema.svg\"/></p>\n<p align=\"center\"><img class=\"display-dark-only\"  width=\"100%\" src=\"assets/koma-schema-dark.svg\"\"/></p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"KomaMRI can be used by either:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Graphical User Interface: User-friendly interaction. No Julia programming skills are required. Refer to Graphical User Interface to check the simplest usage example.\nScripts : Basic knowledge of Julia is required. Refer to Brain Example to check a tutorial. Refer to the API documentation to discover all the functions that the package has to offer.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Some of the features of KomaMRI.jl are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fast simulations by using CPU and GPU parallelization üèÉüí®.\nOpen Source, so anyone can include additional features üÜô.\nCompatibility with community-standards ü§ù like Pulseq .seq and ISMRMRD .mrd.\nCross-platform üåê thanks to the use of the Julia programing language.\nFriendly user interface for people with no programming skills üòå.\nFlexible API for advance users üë®‚Äçüíª.","category":"page"},{"location":"#Potential-Use-Cases","page":"Home","title":"Potential Use Cases","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We see Koma being used in:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The generation of synthetic data to train Machine Learning models.\nTo test novel pulse sequences before implementing them directly in a real scanner (with a Pulseq sequence).\nTeaching exercises for  MRI acquisition or reconstruction.","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"EditURL = \"https://github.com/cncastillo/KomaMRI.jl/blob/master/examples/lit-02-SmallTipApproximation.jl\"","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/#Small-Tip-Angle-Approximation","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"","category":"section"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"(Image: )","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"filename = last(splitpath(@__FILE__)) # hide\nisFileMD = occursin(\".md\", filename) # hide\nisFileJL = occursin(\".jl\", filename) # hide","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"Based on the results in page 41 of the book \"Handbook of MRI Pulse Sequences\" by Bernstein et al.","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"using KomaMRI # hide\nsys = Scanner() # hide\nsys.Smax = 50 # hide","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"In this example, we will showcase a common approximation in MRI, the small tip angle approximation. For this, we will simulate a slice profile for spins with positions zin-22mathrmcm and with a gradient G_z so their frequencies are mapped to fin-55mathrmkHz. To start, we define an RF pulse with a flip angle of 30 deg and pulse duration of T_mathrmrf=32mathrmms.","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"B1 = 4.92e-6\nTrf = 3.2e-3\nzmax = 2e-2\nfmax = 5e3\nz = range(-zmax, zmax, 400)\nGz = fmax / (Œ≥ * zmax)\nf = Œ≥ * Gz * z\nŒ± = KomaMRI.get_flip_angles(seq)[1] #Approx 30 deg","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"The designed RF pulse is presented in the figure below, where the additional gradient refocuses the spins' phase after the excitation.","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"seq = PulseDesigner.RF_sinc(B1, Trf, sys; G=[0;0;Gz], TBP=8)\np2 = plot_seq(seq; max_rf_samples=Inf, slider=false)\nif isFileMD savefig(p2, \"../assets/42-seq.html\") end # hide\nif isFileJL display(p2) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"<object type=\"text/html\" data=\"../../assets/42-seq.html\" style=\"width:100%; height:380px;\"></object>","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"Now we will perform the simulation using the function simulate_slice_profile. Note that we modified Œît_rf in simParams to match the resolution of the waveform.","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"simParams = Dict{String, Any}(\"Œît_rf\" => Trf / length(seq.RF.A[1]))\nM = simulate_slice_profile(seq; z, simParams)\n\nusing PlotlyJS # hide\ns1 = scatter(x=f, y=real.(M.xy), name=\"Mx\") # hide\ns2 = scatter(x=f, y=imag.(M.xy), name=\"My\") # hide\ndat = seq.RF.A[1] # hide\nN = length(dat) # hide\ndat_pad = [zeros(floor(Int64,N)); dat; zeros(floor(Int64,N))] # hide\nN_pad = length(dat_pad) # hide\nU = 1 / (Trf) * N / N_pad #hide\nu = range(0, (N_pad - 1) * U; step=U) # hide\nu = u .- maximum(u) / 2 .- U/2 # hide\nFT_dat_pad = abs.(KomaMRI.fftc(dat_pad; dims=1)) # hide\nscale_factor = maximum(abs.(M.xy)) / maximum(FT_dat_pad) # hide\ns3 = scatter(x=u, y=FT_dat_pad*scale_factor, name=\"|FT(B‚ÇÅ(t))|\", line=attr(dash=\"dash\")) # hide\npb = plot([s1,s2,s3], Layout(title=\"30 deg SINC pulse (TBP=8, Hamming)\", xaxis_title=\"Frequency [Hz]\", xaxis_range=[-fmax,fmax])) # hide\nif isFileMD savefig(pb, \"../assets/4b-profile.html\") end # hide\nif isFileJL display(pb) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"This produces the follwoing slice profile:","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"<object type=\"text/html\" data=\"../../assets/4b-profile.html\" style=\"width:100%; height:380px;\"></object>","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"As you can see, for a flip angle of 30 deg the slice profile is very close to the small tip angle approximation (the Fourier transform of B_1(t)).","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"But what will happen if we use a flip angle of 120 deg instead?","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"Œ±_desired = 120 + 0im               # The multiplication of a complex number scales the RF pulse of a Sequence\nŒ± = KomaMRI.get_flip_angles(seq)[1] # Previous FA approx 30 deg\nseq = (Œ±_desired / Œ±) * seq         # Scaling the pulse to have a flip angle of 120\nM = simulate_slice_profile(seq; z, simParams)\n\ns1 = scatter(x=f, y=abs.(M.xy), name=\"|Mxy|\") # hide\ndat = seq.RF.A[1] # hide\nN = length(dat) # hide\ndat_pad = [zeros(floor(Int64,N)); dat; zeros(floor(Int64,N))] # hide\nN_pad = length(dat_pad) # hide\nU = 1 / (Trf) * N / N_pad #hide\nu = range(0, (N_pad - 1) * U; step=U) # hide\nu = u .- maximum(u) / 2 .- U/2 # hide\nFT_dat_pad = abs.(KomaMRI.fftc(dat_pad; dims=1)) # hide\nscale_factor = maximum(abs.(M.xy)) / maximum(FT_dat_pad) # hide\ns2 = scatter(x=u, y=FT_dat_pad*scale_factor, name=\"|FT(B‚ÇÅ(t))|\", line=attr(dash=\"dash\")) # hide\npa = plot([s1,s2], Layout(title=\"120 deg SINC pulse (TBP=8, Hamming)\", xaxis_title=\"Frequency [Hz]\", xaxis_range=[-fmax,fmax])) # hide\nif isFileMD savefig(pa, \"../assets/4a-profile.html\") end # hide\nif isFileJL display(pa) end # hide\nnothing # hide","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"<object type=\"text/html\" data=\"../../assets/4a-profile.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"For this case, the small tip angle approximation breaks üò¢, thus, the reason for its name!","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"This basic sinc pulse is not designed to be B_1-insensitive.  Some adiabatic RF pulses have been proposed to achieve this. Watch out for a future example showing this adiabatic RF pulses üëÄ.","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"","category":"page"},{"location":"generated/lit-02-SmallTipApproximation/","page":"Small Tip Angle Approximation","title":"Small Tip Angle Approximation","text":"This page was generated using Literate.jl.","category":"page"}]
}
