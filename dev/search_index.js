var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API Documentation","title":"API Documentation","text":"This page shows the documentation for the modules, structs, functions, methods and additional components available when importing the KomaMRI.jl package. It is very useful for reference when using directly the Julia REPL and when creating custom Julia scripts. Please, don't miss out the section How to read the API docs which has important considerations to understand general aspects of the docstring structure. The following are the contents of the API Documentation:","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Pages = [\"api.md\"]\nDepth = 3","category":"page"},{"location":"api/#How-to-read-the-API-docs","page":"API Documentation","title":"How to read the API docs","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"The API documentation has predefined \"template patterns\" which are meant to help the user to understand how to use modules, structs, functions, methods and every aspect necessary in order to take advantage of all the possibilities that KomaMRI.jl offers.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"These documentation \"template patterns\" are based from the Julia Blue Style documentation and other github repositories that works with MRI topics. However, some custom considerations were added for a better understanding and a wider perspective.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Whenever you see a docstring documentation, it will have the following structure:","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"docstring: KomaMRI.component_name — Component\nout1, out2, ... = component_name(arg1, arg2, ...; kw1, kw2, ...)This is a brief description of what component_name does.note: Note\nHere can be placed a note if it is regarded necessary.Argumentsarg1: (::type, =value, [unit], opts: [opt1, opt2, ...]) the description for the arg1\n...Keywordskw1: (::type, =value, [unit], opts: [opt1, opt2, ...]) the description for the kw1\n...Returnsout1: (::type, =value, [unit], opts: [opt1, opt2, ...]) the description for the out1\n...ReferencesSometimes it is a good idea to put some references or links\n...Examplesjulia> arg1, arg2, valkw1, valkw2 = 3.5, \"hello\", 1, true\n\njulia> out1, out2 = component_name(arg1, arg2; kw1=valkw1, kw2=valkw2)","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"The previous docstring block will always have first the way how it is called the component (outputs = component_name(inputs) and next a brief description about what the component does. Then a note block will be displayed if necessary. As general rule, the next subsections are optional: Arguments, Keywords, Returns, References and Examples, however they will be displayed whenever necessary. These subsections are self-explanatory, so it is intuitive to figure out what are they meant for.","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Note that every subitem in the sections Arguments, Keywords and Returns are variables. They have practical information enclosed in parentheses plus a description. They information in parentheses is optional but very useful if it is present:","category":"page"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"::type: is the suggested type of the variable. If the input variable is of type ::type, then nothing can go wrong, but it is always possible to test other types. If the variable is an output, then it will always try to be forced to the type ::type.\n=value: sometimes for the inputs the is defined a default value if it is not assigned by the user.\n[unit]: this is the suggested physical unit of measure of the variable. Everything it is going to be fine if you are stick with these units of measure.\nopts: [opt1, opt2, ...]: sometimes the input value can only be interpreted if it is part of some predefined values.","category":"page"},{"location":"api/#Structs","page":"API Documentation","title":"Structs","text":"","category":"section"},{"location":"api/#Scanner","page":"API Documentation","title":"Scanner","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Scanner","category":"page"},{"location":"api/#KomaMRI.Scanner","page":"API Documentation","title":"KomaMRI.Scanner","text":"scanner = Scanner(B0, B1, Gmax, Smax, ADC_Δt, seq_Δt, GR_Δt, RF_Δt,\n    RF_ring_down_T, RF_dead_time_T, ADC_dead_time_T)\n\nThe Scanner struct.\n\nArguments\n\nB0: (::Real, =1.5, [T]) the main magnetic field\nB1: (::Real, =10e-6, [T]) the maximum RF amplitude\nGmax: (::Real, =60e-3, [T/m]) the maximum Gradient\nSmax: (::Real, =500, [mT/m/ms]) the maximum slew-rate\nADC_Δt: (::Real, =2e-6, [s]) the ADC raster time\nseq_Δt: (::Real, =1e-5, [s]) the sequence-block raster time\nGR_Δt: (::Real, =1e-5, [s]) the gradient raster time\nRF_Δt: (::Real, =1e-6, [s]) the RF raster time\nRF_ring_down_T: (::Real, =20e-6, [s]) the RF ring down time\nRF_dead_time_T: (::Real, =100e-6, [s]) the RF dead time\nADC_dead_time_T: (::Real, =10e-6, [s]) the ADC dead time\n\nReturns\n\nscanner: (::Scanner) the Scanner struct\n\nExamples\n\njulia> sys = Scanner()\nScanner\n  B0: Float64 1.5\n  B1: Float64 1.0e-5\n  Gmax: Float64 0.06\n  Smax: Int64 500\n  ADC_Δt: Float64 2.0e-6\n  seq_Δt: Float64 1.0e-5\n  GR_Δt: Float64 1.0e-5\n  RF_Δt: Float64 1.0e-6\n  RF_ring_down_T: Float64 2.0e-5\n  RF_dead_time_T: Float64 0.0001\n  ADC_dead_time_T: Float64 1.0e-5\n\n\n\n\n\n","category":"type"},{"location":"api/#Phantom","page":"API Documentation","title":"Phantom","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Phantom\nbrain_phantom2D\nbrain_phantom3D","category":"page"},{"location":"api/#KomaMRI.Phantom","page":"API Documentation","title":"KomaMRI.Phantom","text":"phantom = Phantom(name, x, y, z, ρ, T1, T2, T2s, Δw, Dλ1, Dλ2, Dθ, ux, uy, uz)\n\nThe Phantom struct.\n\nArguments\n\nname: (::String) the name of the Phantom\nx: (::Vector{Float64}, [m]) the vector of x-positions of the spins\ny: (::Vector{Float64}, [m]) the vector of y-positions of the spins\nz: (::Vector{Float64}, [m]) the vector of z-positions of the spins\nρ: (::Vector{Float64}) the vector of proton density of the spins\nT1: (::Vector{Float64}, [s]) the vector of T1 parameters of the spins\nT2: (::Vector{Float64}, [s]) the vector of T2 parameters of the spins\nT2s: (::Vector{Float64}, [s]) the vector of T2s parameters of the spins\nΔw: (::Vector{Float64}, [rad/s]) the vector of off-resonance parameters of the spins\nDλ1: (::Vector{Float64}) the vector of Dλ1 (diffusion) parameters of the spins\nDλ2: (::Vector{Float64}) the vector of Dλ2 (diffusion) parameters of the spins\nDθ: (::Vector{Float64}) the vector of Dθ (diffusion) parameters of the spins\nux: (::Function) the displacement field in the x-axis\nuy: (::Function) the displacement field in the y-axis\nuz: (::Function) the displacement field in the z-axis\n\nReturns\n\nphantom: (::Phantom) the Phantom struct\n\nExamples\n\njulia> obj = Phantom(x=zeros(5))\nPhantom\n  name: String \"spin\"\n  x: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]\n  y: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]\n  z: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]\n  ρ: Array{Float64}((5,)) [1.0, 1.0, 1.0, 1.0, 1.0]\n  T1: Array{Float64}((5,)) [Inf, Inf, Inf, Inf, Inf]\n  T2: Array{Float64}((5,)) [Inf, Inf, Inf, Inf, Inf]\n  T2s: Array{Float64}((5,)) [Inf, Inf, Inf, Inf, Inf]\n  Δw: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]\n  Dλ1: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]\n  Dλ2: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]\n  Dθ: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]\n  ux: #145 (function of type KomaMRI.var\"#145#153\")\n  uy: #146 (function of type KomaMRI.var\"#146#154\")\n  uz: #147 (function of type KomaMRI.var\"#147#155\")\n\n\n\n\n\n","category":"type"},{"location":"api/#KomaMRI.brain_phantom2D","page":"API Documentation","title":"KomaMRI.brain_phantom2D","text":"phantom = brain_phantom2D(;axis=\"axial\", ss=4)\n\nCreates a two-dimentional brain phantom struct.\n\nReferences\n\nB. Aubert-Broche, D.L. Collins, A.C. Evans: \"A new improved version of the realistic   digital brain phantom\" NeuroImage, in review - 2006\nB. Aubert-Broche, M. Griffin, G.B. Pike, A.C. Evans and D.L. Collins: \"20 new digital   brain phantoms for creation of validation image data bases\" IEEE TMI, in review - 2006\nhttps://brainweb.bic.mni.mcgill.ca/brainweb\n\nKeywords\n\naxis: (::String, =\"axial\", opts=[\"axial\"]) the orientation of the phantom\nss: (::Real, =4) the brain phantom parameter\n\nReturns\n\nphantom: (::Phantom) the 2D phantom struct\n\nExamples\n\njulia> obj = brain_phantom2D()\nPhantom\n  name: String \"brain2D_axial\"\n  x: Array{Float64}((6506,)) [-0.084, -0.084  …  0.086]\n  y: Array{Float64}((6506,)) [-0.03, -0.028  …  0.002]\n  z: Array{Float64}((6506,)) [-0.0, -0.0  …  0.0]\n  ρ: Array{Float64}((6506,)) [1.0, 1.0  …  1.0]\n  T1: Array{Float64}((6506,)) [0.569, 0.569  …  0.569]\n  T2: Array{Float64}((6506,)) [0.329, 0.329  …  0.329]\n  T2s: Array{Float64}((6506,)) [0.058, 0.058  …  0.058]\n  Δw: Array{Float64}((6506,)) [-0.0, -0.0  …  -0.0]\n  Dλ1: Array{Float64}((6506,)) [0.0, 0.0  …  0.0]\n  Dλ2: Array{Float64}((6506,)) [0.0, 0.0  …  0.0]\n  Dθ: Array{Float64}((6506,)) [0.0, 0.0  …  0.0]\n  ux: #386 (function of type KomaMRI.var\"#386#394\")\n  uy: #387 (function of type KomaMRI.var\"#387#395\")\n  uz: #388 (function of type KomaMRI.var\"#388#396\")\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"api/#KomaMRI.brain_phantom3D","page":"API Documentation","title":"KomaMRI.brain_phantom3D","text":"phantom = brain_phantom3D(;ss=4)\n\nCreates a three-dimentional brain phantom struct.\n\nReferences\n\nB. Aubert-Broche, D.L. Collins, A.C. Evans: \"A new improved version of the realistic   digital brain phantom\" NeuroImage, in review - 2006\nB. Aubert-Broche, M. Griffin, G.B. Pike, A.C. Evans and D.L. Collins: \"20 new digital   brain phantoms for creation of validation image data bases\" IEEE TMI, in review - 2006\nhttps://brainweb.bic.mni.mcgill.ca/brainweb\n\nKeywords\n\nss: (::Real, =4) the heart phantom parameter\n\nReturns\n\nphantom: (::Phantom) the 3D phantom struct\n\nExamples\n\njulia> obj = brain_phantom3D()\nPhantom\n  name: String \"brain3D\"\n  x: Array{Float64}((71326,)) [-0.086, -0.086  …  0.084]\n  y: Array{Float64}((71326,)) [-0.02, -0.018  …  0.004]\n  z: Array{Float64}((71326,)) [-0.01, -0.01  …  0.01]\n  ρ: Array{Float64}((71326,)) [1.0, 1.0  …  1.0]\n  T1: Array{Float64}((71326,)) [0.569, 0.569  …  0.569]\n  T2: Array{Float64}((71326,)) [0.329, 0.329  …  0.329]\n  T2s: Array{Float64}((71326,)) [0.058, 0.058  …  0.058]\n  Δw: Array{Float64}((71326,)) [-0.0, -0.0  …  -0.0]\n  Dλ1: Array{Float64}((71326,)) [0.0, 0.0  …  0.0]\n  Dλ2: Array{Float64}((71326,)) [0.0, 0.0  …  0.0]\n  Dθ: Array{Float64}((71326,)) [0.0, 0.0  …  0.0]\n  ux: #386 (function of type KomaMRI.var\"#386#394\")\n  uy: #387 (function of type KomaMRI.var\"#387#395\")\n  uz: #388 (function of type KomaMRI.var\"#388#396\")\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"api/#Sequence","page":"API Documentation","title":"Sequence","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Sequence","category":"page"},{"location":"api/#KomaMRI.Sequence","page":"API Documentation","title":"KomaMRI.Sequence","text":"seq = Sequence()\nseq = Sequence(GR)\nseq = Sequence(GR, RF)\nseq = Sequence(GR, RF, ADC)\nseq = Sequence(GR, RF, ADC, DUR)\nseq = Sequence(GR::Array{Grad,1})\nseq = Sequence(GR::Array{Grad,1}, RF::Array{RF,1})\nseq = Sequence(GR::Array{Grad,1}, RF::Array{RF,1}, A::ADC, DUR, DEF)\n\nThe Sequence struct.\n\nArguments\n\nGR: (::Matrix{Grad}) the gradient matrix, rows are for (x,y,z) and columns are for time\nRF: (::Matrix{RF}) the RF matrix, the 1 row is for the coil and columns are for time\nADC: (::Vector{ADC}) the ADC vector in time\nDUR: (::Vector{Float64}, [s]) the duration of each sequence-block, this enables   delays after RF pulses to satisfy ring-down times\nDEF: (::Dict{String, Any}) the dictionary with relevant information of the sequence.   The possible keys are [\"AdcRasterTime\", \"GradientRasterTime\", \"Name\", \"Nz\",   \"Num_Blocks\", \"Nx\", \"Ny\", \"PulseqVersion\", \"BlockDurationRaster\",   \"FileName\", \"RadiofrequencyRasterTime\"]\n\nExamples\n\njulia> d1, d2, d3 = 0.8, 0.4, 0.8;\n\njulia> fsinc = x -> 2 * sinc(3*pi*(x - d1/2)) * 1e-3;\n\njulia> matrixGrads = [Grad(0, d1) Grad( 0, d2) Grad(1, d3);\n                      Grad(0, d1) Grad( 1, d2) Grad(0, d3);\n                      Grad(1, d1) Grad(-1, d2) Grad(0, d3)];\n\njulia> matrixRFs = [KomaMRI.RF_fun(fsinc, d1) RF(0, d2) RF(0, d3)];\n\njulia> vectorADCs = [ADC(0, d1); ADC(0, d2); ADC(9, d3)];\n\njulia> seq = Sequence(matrixGrads, matrixRFs, vectorADCs)\nSequence[ τ = 2000.0 ms | blocks: 3 | ADC: 1 | GR: 4 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"api/#Grad","page":"API Documentation","title":"Grad","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Grad\nGrad(::Function, ::Real, ::Int64)","category":"page"},{"location":"api/#KomaMRI.Grad","page":"API Documentation","title":"KomaMRI.Grad","text":"grad = Grad(A, T)\ngrad = Grad(A, T, rise)\ngrad = Grad(A, T, rise, delay)\ngrad = Grad(A, T, rise, fall, delay)\n\nThe Gradient struct.\n\nArguments\n\nA: (::Float64, [T]) the amplitude of the gradient\nT: (::Float64, [s]) the duration of the flat-top\nrise: (::Real, [s]) the duration of the rise\nfall: (::Real, [s]) the duration of the fall\ndelay: (::Real, [s]) the duration of the delay\n\nReturns\n\ngrad: (::Grad) the Gradient struct\n\nExamples\n\njulia> d1, d2, d3 = 0.8, 0.4, 0.8;\n\njulia> matrixGrads = [Grad(0, d1) Grad( 0, d2) Grad(1, d3);\n                      Grad(0, d1) Grad( 1, d2) Grad(0, d3);\n                      Grad(1, d1) Grad(-1, d2) Grad(0, d3)];\n\njulia> seq = Sequence(matrixGrads)\nSequence[ τ = 2000.0 ms | blocks: 3 | ADC: 0 | GR: 4 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq)\n\njulia> d1, d2, d3 = 0.8, 0.4, 0.8;\n\njulia> dr, df, dd = 0.1, 0.05, 1;\n\njulia> matrixGrads = [Grad(0, d1, dr, df, dd) Grad( 0, d2, dr, df, 0) Grad(1, d3, dr, df, 0);\n                      Grad(0, d1, dr, df, dd) Grad( 1, d2, dr, df, 0) Grad(0, d3, dr, df, 0);\n                      Grad(1, d1, dr, df, dd) Grad(-1, d2, dr, df, 0) Grad(0, d3, dr, df, 0)];\n\njulia> seq = Sequence(matrixGrads)\nSequence[ τ = 3450.0 ms | blocks: 3 | ADC: 0 | GR: 4 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"api/#KomaMRI.Grad-Tuple{Function, Real, Int64}","page":"API Documentation","title":"KomaMRI.Grad","text":"grad = Grad(f::Function, T::Real, N::Int64; delay::Real)\n\nGenerates an arbitrary gradient waveform defined by function f in the interval t ∈ [0,T]. It uses N square gradients uniformly spaced in the interval.\n\nArguments\n\nf: (::Function) the gradient waveform\nT: (::Real, [s]) the duration of the gradient waveform\nN: (::Int64) the number of samples of the gradient waveform\n\nKeywords\n\ndelay: (::Real, =0, [s]) the starting delay for the waveform\n\nReturns\n\ngrad: (::Grad) the Gradient struct\n\nExamples\n\njulia> d1, d2, d3 = 0.8, 0.4, 0.8;\n\njulia> f1 = t -> sin(pi*t / d1);\n\njulia> f2 = t -> 1 - exp(- 5 * t / d2);\n\njulia> f3 = t -> exp(t / d3 * log(2)) - 1;\n\njulia> matrixGrads = [Grad(f1, d1) Grad( 0, d2) Grad( 0, d3);\n                      Grad( 0, d1) Grad(f2, d2) Grad( 0, d3);\n                      Grad( 0, d1) Grad( 0, d2) Grad(f3, d3)];\n\njulia> seq = Sequence(matrixGrads)\nSequence[ τ = 2000.0 ms | blocks: 3 | ADC: 0 | GR: 3 | RF: 0 | DEF: 0 ]\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"method"},{"location":"api/#RF","page":"API Documentation","title":"RF","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"RF","category":"page"},{"location":"api/#KomaMRI.RF","page":"API Documentation","title":"KomaMRI.RF","text":"rf = RF(A, T)\nrf = RF(A, T, Δf)\nrf = RF(A, T, Δf, delay)\n\nThe RF struct.\n\nArguments\n\nA: (::Complex{Int64}, [T]) the amplitud-phase B1x + i B1y\nT: (::Int64, [s]) the durations of the RF\nΔf: (::Float64, [Hz]) the frequency offset of the RF\ndelay: (::Float64, [s]) the delay time of the RF\n\nReturns\n\nrf: (::RF) the RF struct\n\nExamples\n\njulia> d1, d2, d3 = 0.8, 0.4, 0.8;\n\njulia> fsinc = x -> 2 * sinc(3*pi*(x - d1/2)) * 1e-3;\n\njulia> matrixGrads = [Grad(0, d1) Grad(0, d2) Grad(0, d3)];\n\njulia> matrixRFs = [KomaMRI.RF_fun(fsinc, d1) RF(0, d2) RF(0, d3)];\n\njulia> seq = Sequence(matrixGrads, matrixRFs)\nSequence[ τ = 2000.0 ms | blocks: 3 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"api/#ADC","page":"API Documentation","title":"ADC","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"ADC","category":"page"},{"location":"api/#KomaMRI.ADC","page":"API Documentation","title":"KomaMRI.ADC","text":"adc = ADC(N, T)\nadc = ADC(N, T, delay)\nadc = ADC(N, T, delay, Δf, ϕ)\n\nThe ADC struct.\n\nArguments\n\nN: (::Int64) the number of acquired samples\nT: (::Float64, [s]) the duration to acquire the samples\ndelay: (::Float64, [s]) the delay time to start the acquisition\nΔf: (::Float64, [Hz]) the delta frequency. It's meant to compensate RF pulse phases.   It is used internally by the read_ADC function\nϕ: (::Float64, [rad]) the phase. It's meant to compensate RF pulse phases. It is   used internally by the read_ADC function\n\nReturns\n\nadc: (::ADC) the ADC struct\n\nExamples\n\njulia> d1, d2, d3 = 0.8, 0.4, 0.8;\n\njulia> matrixGrads = [Grad(0, d1) Grad(0, d2) Grad(0, d3)];\n\njulia> matrixRFs = [RF(0, d1) RF(0, d2) RF(0, d3)];\n\njulia> vectorADCs = [ADC(0, d1); ADC(0, d2); ADC(9, d3)];\n\njulia> seq = Sequence(matrixGrads, matrixRFs, vectorADCs)\nSequence[ τ = 2000.0 ms | blocks: 3 | ADC: 1 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"type"},{"location":"api/#Delay","page":"API Documentation","title":"Delay","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"Delay","category":"page"},{"location":"api/#KomaMRI.Delay","page":"API Documentation","title":"KomaMRI.Delay","text":"delay = Delay(T)\n\nThe Delay struct. The input delay time T must be non-negative.\n\nnote: Note\nThis struct is meant to add delays to a sequence struct that ultimately affects to the duration of the gradients of a sequence.\n\nArguments\n\nT: (::Real, [s]) the time delay value\n\nReturns\n\ndelay: (::Delay) the Delay struct\n\nExamples\n\njulia> d1, d2, d3 = 0.8, 0.4, 0.8;\n\njulia> fsinc = x -> 2 * sinc(3*pi*(x - d1/2)) * 1e-3;\n\njulia> matrixGrads = [Grad(0, d1) Grad( 0, d2) Grad(1, d3);\n                      Grad(0, d1) Grad( 1, d2) Grad(0, d3);\n                      Grad(1, d1) Grad(-1, d2) Grad(0, d3)];\n\njulia> matrixRFs = [KomaMRI.RF_fun(fsinc, d1) RF(0, d2) RF(0, d3)];\n\njulia> vectorADCs = [ADC(0, d1); ADC(0, d2); ADC(9, d3)];\n\njulia> delay = Delay(1);\n\njulia> seq = Sequence(matrixGrads, matrixRFs, vectorADCs)\nSequence[ τ = 2000.0 ms | blocks: 3 | ADC: 1 | GR: 4 | RF: 1 | DEF: 0 ]\n\njulia> delayed_seq = delay + seq\nSequence[ τ = 3000.0 ms | blocks: 4 | ADC: 1 | GR: 4 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(seq)\n\njulia> plot_seq(delayed_seq)\n\n\n\n\n\n","category":"type"},{"location":"api/#Read-Data","page":"API Documentation","title":"Read Data","text":"","category":"section"},{"location":"api/#read_seq","page":"API Documentation","title":"read_seq","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.read_seq","category":"page"},{"location":"api/#KomaMRI.read_seq","page":"API Documentation","title":"KomaMRI.read_seq","text":"seq = read_seq(filename)\n\nReturns the Sequence struct from a sequence file .seq.\n\nArguments\n\nfilename: (::String) the absolute or relative path of the sequence file .seq\n\nReturns\n\nseq: (::Sequence) the sequence struct\n\nExamples\n\njulia> seq = read_seq(\"examples/1.sequences/epi.seq\")\nSuccessfully loaded epi.seq!\nSequence[ τ = 332.16 ms | blocks: 609 | ADC: 300 | GR: 615 | RF: 3 | DEF: 10 ]\n\njulia> plot_seq(seq)\n\njulia> plot_kspace(seq)\n\njulia> seq = read_seq(\"examples/1.sequences/spiral.seq\")\nSuccessfully loaded spiral.seq!\nSequence[ τ = 42.89 ms | blocks: 4 | ADC: 1 | GR: 8 | RF: 2 | DEF: 12 ]\n\njulia> plot_seq(seq)\n\njulia> plot_kspace(seq)\n\n\n\n\n\n","category":"function"},{"location":"api/#read_phantom_jemris","page":"API Documentation","title":"read_phantom_jemris","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"read_phantom_jemris","category":"page"},{"location":"api/#KomaMRI.read_phantom_jemris","page":"API Documentation","title":"KomaMRI.read_phantom_jemris","text":"phantom = read_phantom_jemris(filename)\n\nReturns the Phantom struct from JEMRIS phantoms a file .h5.\n\nArguments\n\nfilename: (::String) the absolute or relative path of the phantom file .h5\n\nReturns\n\nphantom: (::Phantom) the phantom struct\n\nExamples\n\njulia> obj = read_phantom_jemris(\"examples/2.phantoms/brain.h5\")\nPhantom\n  name: String \"brain.h5\"\n  x: Array{Float64}((25841,)) [-0.0085, -0.0075  …  0.0035]\n  y: Array{Float64}((25841,)) [-0.0985, -0.0985  …  0.1055]\n  z: Array{Float64}((25841,)) [0.0, 0.0  …  0.0]\n  ρ: Array{Float64}((25841,)) [1.0, 1.0  …  1.0]\n  T1: Array{Float64}((25841,)) [2.569, 2.569  …  2.569]\n  T2: Array{Float64}((25841,)) [0.329, 0.329  …  0.329]\n  T2s: Array{Float64}((25841,)) [Inf, Inf  …  Inf]\n  Δw: Array{Float64}((25841,)) [0.0, 0.0  …  0.0]\n  Dλ1: Array{Float64}((25841,)) [0.0, 0.0  …  0.0]\n  Dλ2: Array{Float64}((25841,)) [0.0, 0.0  …  0.0]\n  Dθ: Array{Float64}((25841,)) [0.0, 0.0  …  0.0]\n  ux: #161 (function of type KomaMRI.var\"#161#162\"{Int64})\n  uy: #387 (function of type KomaMRI.var\"#387#395\")\n  uz: #388 (function of type KomaMRI.var\"#388#396\")\n\njulia> plot_phantom_map(obj, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"api/#rawSignalToISMRMRD","page":"API Documentation","title":"rawSignalToISMRMRD","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"rawSignalToISMRMRD","category":"page"},{"location":"api/#KomaMRI.rawSignalToISMRMRD","page":"API Documentation","title":"KomaMRI.rawSignalToISMRMRD","text":"raw_ismrmrd = rawSignalToISMRMRD(signal, seq; phantom, sys, simParams)\n\nTransforms the raw signal into ISMRMRD format.\n\nArguments\n\nsignal: (::Vector{ComplexF64}) the raw signal\nseq: (::Sequence) the sequence struct\n\nKeywords\n\nphantom: (::Phantom, =Phantom(name=\"Phantom\",x=[0])) the phantom struct\nsys: (::Scanner, =Scanner()) the scanner struct\nsimParams: (::Dict{String,Any}(), =Dict{String,Any}()) the dictionary with   simulation parameters\n\nReturns\n\nraw_ismrmrd: (::RawAcquisitionData) the raw signal in ISMRMRD format\n\nExamples\n\njulia> sys = Scanner();\n\njulia> FOV, N = 23e-2, 101;\n\njulia> durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse\n\njulia> ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)\nSequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> epi = PulseDesigner.EPI(FOV, N, sys)\nSequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]\n\njulia> seq = ex + epi\nSequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 4 ]\n\njulia> plot_seq(seq)\n\njulia> obj = brain_phantom2D();\n\njulia> signal = simulate(obj, seq, sys);\n\njulia> ismrmrd = rawSignalToISMRMRD([signal;;], seq; phantom=obj, sys=sys);\n\njulia> plot_signal(ismrmrd)\n\n\n\n\n\n","category":"function"},{"location":"api/#Pulse-Design","page":"API Documentation","title":"Pulse Design","text":"","category":"section"},{"location":"api/#PulseDesigner","page":"API Documentation","title":"PulseDesigner","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"PulseDesigner","category":"page"},{"location":"api/#KomaMRI.PulseDesigner","page":"API Documentation","title":"KomaMRI.PulseDesigner","text":"PulseDesigner\n\nA module to define different pulse sequences.\n\n\n\n\n\n","category":"module"},{"location":"api/#PulseDesigner.RF_hard","page":"API Documentation","title":"PulseDesigner.RF_hard","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"PulseDesigner.RF_hard","category":"page"},{"location":"api/#KomaMRI.PulseDesigner.RF_hard","page":"API Documentation","title":"KomaMRI.PulseDesigner.RF_hard","text":"ex = RF_hard(B1, T, sys::Scanner; G=[0,0,0], Δf=0)\n\nDefinition of the RF hard sequence.\n\nArguments\n\nB1: (Float64, [T]) the amplitude of the RF pulse\nT: (Float64, [s]) the duration of the RF pulse\nsys: (::Scanner) the scanner struct\n\nKeywords\n\nG: (Vector{Float64}, =[0, 0, 0], [T]) the gradient amplitudes for x, y, z\nΔf: (Float64, =0, [Hz]) the frequency offset of the RF pulse\n\nReturns\n\nex: (::Sequence) the excitation sequence struct\n\nExamples\n\njulia> sys = Scanner();\n\njulia> durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse\n\njulia> ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)\nSequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> plot_seq(ex)\n\n\n\n\n\n","category":"function"},{"location":"api/#PulseDesigner.EPI","page":"API Documentation","title":"PulseDesigner.EPI","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"PulseDesigner.EPI","category":"page"},{"location":"api/#KomaMRI.PulseDesigner.EPI","page":"API Documentation","title":"KomaMRI.PulseDesigner.EPI","text":"epi = EPI(FOV::Float64, N::Int, sys::Scanner)\n\nDefinition of the EPI sequence.\n\nArguments\n\nFOV: (::Float64, [m]) the field of view\nN: (::Int) the number of pixels in the x and y axis\nsys: (::Scanner) the scanner struct\n\nReturns\n\nepi: (::Sequence) the epi sequence struct\n\nExamples\n\njulia> sys = Scanner();\n\njulia> FOV, N = 23e-2, 101;\n\njulia> epi = PulseDesigner.EPI(FOV, N, sys)\nSequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]\n\njulia> plot_seq(epi)\n\njulia> plot_kspace(epi)\n\n\n\n\n\n","category":"function"},{"location":"api/#PulseDesigner.radial_base","page":"API Documentation","title":"PulseDesigner.radial_base","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"PulseDesigner.radial_base","category":"page"},{"location":"api/#KomaMRI.PulseDesigner.radial_base","page":"API Documentation","title":"KomaMRI.PulseDesigner.radial_base","text":"seq = radial_base(FOV::Float64, Nr::Int, sys::Scanner)\n\nDefinition of the radial base sequence.\n\nArguments\n\nFOV: (::Float64, [m]) the field of view\nN: (::Int) number of pixel in the radious\nsys: (::Scanner) the scanner struct\n\nReturns\n\nseq: (::Sequence) the radial base sequence struct\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation","page":"API Documentation","title":"Simulation","text":"","category":"section"},{"location":"api/#simulate","page":"API Documentation","title":"simulate","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"simulate","category":"page"},{"location":"api/#KomaMRI.simulate","page":"API Documentation","title":"KomaMRI.simulate","text":"out = simulate(obj::Phantom, seq::Sequence, sys::Scanner; simParams, w)\n\nReturns the raw signal or the last state of the magnetization according to the value of the \"return_type\" key of the simParams dictionary.\n\nArguments\n\nobj: (::Phantom) the phantom struct\nseq: (::Sequence) the sequence struct\nsys: (::Scanner) the scanner struct\n\nKeywords\n\nsimParams: (::Dict{String,Any}, =Dict{String,Any}()) the dictionary with simulation   parameters\nw: (::Any, =nothing) the flag to regard a progress bar in the blink window UI. If   this variable is differnet from nothing, then the progress bar is considered\n\nReturns\n\nout: (::Vector{ComplexF64} or ::Vector{Mag} or RawAcquisitionData) depending if \"return_type\" is   \"mat\" or \"mag\" or \"raw\" (default) respectively.\n\nExamples\n\nPreparation (define scanner and sequence):\n\njulia> sys = Scanner();\n\njulia> FOV, N = 23e-2, 101;\n\njulia> durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse\n\njulia> ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)\nSequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> epi = PulseDesigner.EPI(FOV, N, sys)\nSequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]\n\njulia> seq = ex + epi\nSequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 4 ]\n\njulia> plot_seq(seq)\n\njulia> plot_kspace(seq)\n\nSimulate:\n\njulia> obj = brain_phantom2D()\n\njulia> signal = simulate(obj, seq, sys);\n\njulia> ismrmrd = rawSignalToISMRMRD([signal;;], seq; phantom=obj, sys=sys);\n\njulia> plot_signal(ismrmrd)\n\nReconstruct:\n\njulia> Nx, Ny = ismrmrd.params[\"reconSize\"][1:2];\n\njulia> params = Dict{Symbol,Any}(:reco=>\"direct\", :reconSize=>(Nx, Ny), :densityWeighting=>true);\n\njulia> acq = AcquisitionData(ismrmrd);\n\njulia> recon = reconstruction(acq, params);\n\njulia> image = reshape(recon.data, Nx, Ny, :)\n102×102×1 Array{ComplexF64, 3}:\n[:, :, 1] =\n 0.0+0.0im  0.0+0.0im  …  0.0+0.0im\n 0.0+0.0im  0.0+0.0im     0.0+0.0im\n    ⋮           ⋮       ⋱      ⋮\n 0.0+0.0im  0.0+0.0im  …  0.0+0.0im\n\njulia> slice_abs = abs.(image[:, :, 1])\n102×102 Matrix{Float64}:\n 0.0  0.0  …  0.0\n 0.0  0.0     0.0\n  ⋮        ⋱   ⋮\n 0.0  0.0  …  0.0\n\njulia> plot_image(slice_abs)\n\n```\n\n\n\n\n\n","category":"function"},{"location":"api/#simulate_slice_profile","page":"API Documentation","title":"simulate_slice_profile","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"simulate_slice_profile","category":"page"},{"location":"api/#KomaMRI.simulate_slice_profile","page":"API Documentation","title":"KomaMRI.simulate_slice_profile","text":"M = simulate_slice_profile(seq; z, simParams)\n\nReturns magnetization of spins distributed along z after running the Sequence seq.\n\nnote: Note\nThis function is not being used in this KomaMRI version.\n\nArguments\n\nseq: (::Sequence) the sequence struct\n\nKeywords\n\nz: (=range(-2e-2,2e-2,200)) a range for the z axe\nsimParams: (::Dict{String, Any}, =Dict{String,Any}(\"Δt_rf\"=>1e-6)) a dictionary with   simulation parameters\n\nReturns\n\nM: (::Vector{Mag}) the final state of the Mag vector\n\n\n\n\n\n","category":"function"},{"location":"api/#Plots","page":"API Documentation","title":"Plots","text":"","category":"section"},{"location":"api/#plot_phantom_map","page":"API Documentation","title":"plot_phantom_map","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"plot_phantom_map","category":"page"},{"location":"api/#KomaMRI.plot_phantom_map","page":"API Documentation","title":"KomaMRI.plot_phantom_map","text":"p = plot_phantom_map(ph, key; t0=0, height=700, width=nothing, darkmode=false)\n\nPlots a phantom map for a specific spin parameter given by key.\n\nArguments\n\nph: (::Phantom) the phantom struct\nkey: (::Symbol, opts: [:ρ, :T1, :T2, :T2s, :x, :y, :z]) the symbol for   displaying different parameters of the phantom spins\n\nKeywords\n\nt0: (::Float64, =0, [ms]) the time to see displacement of the phantom\nheight: (::Int64, =nothing) the height of the plot\nwidth: (::Int64, =nothing) the width of the plot\ndarkmode: (::Bool, =false) the boolean to define colors for darkmode\n\nReturns\n\np: (::PlotlyJS.SyncPlot) the plot of the phantom map for a specific spin parameter\n\nReferences\n\nColormaps from https://github.com/markgriswold/MRFColormaps Towards Unified Colormaps for Quantitative MRF Data, Mark Griswold, et al. (2018).\n\nExamples\n\njulia> obj2D, obj3D = brain_phantom2D(), brain_phantom3D();\n\njulia> plot_phantom_map(obj2D, :ρ)\n\njulia> plot_phantom_map(obj3D, :ρ)\n\n\n\n\n\n","category":"function"},{"location":"api/#plot_seq","page":"API Documentation","title":"plot_seq","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"plot_seq","category":"page"},{"location":"api/#KomaMRI.plot_seq","page":"API Documentation","title":"KomaMRI.plot_seq","text":"p = plot_seq(seq; width, height, slider, show_seq_blocks, darkmode, max_rf_samples, range)\n\nPlots a sequence struct.\n\nArguments\n\nseq: (::Sequence) the sequence struct\n\nKeywords\n\nwidth: (::Int64, =nothing) the width of the plot\nheight: (::Int64, =nothing) the height of the plot\nslider: (::Bool, =true) the boolean to display a slider\nshow_seq_blocks: (::Bool, =false) the boolean to show sequence blocks\ndarkmode: (::Bool, =false) the boolean to define colors for darkmode\nmax_rf_samples: (::Int64, =100) the maximum number of RF samples\nrange: (::Vector{Float64}, =[]) the time range to be displayed initially\n\nReturns\n\np: (::PlotlyJS.SyncPlot) the plot of the sequence struct\n\nExamples\n\njulia> sys = Scanner();\n\njulia> FOV, N = 23e-2, 101;\n\njulia> durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse\n\njulia> ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)\nSequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> epi = PulseDesigner.EPI(FOV, N, sys)\nSequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]\n\njulia> seq = ex + epi\nSequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 4 ]\n\njulia> plot_seq(seq)\n\n\n\n\n\n","category":"function"},{"location":"api/#plot_kspace","page":"API Documentation","title":"plot_kspace","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"plot_kspace","category":"page"},{"location":"api/#KomaMRI.plot_kspace","page":"API Documentation","title":"KomaMRI.plot_kspace","text":"p = plot_kspace(seq; width=nothing, height=nothing, darkmode=false)\n\nPlots the k-space of a sequence struct.\n\nArguments\n\nseq: (::Sequence) the sequence struct\n\nKeywords\n\nwidth: (::Int64, =nothing) the width of the plot\nheight: (::Int64, =nothing) the height of the plot\ndarkmode: (::Bool, =false) the boolean to define colors for darkmode\n\nReturns\n\np: (::PlotlyJS.SyncPlot) the plot of the k-space of the sequence struct seq\n\nExamples\n\njulia> sys = Scanner();\n\njulia> FOV, N = 23e-2, 101;\n\njulia> durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse\n\njulia> ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)\nSequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> epi = PulseDesigner.EPI(FOV, N, sys)\nSequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]\n\njulia> seq = ex + epi\nSequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 4 ]\n\njulia> plot_kspace(seq)\n\n\n\n\n\n","category":"function"},{"location":"api/#plot_M0","page":"API Documentation","title":"plot_M0","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"plot_M0","category":"page"},{"location":"api/#KomaMRI.plot_M0","page":"API Documentation","title":"KomaMRI.plot_M0","text":"p = plot_M0(seq; height=nothing, width=nothing, slider=true, darkmode=false)\n\nPlots the magnetization M0 of a sequence struct.\n\nArguments\n\nseq: (::Sequence) the sequence struct\n\nKeywords\n\nheight: (::Int64, =nothing) the height of the plot\nwidth: (::Int64, =nothing) the width of the plot\nslider: (::Bool, =true) the boolean to display a slider\ndarkmode: (::Bool, =false) the boolean to define colors for darkmode\n\nReturns\n\np: (::PlotlyJS.SyncPlot) the plot of the magnetization M0 of the sequence struct seq\n\nExamples\n\njulia> sys = Scanner();\n\njulia> FOV, N = 23e-2, 101;\n\njulia> durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse\n\njulia> ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)\nSequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> epi = PulseDesigner.EPI(FOV, N, sys)\nSequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]\n\njulia> seq = ex + epi\nSequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 4 ]\n\njulia> plot_M0(seq)\n\n\n\n\n\n","category":"function"},{"location":"api/#plot_signal","page":"API Documentation","title":"plot_signal","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"plot_signal","category":"page"},{"location":"api/#KomaMRI.plot_signal","page":"API Documentation","title":"KomaMRI.plot_signal","text":"p = plot_signal(raw::RawAcquisitionData; height, width, darkmode, range)\n\nPlots a raw signal in ISMRMRD format.\n\nArguments\n\nraw: (::RawAcquisitionData) the RawAcquisitionData struct which is the raw signal in   ISMRMRD format\n\nKeywords\n\nwidth: (::Int64, =nothing) the width of the plot\nheight: (::Int64, =nothing) the height of the plot\ndarkmode: (::Bool, =false) the boolean to define colors for darkmode\nrange: (::Vector{Float64}, =[]) the time range to be displayed initially\n\nReturns\n\np: (::PlotlyJS.SyncPlot) the plot of the raw signal\n\nExamples\n\njulia> sys = Scanner();\n\njulia> FOV, N = 23e-2, 101;\n\njulia> durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse\n\njulia> ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)\nSequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> epi = PulseDesigner.EPI(FOV, N, sys)\nSequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]\n\njulia> seq = ex + epi\nSequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 4 ]\n\njulia> plot_seq(seq)\n\njulia> obj = brain_phantom2D();\n\njulia> signal = simulate(obj, seq, sys);\n\njulia> ismrmrd = rawSignalToISMRMRD([signal;;], seq; phantom=obj, sys=sys);\n\njulia> plot_signal(ismrmrd)\n\n\n\n\n\n","category":"function"},{"location":"api/#plot_image","page":"API Documentation","title":"plot_image","text":"","category":"section"},{"location":"api/","page":"API Documentation","title":"API Documentation","text":"plot_image","category":"page"},{"location":"api/#KomaMRI.plot_image","page":"API Documentation","title":"KomaMRI.plot_image","text":"p = plot_image(image; height, width, zmin, zmax, darkmode, title)\n\nPlots an image matrix.\n\nArguments\n\nimage: (::Matrix{Float64}) the image matrix\n\nKeywords\n\nheight: (::Int64, =750) the height of the plot\nwidth: (::Int64, =nothing) the width of the plot\nzmin: (::Float64, =minimum(abs.(image[:]))) the reference value for minimum color\nzmax: (::Float64, =maximum(abs.(image[:]))) the reference value for maximum color\ndarkmode: (::Bool, =false) the boolean to define colors for darkmode\ntitle: (::String, =\"\") the title of the plot\n\nReturns\n\np: (::PlotlyJS.SyncPlot) the plot of the image matrix\n\nExamples\n\nPreparation (define scanner and sequence):\n\njulia> sys = Scanner();\n\njulia> FOV, N = 23e-2, 101;\n\njulia> durRF = π/2/(2π*γ*sys.B1); #90-degree hard excitation pulse\n\njulia> ex = PulseDesigner.RF_hard(sys.B1, durRF, sys)\nSequence[ τ = 0.587 ms | blocks: 1 | ADC: 0 | GR: 0 | RF: 1 | DEF: 0 ]\n\njulia> epi = PulseDesigner.EPI(FOV, N, sys)\nSequence[ τ = 62.259 ms | blocks: 203 | ADC: 101 | GR: 205 | RF: 0 | DEF: 4 ]\n\njulia> seq = ex + epi\nSequence[ τ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 4 ]\n\njulia> plot_seq(seq)\n\njulia> plot_kspace(seq)\n\nSimulate:\n\njulia> obj = brain_phantom2D()\n\njulia> signal = simulate(obj, seq, sys);\n\njulia> ismrmrd = rawSignalToISMRMRD([signal;;], seq; phantom=obj, sys=sys);\n\njulia> plot_signal(ismrmrd)\n\nReconstruct:\n\njulia> Nx, Ny = ismrmrd.params[\"reconSize\"][1:2];\n\njulia> params = Dict{Symbol,Any}(:reco=>\"direct\", :reconSize=>(Nx, Ny), :densityWeighting=>true);\n\njulia> acq = AcquisitionData(ismrmrd);\n\njulia> recon = reconstruction(acq, params);\n\njulia> image = reshape(recon.data, Nx, Ny, :)\n102×102×1 Array{ComplexF64, 3}:\n[:, :, 1] =\n 0.0+0.0im  0.0+0.0im  …  0.0+0.0im\n 0.0+0.0im  0.0+0.0im     0.0+0.0im\n    ⋮           ⋮       ⋱      ⋮\n 0.0+0.0im  0.0+0.0im  …  0.0+0.0im\n\njulia> slice_abs = abs.(image[:, :, 1])\n102×102 Matrix{Float64}:\n 0.0  0.0  …  0.0\n 0.0  0.0     0.0\n  ⋮        ⋱   ⋮\n 0.0  0.0  …  0.0\n\njulia> plot_image(slice_abs)\n\n\n\n\n\n","category":"function"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Installing-Julia","page":"Getting Started","title":"Installing Julia","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"KomaMRI was written in Julia, so the first thing you should do is to install it! The latest version of Julia can be downloaded at the Julia Downloads page. It is advisable you add julia to the PATH, which can be done during the installation process.","category":"page"},{"location":"getting-started/#Installing-KomaMRI","page":"Getting Started","title":"Installing KomaMRI","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Once Julia is installed, open the Julia REPL and add the KomaMRI package. To bring up Julia's package manager enter ], and then add the KomaMRI package. This process should take about 5 minutes in a fresh Julia installation. ","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n\n(@v1.8) pkg> add KomaMRI","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Then press Ctrl+C or backspace to return to the julia> prompt.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"getting-started/#My-First-MRI-Simulation","page":"Getting Started","title":"My First MRI Simulation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For our first simulation we will use Koma's graphical user interface (GUI). For this, you will first need to load KomaMRI by typing using KomaMRI, and then lauch the GUI with KomaUI().","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> using KomaMRI\n\njulia> KomaUI()","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The first time you use this command it may take more time than usual, but a window with the Koma GUI will pop up:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The user interface has some basic definitions for the scanner, phantom, and sequence already preloaded. So you can immediately interact with the simulation and reconstruction processes, and then visualize the results.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"As a simple demonstration, press the button Simulate! and wait until the simulation is ready. Then click on the Raw Data dropdown and then click on the View Raw Data button. You should see the following:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Then, press the button Reconstruct! and wait until the reconstruction ends. Then click on the Reconstruction dropdown and then click on the |Image| button to see the image reconstruction: ","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Congratulations, you successfully simulated an MRI acquisition! 🎊","category":"page"},{"location":"ui-details/#Graphical-User-Interface","page":"Graphical User Interface","title":"Graphical User Interface","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"This section is meant to explain some details about how to use the user interface of the KomaMRI.jl package and the processes that happen internally while interacting with it.","category":"page"},{"location":"ui-details/#Launch-the-UI","page":"Graphical User Interface","title":"Launch the UI","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"Open the Julia REPL and issue the following commands to include the KomaMRI.jl package and launch the user interface:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"julia> using KomaMRI\n\njulia> KomaUI()","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"assets/gui-dashboard.png\"/></p>","category":"page"},{"location":"ui-details/#Inputs","page":"Graphical User Interface","title":"Inputs","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"The user interface has already preloaded some inputs (stored in RAM). In particular, it has predefined the Scanner, the Phantom and the Sequence structs. In the following subsections, we will show how to visualize these inputs.","category":"page"},{"location":"ui-details/#Scanner","page":"Graphical User Interface","title":"Scanner","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"So far, it is not possible to see the Scanner struct in the user interface. However, the preloaded Scanner struct is the default one, so it is possible to know its attributes by creating a new default Scanner struct in the Julia REPL like so:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"julia> sys = Scanner()\nScanner\n  B0: Float64 1.5\n  B1: Float64 1.0e-5\n  Gmax: Float64 0.06\n  Smax: Int64 500\n  ADC_Δt: Float64 2.0e-6\n  seq_Δt: Float64 1.0e-5\n  GR_Δt: Float64 1.0e-5\n  RF_Δt: Float64 1.0e-6\n  RF_ring_down_T: Float64 2.0e-5\n  RF_dead_time_T: Float64 0.0001\n  ADC_dead_time_T: Float64 1.0e-5","category":"page"},{"location":"ui-details/#Phantom","page":"Graphical User Interface","title":"Phantom","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"To see the phantom already stored in RAM, simply click on the Phantom dropdown an then press the View Phantom button. The preloaded phantom is a slice of a brain:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"assets/gui-phantom-view.png\"/></p>","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"It is also possible to load .h5 phantom files. The KomaMRI.jl has some examples stored at ~/.julia/packages/KomaMRI/<id-string>/examples/2.phantoms/. For instance, let's load the sphere_chemical_shift.h5 file:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"assets/gui-phantom-load.png\"/></p>","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"Note that you can select different spin parameters to visualize like rho, T_1, T_2, among others. ","category":"page"},{"location":"ui-details/#Sequence","page":"Graphical User Interface","title":"Sequence","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"There are two options to visualize the sequence already preloaded in RAM: in the time domain or in the k-space. The preloaded sequence is a single-shot EPI.","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"For visualization of the sequence in the time domain, click on the Sequence dropdown and then press the Sequence (MPS) button:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"assets/gui-seq-time-view.png\"/></p>","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"For visualization of the sequence in the k-space, click on the Sequence dropdown and then press the k-space button:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"assets/gui-seq-kspace-view.png\"/></p>","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"It is also possible to load .seq sequence files. The KomaMRI.jl has some examples stored at ~/.julia/packages/KomaMRI/<id-string>/examples/1.sequences/. For instance, let's load the spiral.seq file and view it the time domain and k-space:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"assets/gui-seq-time-load.png\"/></p>","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"assets/gui-seq-kspace-load.png\"/></p>","category":"page"},{"location":"ui-details/#Simulation","page":"Graphical User Interface","title":"Simulation","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"Once the inputs are loaded in RAM, it is possible to perform the simulation to get the Raw Signal.","category":"page"},{"location":"ui-details/#Simulation-Parameters","page":"Graphical User Interface","title":"Simulation Parameters","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"To visualize the default simulation parameters, click on the Simulate! dropdown and then press the View Options button:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"assets/gui-sim-params-view.png\"/></p>","category":"page"},{"location":"ui-details/#Visualization-of-the-Raw-Signal","page":"Graphical User Interface","title":"Visualization of the Raw Signal","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"Press the Simulate! button to perform the simulation (this may take a while). Then, to view the generated Raw Signal, click on the Raw Data dropdown and then press the View Raw Data button:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"assets/gui-rawsignal-view.png\"/></p>","category":"page"},{"location":"ui-details/#Reconstruction","page":"Graphical User Interface","title":"Reconstruction","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"Once the Raw Signal is loaded in RAM, it is possible to reconstruct the image.","category":"page"},{"location":"ui-details/#Reconstruction-Parameters","page":"Graphical User Interface","title":"Reconstruction Parameters","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"To visualize the default reconstruction parameters, click on the Reconstruct! dropdown and then press the View Options button:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"assets/gui-recon-params-view.png\"/></p>","category":"page"},{"location":"ui-details/#Visualization-of-the-Image","page":"Graphical User Interface","title":"Visualization of the Image","text":"","category":"section"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"Press the Reconstruct! button to perform the reconstruction (this may take a while). Then, to view the generated Image, click on the he Reconstruct! dropdown and then press the |Image| button:","category":"page"},{"location":"ui-details/","page":"Graphical User Interface","title":"Graphical User Interface","text":"<p align=\"center\"><img width=\"90%\" src=\"assets/gui-image-view.png\"/></p>","category":"page"},{"location":"mri-theory/#Koma's-Simulation-Method","page":"Simulation Method","title":"Koma's Simulation Method","text":"","category":"section"},{"location":"mri-theory/#Physical-and-Mathematical-Background","page":"Simulation Method","title":"Physical and Mathematical Background","text":"","category":"section"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"Koma simulates the magnetization of each spin by solving the Bloch equations in the rotating frame:","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"beginalign tag1\n\nfracmathrmd boldsymbolMmathrmd t =\n  gamma boldsymbolM times boldsymbolB\n- fracM_x hatx + M_y hatyT_2\n- fracM_z hatx + M_0 hatyT_1 \n\nendalign","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"with gamma the gyromagnetic ratio, boldsymbolM = M_x M_y M_z^T the magnetization vector, and","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"boldsymbolB = B_1x(t) B_1y(t) boldsymbolG(t) cdot boldsymbolx + Delta omega(t)^T","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"the effective magnetic field. M_0 is the proton density, T_1 and T_2 are the relaxation times, and Delta omega is the off-resonance, for each position.","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"The solution of Equation (1) for a single spin is independent of the state of the other spins in the system, a key feature that enables parallelization (look at GPU/CPU Parallelization).","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"Our simulator also uses the method of operator splitting to simplify the solution of Equation (1). This reflects mathematically the intuition of separating the Bloch equations in a rotation operator described by","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"beginalign tag2\n\nfracmathrmdmathrmdt boldsymbolM =\nbeginbmatrix\n 0            gamma B_z  -gamma B_y \n-gamma B_z   0            gamma B_x \n gamma B_y  -gamma B_x   0\nendbmatrix\nboldsymbolM \n\nendalign","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"and a relaxation operator described by","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"beginalign tag3\n\nfracmathrmdmathrmdt boldsymbolM =\nbeginbmatrix\n-tfrac1T_2  0  0 \n0  -tfrac1T_2  0 \n0  0  -tfrac1T_1\nendbmatrix\nboldsymbolM\n+\nbeginbmatrix\n0 \n0 \ntfracM_0T_1\nendbmatrix \n\nendalign","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"The evolution of the magnetization can then be described as a two-step process for each time step Delta t (Figure 2).","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"<p align=\"center\">\n<figure>\n  <img width=\"60%\" src=\"assets/block-equation-intuition.svg\">\n  <figcaption><b>Figure 2</b>: Solution of the Bloch equations for one time step can be described by (2) a rotation and (3) a relaxation step.</figcaption>\n</figure>\n</p>","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"Furthermore, we define two regimes in the pulse sequence: excitation and precession. During the latter, the excitation fields are nulled: B_x = B_y = 0 in Equation (2). In the precession regime, the operator splitting method gives an exact solution, whereas during the excitation regime the method has O(Delta t^3) convergence.","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"From this point forward, we will drop the vectorial notation for boldsymbolM and boldsymbolB_1, and we will use M_xy = M_x + i M_y and B_1 = B_1x + i B_1y to describe the simplifications made in each regime.","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"The rotations during the excitation regime are stored in their spin-domain or SU(2) representation","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"boldQ =\nbeginbmatrix\nalpha -beta^* \nbeta  -alpha^*\nendbmatrix quadquad\ntextwith\nalpha^2 + beta^2 = 1 ","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"characterized by the Cayley-Klein complex parameters or Spinors for short (alphabeta). Spinors can represent any 3D rotation as","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"alpha = cos left( tfracvarphi2 right)  - i  n_z sin left( tfracvarphi2 right) \nbeta = -i n_xy sin left( tfracvarphi2 right) ","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"To solve Equation (2) the parameters for the Spinors are n_xy = tfracB_1lVert boldsymbolB rVert, n_z = tfracB_zlVert boldsymbolB rVert, and","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"beginalign tag4\n\nvarphi = - gamma lVert boldsymbolB rVert Delta t \n\nendalign","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"Then, the application of a Spinor rotation to a magnetization element is described by the operation","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"beginalign tag5\n\nbeginbmatrix\nM_xy^+ \nM_z^+\nendbmatrix = \nbeginbmatrix\n2alpha^* beta M_z + alpha^*^2 M_xy - beta^2 M_xy^* \n(alpha^2 - beta^2)M_z - 2Releft( alpha beta M_xy^* right)\nendbmatrix\n\nendalign","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"For the precession regime, all the rotations are with respect to z, and therefore they can be described with a complex exponential applied to the transverse magnetization","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"beginalign tag6\n\nM_xy^+ = M_xy e^ivarphi \n\nendalign","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"where varphi is defined in Equation (4).","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"Finally, to solve the relaxation step described in Equation (3) the magnetization is updated by","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"beginbmatrix\nM_xy^+ \nM_z^+\nendbmatrix =\nbeginbmatrix\nM_xy e^-tfracDelta tT_2 \nM_z e^-tfracDelta tT_1 + M_0left(1-e^-tfracDelta tT_1right)\nendbmatrix ","category":"page"},{"location":"mri-theory/#Simulation-Blocks,-Regime-Switching,-and-Sequence-Aware-Time-Stepping","page":"Simulation Method","title":"Simulation Blocks, Regime Switching, and Sequence-Aware Time Stepping","text":"","category":"section"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"To reduce the memory usage of our simulator, we subdivided time into Nblocks (Figure 3). KomaMRI classifies each block in either the excitation regime or the precession regime before the simulation.","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"For precession blocks, we can improve the accuracy of the simulations by using the integral representation of Equation (6), obtained by applying the limit as Delta t rightarrow 0 of iterated applications of Equation (6), giving a phase of","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"varphi = - gamma int_t_i^t_i+1 boldsymbolG(tau) cdot boldsymbolx(tau)  mathrmdtau - int_t_i^t_i+1 Delta omega(tau)  mathrmdtau ","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"Assuming that during the i-th simulation block (t in t_it_i+1) the gradients boldsymbolG(t) are piece-wise linear functions, and boldsymbolx(t) and Delta omega (t) are approximately constant, then, if we use the trapezoidal rule to obtain the value of this integral, we will obtain an exact result by sampling just the vertices of boldsymbolG(t), greatly reducing the number of points required by the simulation. We will only need intermediate points in the case of motion and for recording the sampling points as required by the Analog to Digital Converter (ADC). The user can control the time between intermediate gradient samples with the parameter Δt (Figure 3).","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"We can do something similar with B_1(t) in the excitation regime. If we assume B_1(t) is a piece-wise constant function (or concatenation of hard pulses), then Equation (5) will give an exact solution to Equation (2). The parameter Δt_rf manages the time between RF samples (Figure 3), and can be relatively large for 2D imaging where the slice profile is less relevant.","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"Thus, KomaMRI uses the rationale mentioned above to: (1) call different methods based on the regime of each block, while also (2) obtaining a variable time stepping schedule that adapts to the sequence needs. We named the latter sequence-aware time stepping (Figure 3).","category":"page"},{"location":"mri-theory/#GPU/CPU-Parallelization","page":"Simulation Method","title":"GPU/CPU Parallelization","text":"","category":"section"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"We further increase the simulation speed by separating the Bloch calculations into Nthreads and then performing the GPU operations with CUDA.jl (Figure 3). This separation is possible as all magnetization vectors are independent of one another.","category":"page"},{"location":"mri-theory/","page":"Simulation Method","title":"Simulation Method","text":"<p align=\"center\">\n<figure>\n  <img width=\"100%\" src=\"assets/koma-solution.svg\">\n  <figcaption><b>Figure 3</b>: This is a summary of the functions called to perform the simulation. The sequence <b>seq</b> is discretized after calculating the required time points in the wrapper function <b>simulate</b>. The time points are then divided into <b>Nblocks</b> to reduce the amount of memory used. The phantom <b>obj</b> is divided into <b>Nthreads</b>, and <b>KomaMRI</b> will use either <b>run_spin_excitation</b> or <b>run_spin_precession</b> depending on the regime. If an ADC object is present, the simulator will add the signal contributions of each thread to construct the acquired signal <b>S[t]</b>. All the parameters: <b>Nthreads</b>, <b>Nblocks</b>, <b>Δt_rf</b>, and <b>Δt</b>, are passed through a dictionary called <b>simParams</b> as an optional parameter of the <b>simulate</b> function.\n</figure>\n</p>","category":"page"},{"location":"simulation-examples/#Simulation-Examples","page":"Examples","title":"Simulation Examples","text":"","category":"section"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"These examples are designed so you can go along by copying and pasting the code blocks. 😃. Before starting, don't forget to include the KomaMRI package:","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"using KomaMRI # Copy me by clicking the icon at the right! ------>","category":"page"},{"location":"simulation-examples/#Free-Induction-Decay","page":"Examples","title":"Free Induction Decay","text":"","category":"section"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"The free induction decay is the simplest observable NMR signal. This signal is the one that follows a single tipping RF pulse. To recreate this experiment, we will need to define a Sequence with 2 blocks. ","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"The first block containing an RF pulse with a flip-angle of 90 deg, ","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"ampRF = 2e-6                        # 2 uT RF amplitude\ndurRF = π / 2 / (2π * γ * ampRF)    # required duration for a 90 deg RF pulse\nexc = RF(ampRF,durRF)\nnothing # hide","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"and the second block containing the ADC.","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"nADC = 8192         # number of acquisition samples\ndurADC = 250e-3     # duration of the acquisition\ndelay =  1e-3       # small delay\nacq = ADC(nADC, durADC, delay)\nnothing # hide","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"Finally, we concatenate the sequence blocks to create the final sequence (for more info. refer to Sequence Structure).","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"seq = Sequence()  # empty sequence\nseq += exc        # adding RF-only block\nseq += acq        # adding ADC-only block\np = plot_seq(seq; slider=false, height=300)\nsavefig(p, \"assets/1-seq.html\") # hide\nnothing # hide","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"<object type=\"text/html\" data=\"assets/1-seq.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"Now, we will define a Phantom with a single spin at x=0 with T_1=1000mathrmms and T_2=100mathrmms.","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"obj = Phantom(x=[0], T1=[1000e-3], T2=[100e-3])\nnothing # hide","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"Finally, to simulate we will need to use the function simulate.","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"sys = Scanner() # default hardware definition\nraw = simulate(obj, seq, sys)","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"To plot the results we will need to use the plot_signal function ","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"p = plot_signal(raw; slider=false, height=300)\nsavefig(p, \"assets/1-signal.html\"); nothing # hide","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"<object type=\"text/html\" data=\"assets/1-signal.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"Nice!, we can see that S(t) follows an exponential decay exp(-tT_2) as expected.","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"For a little bit of spiciness, let's add off-resonance to our example. We will use Delta f=-100mathrmHz. For this, we will need to add a definition for Δw in our Phantom","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"obj = Phantom(x=[0], T1=[1000e-3], T2=[100e-3], Δw=[-2π*100])\nnothing # hide","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"and simulate again.","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"raw = simulate(obj, seq, sys)\np = plot_signal(raw; slider=false, height=300)\nsavefig(p, \"assets/2-signal.html\"); nothing # hide","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"<object type=\"text/html\" data=\"assets/2-signal.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"The signal now follows an exponential of the form exp(-tT_2)cdotexp(-iDeltaomega t). The addition of exp(-iDeltaomega t) to the signal will generate a shift in the image space (Fourier shifting property). This effect will be better visualized and explained in later examples.","category":"page"},{"location":"simulation-examples/#Chemical-Shift-in-an-EPI-sequence","page":"Examples","title":"Chemical Shift in an EPI sequence","text":"","category":"section"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"For a more realistic example, we will use a brain phantom. ","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"using KomaMRI\nsys = Scanner()","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"obj = brain_phantom2D() # a slice of a brain\np1 = plot_phantom_map(obj, :T2 ; height=400)\np2 = plot_phantom_map(obj, :Δw ; height=400)\nsavefig(p1, \"assets/1-phantom.html\"); nothing # hide\nsavefig(p2, \"assets/2-phantom.html\"); nothing # hide","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"At the left, you can see the T_2 map of the phantom, and at the right, the off-resonance Deltaomega. In this example, the fat is the only source of off-resonance (with Delta f =  -220mathrmHz) and you can see it in black in the off-resonance map.","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"<object type=\"text/html\" data=\"assets/1-phantom.html\" style=\"width:50%; height:420px;\"></object><object type=\"text/html\" data=\"assets/2-phantom.html\" style=\"width:50%; height:420px;\"></object>","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"Then, we will load an EPI sequence, that is well known for being affected by off-resonance. With this sequence, we will be able visualize the effect of the chemical shift.","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"seq = read_seq(\"../../examples/3.koma_paper/comparison/sequences/EPI/epi_100x100_TE100_FOV230.seq\")\np = plot_seq(seq; range=[0 40], slider=true, height=300)\nsavefig(p, \"assets/2-seq.html\"); ","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"seq = read_seq(\"examples/3.koma_paper/comparison/sequences/EPI/epi_100x100_TE100_FOV230.seq\")","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"Feel free to explore the sequence's plot 🔍 below!","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"<object type=\"text/html\" data=\"assets/2-seq.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"If we simulate this sequence we will end up with the following signal.","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"raw = simulate(obj, seq, sys)","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"p = plot_signal(raw; range=[98.4 103.4] , height=300)\nsavefig(p, \"assets/3-signal.html\"); nothing # hide","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"<object type=\"text/html\" data=\"assets/3-signal.html\" style=\"width:100%; height:320px;\"></object>","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"Now, we need to inspect what effect the off-resonance had in the reconstructed image. As you can see, the fat layer is now shifted to a different position 🤯, this is why the effect is called chemical shift!","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"# Get the acquisition data\nacq = AcquisitionData(raw)\nacq.traj[1].circular = false #This is to remove a circular mask\n\n# Setting up the reconstruction parameters\nNx, Ny = raw.params[\"reconSize\"][1:2]\nreconParams = Dict{Symbol,Any}(:reco=>\"direct\", :reconSize=>(Nx, Ny))\nimage = reconstruction(acq, reconParams)\n\n# Plotting the recon\nslice_abs = abs.(image[:, :, 1])\np = plot_image(slice_abs; height=400)\nsavefig(p, \"assets/1-recon.html\");  nothing # hide","category":"page"},{"location":"simulation-examples/","page":"Examples","title":"Examples","text":"<center>\n<object type=\"text/html\" data=\"assets/1-recon.html\" style=\"width:65%; height:420px;\">\n</center>","category":"page"},{"location":"sequence/#Sequence-Definition","page":"-","title":"Sequence Definition","text":"","category":"section"},{"location":"sequence/","page":"-","title":"-","text":"This subsection dives into some details about how a sequence is constructed. Let's introduce the following simple sequence figure to extend the ideas from a visual example to a more general sequence definition:","category":"page"},{"location":"sequence/","page":"-","title":"-","text":"<p align=\"center\">\n<img width=\"90%\" src=\"assets/sequence-diagram.svg\"/>\n</p>","category":"page"},{"location":"sequence/","page":"-","title":"-","text":"A sequence can be thought as and ordered concatenation of blocks over time. Every block is composed by an RF pulse, the (xyz) gradients,  and the acquisition of the samples. There is also a time duration associated to each block. For short, we are going to refer to these components like so:","category":"page"},{"location":"sequence/","page":"-","title":"-","text":"beginmatrix*l\ni            textsequence block ID \nRFi        textRF pulse at the i block \nG_ji       textgradients at the i block  forall j in xyz \nADCi       textacquisition at the i block \nDURi       textduration at the i block\nendmatrix*","category":"page"},{"location":"sequence/","page":"-","title":"-","text":"Additionally, there are associated some uniform time resolution parameters or raster times for the RF, gradients and adquistion:","category":"page"},{"location":"sequence/","page":"-","title":"-","text":"beginmatrix*l\nDelta t_RF     textraster time for RF pulses\nDelta t_G      textraster time for gradients\nDelta t_ADC    textraster time for acquisition\nendmatrix*","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KomaMRI.jl is a Julia package meant to simulate general Magnetic Resonance Imaging (MRI) scenarios. Its name comes from the Japanese word for spinning-top こま (ko-ma) as they precess due to gravity like spins in a magnetic field.","category":"page"},{"location":"","page":"Home","title":"Home","text":"KomaMRI generates raw data by solving the Bloch equations using the specified scanner, phantom and sequence. It also provides a Graphical User Interface (GUI) that encapsulates the whole imaging pipeline (simulation and reconstruction).","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\"><img class=\"display-light-only\" width=\"100%\" src=\"assets/koma-schema.svg\"/></p>\n<p align=\"center\"><img class=\"display-dark-only\"  width=\"100%\" src=\"assets/koma-schema-dark.svg\"\"/></p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"KomaMRI can be used by either:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Graphical User Interface: User-friendly interaction. No Julia programming skills are required. Refer to Graphical User Interface to check the simplest usage example.\nScripts : Basic knowledge of Julia is required. Refer to Brain Example to check a tutorial. Refer to the API documentation to discover all the functions that the package has to offer.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Some of the features of KomaMRI.jl are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fast simulations by using CPU and GPU parallelization.\nOpen Source, so anyone can include additional features.\nCompatibility with community-standards like Pulseq .seq and ISMRMRD .mrd.\nCross-platform thanks to the use of the Julia programing language.\nFriendly user interface for people with no programming skills.\nFlexible API for advance users.","category":"page"},{"location":"#Potential-Use-Cases","page":"Home","title":"Potential Use Cases","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We see Koma being used in:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The generation of synthetic data to train Machine Learning models.\nTo test novel pulse sequences before implementing them directly in a real scanner (with a Pulseq sequence).\nTeaching exercises for  MRI acquisition or reconstruction.","category":"page"},{"location":"mri-theory-informal/#MRI-Theory","page":"MRI Theory","title":"MRI Theory","text":"","category":"section"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"This section is meant to be a general overview or summary of the main MRI concepts and insights. It is a good starting point to show up the most relevant components involved and how they are related for raw signal acquisition and image reconstruction. The idea is to have a fresh and clear understanding of what is happening behind the scenes when using the KomaMRI.jl package. Some light background in Differential Equations, Signal Processing and Fourier Theory is advisable to follow along.   ","category":"page"},{"location":"mri-theory-informal/#Raw-Signal-Generation","page":"MRI Theory","title":"Raw Signal Generation","text":"","category":"section"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"In order to generate an image from a phantom object with a scanner system and sequence signals, its necessary to acquire a raw signal s(t). This signal can be though as the sum of all spin magnetizations M of the object:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"s(t) =\nint_x int_y int_z\nunderbrace\nM(x y z t)\n_approx  alpha  image(xyz) \n mathrmdz  mathrmdy  mathrmdx","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Note that the magnitude of the magnetization is kind of proportional to the image. In real life it's not possible to get directly all the spin magnetizations, however it's possible to obtain the sum of all of them in the raw signal. To avoid losing image information in the sum operation, every spin magnetization resonates with different Larmor frequencies which values depend on the position (xyz) (i.e. modulated or encoded with the basis of the spatial frequency domain). Thus the raw signal can be thought as:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"beginalign tag1\n\ns(t) approx\nint_x int_y int_z\nunderbrace\nm(x y z)\n_alpha  image(xyz)\nunderbrace\ne^-j 2 pi k_x(t) x + k_y(t) y + k_z(t) z\n_modulation  basis \n mathrmdz  mathrmdy  mathrmdx\n\nendalign","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"where:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"veck(t) =\nbeginpmatrix\nk_x(t) \nk_y(t) \nk_z(t)\nendpmatrix =\nfrac2pigamma\nbeginpmatrix\nint_0^t G_x(tau) mathrmd tau\nint_0^t G_y(tau) mathrmd tau\nint_0^t G_z(tau) mathrmd tau\nendpmatrix\n  \nbeginmatrix*l\ngamma  gyromagnetic  ratio \nG_i(t)  input  gradient  signals\nendmatrix*","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"In the above expressions, we can see that the frequency of each spin can be manipulated by applying input gradient signals (or a gradient field). In practice, this gradient field is applied in the longitudinal axis hatz (but it is always dependent on the (xyz) position), which makes the spins able to resonate (or precess) at different Larmor frequencies after another input RF pulse excite them in the transverse direction. Both inputs, the gradient signal and the RF pulse, are part of the effective magnetic field vecB(t):","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"vecB(t) = \nbeginpmatrix\nB_1x(t) \nB_1y(t) \nG_x(t) x + G_y(t) y + G_z(t) z\nendpmatrix\n  \nbeginmatrix*l\nB_1i(t)  input  RF  pulse  (transverse) \nG_i(t)      input  gradients  (longitudinal)\nendmatrix*","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"It's important to highlight that the coil that senses the raw signal can only detects magnetization components oriented in the transverse direction. For this reason is necessary to apply the short RF signal orthogonally to the longitudinal hatz axe.","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"One of the primary concerns, to generate an image is to design proper input signals for the effective magnetic field vecB(t). In particular, by inspecting equation (1), it's possible to manipulate the spacial frequencies k_x(t), k_y(t) and k_z(t) by applying the gradients G_x(t), G_y(t) and G_z(t). Thus, we have information of the raw signal s(t) an the basis e^-j 2 pi k_x(t) x + k_y(t) y + k_z(t) z. Mathematically speaking, every sample of the raw signal is the Fourier transform of the magnetization m(xyz) for a specific point of the spacial frequency domain:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"s(t) = Fourierm  (k_x(t) k_y(t) k_z(t))","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Therefore, to get the magnetization m(xyz) for all the points in the spacial domain its necessary to solve the inverse problem with enough points to cover the complete spacial frequency domain, which can be achieved by following a trajectory over time applying different gradient signals (i.e. a trajectory to complete the k-space).","category":"page"},{"location":"mri-theory-informal/#K-Space-and-Acquisition","page":"MRI Theory","title":"K-Space and Acquisition","text":"","category":"section"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Note that the trajectory to cover the k-space eventually can have any continuos shape, however it cannot fill the complete space. Furthermore, due to natural hardware restrictions, the continuos trajectory is sampled during the acquisition of the raw signal st. Thus, every discrete point of st represents a discrete point in the k-space.","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Intuitively, it is desirable to get many points as possible and homogeneously distributed in the k-space. In particular, since the theory behind the raw signal generation is intimately related with the Fourier Transform, a natural way to cover the k-space is by taken a discrete mesh grid of points (trajectories and samples separated by small cubes). In this case, it is possible to apply Fourier theory to define the minimal k-space resolution (separation of the samples in the k-space) to set space dimensions (Field of Views) and prevent aliasing in the image, and define maximal limits in the k-space to set space resolution in the image.","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"underbrace\nDelta k_i\n_k-space  resolution\nlongrightarrow\nunderbrace\nFOV_i\n_space  width  bounds ","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"underbrace\nW_k_i\n_k-space  width  bounds\nlongrightarrow\nunderbrace\nDelta i\n_space  resolution ","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"forall i in x y  z","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Even though a mesh grid of discrete points is the natural way of thinking to cover the k-space, it is always possible possible to apply more exotic k-space trajectories, which could be helpful, for instance, to reduce the complete acquisition time. Keep in mind though, this fact must be regarded when solving the inverse problem for obtaining the image, for example by applying and interpolation function before taking the inverse Fourier Transform.","category":"page"},{"location":"mri-theory-informal/#Spin-Dynamics","page":"MRI Theory","title":"Spin Dynamics","text":"","category":"section"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"It's important to point out that all the magnetization spins are independent from each other, so we could separate the phantom object into multiple spins and solve the Bloch Equations for every magnetization vector vecM independently:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"fracmathrmd vecMmathrmd t =\n  gamma vecM times vecB\n- fracM_x hatx + M_y hatyT_2\n- fracM_z hatx + M_0 hatyT_1","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"or:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"beginalign tag2\n\nfracmathrmdmathrmdt vecM =\nunderbrace\ngamma\nbeginbmatrix\n 0     B_z  -B_y \n-B_z   0     B_x \n B_y  -B_x   0\nendbmatrix\nvecM\n_textrotation \n-\nunderbrace\nbeginbmatrix\ntfrac1T_2  0  0 \n0  tfrac1T_2  0 \n0  0  tfrac1T_1\nendbmatrix\nvecM\n_textrelaxation \n+\nunderbrace\nbeginbmatrix\n0 \n0 \ntfracM_0T_1\nendbmatrix\n_textsteady-state \n\nendalign","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"beginmatrix*l\ngamma  gyromagnetic  ratio \nT_2     transverse  relaxation  time  constant \nT_1     longitudinal  relaxation  time  constant\nendmatrix*","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"vecM(t) =\nbeginpmatrix\nM_x(t) \nM_y(t) \nM_z(t)\nendpmatrix\n  \nvecB(t) = \nbeginpmatrix\nB_x(t) \nB_y(t) \nB_z(t)\nendpmatrix =\nbeginpmatrix\nB_1x(t) \nB_1y(t) \nG_x(t) x + G_y(t) y + G_z(t) z\nendpmatrix","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"beginmatrix*l\nB_1i(t)  input  RF  pulse  (transverse) \nG_i(t)      input  gradients  (longitudinal)\nendmatrix*","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Note that equation (2) can be separated into three parts:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Rotation: governed by the inputs RF pulse and gradient signals. It gives an initial excitation and the oscillatory behavior for different Larmor frequencies, respectively. \nRelaxation: gives the decay behavior (the magnetization envelope) after the excitation of the spins.\nSteady-State: spins points towards the longitudinal direction after a while.","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"Thus, to get the raw signal s(t) it's necessary to solve the Bloch equations (equation (2)) for every spin of the phantom object, then sum up the contributions of all of them and finally consider just the components of the transverse plane:","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"s(t) = s_xy(t)\n  \ns_xy(t) = s_x(t) + j s_y(t)","category":"page"},{"location":"mri-theory-informal/","page":"MRI Theory","title":"MRI Theory","text":"beginpmatrix\ns_x(t) \ns_y(t) \ns_z(t)\nendpmatrix =\nint_x int_y int_z\nvecM(x y z t)\n mathrmdz  mathrmdy  mathrmdx","category":"page"},{"location":"docstrings/#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"docstrings/#dataflow-graph","page":"API Documentation","title":"Dataflow Graph","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"(Image: )","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Pages = [\"docstrings.md\"]\nDepth = 3","category":"page"},{"location":"docstrings/#datatypes","page":"API Documentation","title":"DataTypes","text":"","category":"section"},{"location":"docstrings/#Mag","page":"API Documentation","title":"Mag","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Mag\nMag(::Phantom, ::Symbol)\nshow(::IO, ::Mag)\ngetproperty(::Vector{Mag}, ::Symbol)","category":"page"},{"location":"docstrings/#KomaMRI.Mag","page":"API Documentation","title":"KomaMRI.Mag","text":"mag = Mag(xy::Complex, z::Real)\n\nThe Magnetization struct.\n\nArguments\n\nxy: (::Complex{Int64}) the magnetization of a spin in the xy plane\nz: (::Real) the magnetization of a spin in the z plane\n\nReturns\n\nmag: (::Mag) the Magnetization struct\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#KomaMRI.Mag-Tuple{Phantom, Symbol}","page":"API Documentation","title":"KomaMRI.Mag","text":"mag = Mag(p::Phantom, dir::Symbol)\n\nGenerates a Vector of Mag structs with the information of the p panthom struct (the proton density) in the axis given by the dir symbol.\n\nArguments\n\np: (::Phantom) the phantom struct\ndir: (::Symbol, opts: [:x, :z]) the symbol that represents the axis of the   magnetization\n\nReturns\n\nmag: (Vector{Mag}) the vector of Magnetization structs\n\nExamples\n\njulia> obj = Phantom(x=zeros(5));\n\njulia> mag = Mag(obj, :z)\n5-element Vector{Mag}:\n Mag(xy = 0.0 + 0.0im, z = 1.0)\n Mag(xy = 0.0 + 0.0im, z = 1.0)\n Mag(xy = 0.0 + 0.0im, z = 1.0)\n Mag(xy = 0.0 + 0.0im, z = 1.0)\n Mag(xy = 0.0 + 0.0im, z = 1.0)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.show-Tuple{IO, Mag}","page":"API Documentation","title":"Base.show","text":"str = show(io::IO, x::Mag)\n\nDisplays information about the Mag struct x in the julia REPL.\n\nArguments\n\nx: (::Mag) the Magnetization struct\n\nReturns\n\nstr (::String) the output string message\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.getproperty-Tuple{Vector{Mag}, Symbol}","page":"API Documentation","title":"Base.getproperty","text":"y = getproperty(x::Vector{Mag}, f::Symbol)\n\nOverchages Base.getproperty(). It is meant to access properties of the Mag vector x directly without needing to iterate elementwise.\n\nArguments\n\nx: (::Vector{Mag}) the vector of Mag structs\nf: (::Symbol, opts: [:xy, :z]) the symbol that represents a property of a Mag   struct\n\nReturns\n\ny: (::Vector{Any}) the vector with the property defined by the f symbol for all   elements of the Mag vector x\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Phantom","page":"API Documentation","title":"Phantom","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.Phantom — Type\nKomaMRI.brain_phantom2D — Function\nKomaMRI.brain_phantom3D — Function","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.heart_phantom","category":"page"},{"location":"docstrings/#KomaMRI.heart_phantom","page":"API Documentation","title":"KomaMRI.heart_phantom","text":"phantom = heart_phantom(α=1, β=1, γ=1, fat_bool::Bool=false)\n\nHeart-like LV phantom. The variable α is for streching, β for contraction, and γ for rotation.\n\nArguments\n\nα: (::Real, =1) the streching parameter\nβ: (::Real, =1) the contraction parameter\nγ: (::Real, =1) the rotation parameter\nfat_bool: (::Bool, =false) the fat boolean parameter\n\nReturns\n\nphantom: (::Phantom) the Heart-like LV phantom struct\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Scanner","page":"API Documentation","title":"Scanner","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.Scanner — Type","category":"page"},{"location":"docstrings/#Sequence","page":"API Documentation","title":"Sequence","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.Sequence — Type","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"show(::IO, ::Sequence)\nKomaMRI.is_ADC_on\nKomaMRI.is_RF_on\nKomaMRI.is_GR_on\nKomaMRI.is_Gx_on\nKomaMRI.is_Gy_on\nKomaMRI.is_Gz_on\nKomaMRI.is_Delay\nKomaMRI.durs(::Sequence)\ndur(::Sequence)\nKomaMRI.⏢\nKomaMRI.get_grads\nKomaMRI.get_rfs\nKomaMRI.get_flip_angles\nKomaMRI.get_ADC_on\nKomaMRI.get_kspace\nKomaMRI.get_RF_types\n\nKomaMRI.δ2N","category":"page"},{"location":"docstrings/#Base.show-Tuple{IO, Sequence}","page":"API Documentation","title":"Base.show","text":"str = show(io::IO, s::Sequence)\n\nDisplays information about the Sequence struct s in the julia REPL.\n\nArguments\n\ns: (::Sequence) the Sequence struct\n\nReturns\n\nstr (::String) the output string message\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.is_ADC_on","page":"API Documentation","title":"KomaMRI.is_ADC_on","text":"y = is_ADC_on(x::Sequence)\ny = is_ADC_on(x::Sequence, t::Union{Array{Float64,1}, Array{Float64,2}})\n\nTells if the sequence seq has elements with ADC active, or active during time t.\n\nArguments\n\nx: (::Sequence) the sequence struct\nt: (::Union{Array{Float64,1}, Array{Float64,2}}, [s]) the time to check\n\nReturns\n\ny: (::Bool) the boolean that tells whether or not the ADC in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.is_RF_on","page":"API Documentation","title":"KomaMRI.is_RF_on","text":"y = is_RF_on(x::Sequence)\ny = is_RF_on(x::Sequence, t::Vector{Float64})\n\nTells if the sequence seq has elements with RF active, or active during time t.\n\nArguments\n\nx: (::Sequence) the sequence struct\nt: (::Vector{Float64}, [s]) the time to check\n\nReturns\n\ny: (::Bool) the boolean that tells whether or not the RF in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.is_GR_on","page":"API Documentation","title":"KomaMRI.is_GR_on","text":"y = is_GR_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active.\n\nArguments\n\nx: (::Sequence) the sequence struct\n\nReturns\n\ny: (::Bool) the boolean that tells whether or not the GR in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.is_Gx_on","page":"API Documentation","title":"KomaMRI.is_Gx_on","text":"y = is_Gx_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in x direction.\n\nArguments\n\nx: (::Sequence) the sequence struct\n\nReturns\n\ny: (::Bool) the boolean that tells whether or not the GRx in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.is_Gy_on","page":"API Documentation","title":"KomaMRI.is_Gy_on","text":"y = is_Gy_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in y direction.\n\nArguments\n\nx: (::Sequence) the sequence struct\n\nReturns\n\ny: (::Bool) the boolean that tells whether or not the GRy in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.is_Gz_on","page":"API Documentation","title":"KomaMRI.is_Gz_on","text":"y = is_Gz_on(x::Sequence)\n\nTells if the sequence seq has elements with GR active in z direction.\n\nArguments\n\nx: (::Sequence) the sequence struct\n\nReturns\n\ny: (::Bool) the boolean that tells whether or not the GRz in the sequence is active\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.is_Delay","page":"API Documentation","title":"KomaMRI.is_Delay","text":"y = is_Delay(x::Sequence)\n\nTells if the sequence seq is a delay.\n\nArguments\n\nx: (::Sequence) the sequence struct\n\nReturns\n\ny::Bool: the boolean that tells whether or not the sequence is a delay\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.durs-Tuple{Sequence}","page":"API Documentation","title":"KomaMRI.durs","text":"ΔT = durs(x::Sequence)\n\nReturns the array of durations of sequence's blocks in [s].\n\nArguments\n\nx: (::Sequence) the sequence struct\n\nReturns\n\nΔT: (::Vector{Real}, [s]) the array of durations of sequence's blocks\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.dur-Tuple{Sequence}","page":"API Documentation","title":"KomaMRI.dur","text":"T = dur(x::Sequence)\n\nThe total duration of the sequence in [s].\n\nArguments\n\nx: (::Sequence) the sequence struct\n\nReturns\n\nT: (::Real, [s]) the total duration of the sequence\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.⏢","page":"API Documentation","title":"KomaMRI.⏢","text":"y = ⏢(A, t, ΔT, ζ1, ζ2, delay)\n\nGenerates a trapezoidal waveform vector.\n\nArguments\n\nA: (::Real) the amplitude\nt: (::Vector{Float64}, [s]) the times to evaluate (actually it's a 1-row   ::Matrix{Float64})\nΔT: (::Real, [s]) the time duration of the top-flat\nζ1: (::Real, [s]) the rise time duration\nζ2: (::Real, [s]) the fall time duration\ndelay: (::Real, [s]) the delay time\n\nReturns\n\ny: (::Vector{Float64}) the trapezoidal waveform (actually it's a 1-row   ::Matrix{Float64})\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_grads","page":"API Documentation","title":"KomaMRI.get_grads","text":"Gx, Gy, Gz = get_grads(seq, t::Vector)\nGx, Gy, Gz = get_grads(seq, t::Matrix)\n\nGet the gradient array from sequence seq evaluated in time points t.\n\nArguments\n\nseq: (::Sequence) the sequence struct\nt: (::Vector{Float64} or 1-row ::Matrix{Float64}, [s]) the times to evaluate\n\nReturns\n\nGx: (Vector{Float64} or 1-row ::Matrix{Float64}, [T]) the gradient vector values   in the x direction\nGy: (Vector{Float64} or 1-row ::Matrix{Float64}, [T]) the gradient vector values   in the y direction\nGz: (Vector{Float64} or 1-row ::Matrix{Float64}, [T]) the gradient vector values   in the z direction\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_rfs","page":"API Documentation","title":"KomaMRI.get_rfs","text":"B1, Δf_rf  = get_rfs(seq::Sequence, t)\n\nReturns the RF pulses and the delta frequency.\n\nArguments\n\nseq: (::Sequence) the sequence struct\nt: (1-row ::Matrix{Float64}, [s]) the time points\n\nReturns\n\nB1: (1-row ::Matrix{ComplexF64}, [T]) the vector of RF pulses\nΔf_rf: (1-row ::Matrix{Float64}, [Hz]) the delta frequency vector\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_flip_angles","page":"API Documentation","title":"KomaMRI.get_flip_angles","text":"y = get_flip_angles(x::Sequence)\n\nReturns all the flip angles of the RF pulses in the sequence x.\n\nArguments\n\nx: (::Sequence) the sequence struct\n\nReturns\n\ny: (::Vector{Float64}, [deg]) the flip angles\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_ADC_on","page":"API Documentation","title":"KomaMRI.get_ADC_on","text":"y = get_ADC_on(seq::Sequence, t::Array{Float64,1})\n\nGet the ADC struct that are active.\n\nnote: Note\nThis function is not being used.\n\nArguments\n\nseq: (::Sequence) the sequence struct\nt: (::Vector{Float64}, [s]) the time vector\n\nReturns\n\ny: (::Vector{Bool}) the ADC struct that are active\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_kspace","page":"API Documentation","title":"KomaMRI.get_kspace","text":"kspace, kspace_adc = get_kspace(seq::Sequence; Δt=1)\n\nOutputs designed k-space trajectory from sequence struct.\n\nArguments\n\nseq: (::Sequence) the sequence struct\nΔt: (::Real, =1, [s]) the nominal delta time separation between two time samples   for ADC acquisition and Gradients\n\nReturns\n\nkspace: (3-column ::Matrix{Float64}) the kspace\nkspace_adc: (3-column ::Matrix{Float64}) the adc kspace\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_RF_types","page":"API Documentation","title":"KomaMRI.get_RF_types","text":"rf_idx, rf_type = get_RF_types(seq, t)\n\nGet RF centers and types (excitation or precession). Useful for k-space calculations.\n\nArguments\n\nseq: (::Sequence) the sequence struct\nt: (::Vector{Float64}, [s]) the time values\n\nReturns\n\nrf_idx: (::Vector{Int64}) the indices of the RF centers\nrf_type: (::Vector{Int64}, opts: [0, 1]) the RF type (0: excitation, 1:   precession)\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Grad","page":"API Documentation","title":"Grad","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.Grad — Type\nKomaMRI.Grad(::Function, ::Real, ::Int64) — Method","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"rotx\nroty\nrotz\nshow(::IO, ::Grad)\ngetproperty(::Vector{Grad}, ::Symbol)\ndur(::Grad)","category":"page"},{"location":"docstrings/#KomaMRI.rotx","page":"API Documentation","title":"KomaMRI.rotx","text":"Rx = rotx(θ::Real)\n\nRotates vector counter-clockwise with respect to the x-axis.\n\nArguments\n\nθ: (::Real, [rad]) the rotation angle\n\nReturns\n\nRx: (::Matrix{Int64}) the rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.roty","page":"API Documentation","title":"KomaMRI.roty","text":"Ry = roty(θ::Real)\n\nRotates vector counter-clockwise with respect to the y-axis.\n\nArguments\n\nθ: (::Real, [rad]) the rotation angle\n\nReturns\n\nRy: (::Matrix{Int64}) the rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.rotz","page":"API Documentation","title":"KomaMRI.rotz","text":"Rz = rotz(θ::Real)\n\nRotates vector counter-clockwise with respect to the z-axis.\n\nArguments\n\nθ: (::Real, [rad]) the rotation angle\n\nReturns\n\nRz: (::Matrix{Int64}) the rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Base.show-Tuple{IO, Grad}","page":"API Documentation","title":"Base.show","text":"str = show(io::IO, x::Grad)\n\nDisplays information about the Grad struct x in the julia REPL.\n\nArguments\n\nx: (::Grad) the Grad struct\n\nReturns\n\nstr (::String) the output string message\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.getproperty-Tuple{Vector{Grad}, Symbol}","page":"API Documentation","title":"Base.getproperty","text":"y = getproperty(x::Vector{Grad}, f::Symbol)\ny = getproperty(x::Matrix{Grad}, f::Symbol)\n\nOverchages Base.getproperty(). It is meant to access properties of the Grad vector x directly without the need to iterate elementwise.\n\nArguments\n\nx: (::Vector{Grad} or ::Matrix{Grad}) the vector or matrix of Grad structs\nf: (::Symbol, opts: [:x, :y, :z, :T, :delay, :rise, :delay, :dur,   :A, f]) the input symbol that represents a property of the vector or matrix of Grad   structs\n\nReturns\n\ny: (::Vector{Any} or ::Matrix{Any}) the vector or matrix with the property defined   by the symbol f for all elements of the Grad vector or matrix x\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.dur-Tuple{Grad}","page":"API Documentation","title":"KomaMRI.dur","text":"y = dur(x::Grad)\ny = dur(x::Vector{Grad})\n\nDuration time in [s] of Grad struct or Grad array. When the input is a gradient vector, then the duration is the maximum duration of all the elements of the gradient vector.\n\nArguments\n\nx: (::Grad or ::Vector{Grad}) the RF struct or RF array\n\nReturns\n\ny: (::Float64, [s]) the duration of the RF struct or RF array\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#RF","page":"API Documentation","title":"RF","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.RF — Type","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Spinor\nshow(::IO,::Spinor)\n*(::Spinor, ::Spinor)\nRz\nRy\nRx\nKomaMRI.Rg\nKomaMRI.Rφ\nQ\nabs(::Spinor)\n\nshow(::IO, ::RF)\ngetproperty(::Vector{RF}, ::Symbol)\ndur(::RF)\nKomaMRI.RF_fun\nKomaMRI.get_flip_angle\nKomaMRI.get_RF_center","category":"page"},{"location":"docstrings/#KomaMRI.Spinor","page":"API Documentation","title":"KomaMRI.Spinor","text":"spinor = Spinor(α, β)\n\nSpinor(α, β) with Cayley-Klein parameters α and β. Based on \"Introduction to the Shinnar-Le Roux algorithm\", Patrick Le Roux (1995). A spinor is a way to represent 3D rotations, the underlying representation is a 2 X 2 complex unitary matrix (alphabetainmathbbC):\n\nR=leftbeginarraycc\nalpha  -beta^*\nbeta  alpha^*\nendarrayright\n\nwith alpha^2+beta^2 = 1.\n\nThis later operates on the 2times2 representation of (xyz) as follows V^+ = R V R^*.\n\nArguments\n\nα: (::Complex{Int64}) the Cayley-Klein parameter α\nβ: (::Complex{Int64}) the Cayley-Klein parameter β\n\nReturns\n\nspinor: (::Spinor) the Spinor struct\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Base.show-Tuple{IO, Spinor}","page":"API Documentation","title":"Base.show","text":"str = show(io::IO, s::Spinor)\n\nDisplays the spinor parameters in the julia REPL.\n\nArguments\n\ns: (::Spinor) the spinnor struct\n\nReturns\n\nstr: (::String) the output string message\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:*-Tuple{Spinor, Spinor}","page":"API Documentation","title":"Base.:*","text":"s = *(s1::Spinor, s2::Spinor)\n\nSpinor multiplication identity: (α1,β1)×(α2,β2) = (α1 α2 - β2⋆ β1 , β2 α1 + α2⋆ β1)\n\nArguments\n\ns1: (::Spinor) the first spinnor struct\ns2: (::Spinor) the second spinnor struct\n\nReturns\n\ns: (::Spinor) the multiplication spinnor identity result\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.Rz","page":"API Documentation","title":"KomaMRI.Rz","text":"s = Rz(φ)\n\nSpinor clockwise rotation matrix with angle φ with respect to z-axis.\n\nArguments\n\nφ: (::Real, [rad]) the angle with respect to z-axis\n\nReturns\n\ns: (::Spinnor) the spinnor struct that represents the Rz rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.Ry","page":"API Documentation","title":"KomaMRI.Ry","text":"s = Ry(θ)\n\nSpinor clockwise rotation matrix with angle θ with respect to y-axis.\n\nArguments\n\nθ: (::Real, [rad]) the angle with respect to y-axis\n\nReturns\n\ns: (::Spinnor) the spinnor struct that represents the Ry rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.Rx","page":"API Documentation","title":"KomaMRI.Rx","text":"s = Rx(θ)\n\nSpinor clockwise rotation matrix with angle θ with respect to x-axis.\n\nArguments\n\nθ: (::Real, [rad]) the angle with respect to x-axis\n\nReturns\n\ns: (::Spinnor) the spinnor struct that represents the Rx rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.Rg","page":"API Documentation","title":"KomaMRI.Rg","text":"s = Rg(φ1, θ, φ2)\n\nSpinor rotation matrix: Rg(φ1, θ, φ2) = Rz(φ2) Ry(θ) Rz(φ1)\n\nArguments\n\nφ1: (::Real, [rad]) the φ1 angle\nθ: (::Real, [rad]) the θ angle\nφ2: (::Real, [rad]) the φ2 angle\n\nReturns\n\ns: (::Spinnor) the spinnor struct that represents the Rg rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.Rφ","page":"API Documentation","title":"KomaMRI.Rφ","text":"s = Rφ(φ, θ)\n\nSpinor rotation matrix with angle θ with axis in the xy plane u=(cosφ, sinφ).\n\nRφ(φ,θ) = Rg(-φ,θ,φ) = Rz(φ) Ry(θ) Rz(-φ)\n\nArguments\n\nφ: (::Real, [rad]) the φ angle\nθ: (::Real, [rad]) the θ angle\n\nReturns\n\ns: (::Spinnor) the spinnor struct that represents the Rφ rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.Q","page":"API Documentation","title":"KomaMRI.Q","text":"s = Q(φ, nxy, nz)\n\nSpinor rotation matrix. Rotation of φ with respect to the axis of rotation n=(nx, ny, nz).\n\nPauly, J., Le Roux, P., Nishimura, D., & Macovski, A. (1991). Parameter relations for the Shinnar-Le Roux selective excitation pulse design algorithm (NMR imaging). IEEE Transactions on Medical Imaging, 10(1), 53-65. doi:10.1109/42.75611\n\nvarphi=-gammaDelta tsqrtleftB_1right^2+left(boldsymbolGcdotboldsymbolx\nright)^2=-gammaDelta tleftVert boldsymbolBrightVert\n\nboldsymboln=boldsymbolBleftVert boldsymbolBrightVert\n\nArguments\n\nφ: (::Real, [rad]) the φ angle\nnxy: (::Real) the nxy factor\nnz: (::Real) the nz factor\n\nReturns\n\ns: (::Spinnor) the spinnor struct that represents the Q rotation matrix\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Base.abs-Tuple{Spinor}","page":"API Documentation","title":"Base.abs","text":"y = abs(s::Spinor)\n\nIt calculates |α|^2 + |β|^2 of the Cayley-Klein parameters.\n\nArguments\n\ns: (::Spinnor) the spinnor struct\n\nReturns\n\ny: (::Real) the result of the abs operator\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.show-Tuple{IO, RF}","page":"API Documentation","title":"Base.show","text":"str = show(io::IO, x::RF)\n\nDisplays information about the RF struct x in the julia REPL.\n\nArguments\n\nx: (::RF) the RF struct\n\nReturns\n\nstr: (::String) the output string message\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.getproperty-Tuple{Vector{RF}, Symbol}","page":"API Documentation","title":"Base.getproperty","text":"y = getproperty(x::Vector{RF}, f::Symbol)\ny = getproperty(x::Matrix{RF}, f::Symbol)\n\nOverchages Base.getproperty(). It is meant to access properties of the RF vector x directly without the need to iterate elementwise.\n\nArguments\n\nx: (::Vector{RF} or ::Matrix{RF}) the vector or matrix of RF structs\nf: (::Symbol, opts: [:A, :Bx, :By, :T, :Δf, :delay and :dur]) the input   symbol that represents a property of the vector or matrix of RF structs\n\nReturns\n\ny: (::Vector{Any} or ::Matrix{Any}) the vector with the property defined by the   symbol f for all elements of the RF vector or matrix x\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.dur-Tuple{RF}","page":"API Documentation","title":"KomaMRI.dur","text":"y = dur(x::RF)\ny = dur(x::Array{RF,1})\ny = dur(x::Array{RF,2})\n\nDuration time in [s] of RF struct or RF array.\n\nArguments\n\nx: (::RF or ::Array{RF,1} or ::Array{RF,2}) the RF struct or RF array\n\nReturns\n\ny: (::Float64, [s]) the duration of the RF struct or RF array\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.RF_fun","page":"API Documentation","title":"KomaMRI.RF_fun","text":"rf = RF_fun(f::Function, T::Real, N::Int64)\n\nGenerate an RF sequence with amplitudes sampled from a function waveform.\n\nnote: Note\nThis function is not being used in this KomaMRI version.\n\nArguments\n\nf: (::Function, [T]) the function for the RF amplitud waveform\nT: (::Real, [s]) the duration of the RF pulse\nN: (::Int64) the number of samples of the RF pulse\n\nReturns\n\nrf:(::RF) the RF struct with amplitud defined by the function f\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_flip_angle","page":"API Documentation","title":"KomaMRI.get_flip_angle","text":"α = get_flip_angle(x::RF)\n\nCalculates the flip angle α [deg] of an RF struct. α = γ ∫ B1(τ) dτ\n\nArguments\n\nx: (::RF) the RF struct\n\nReturns\n\nα: (::Int64, [deg]) the flip angle RF struct x\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_RF_center","page":"API Documentation","title":"KomaMRI.get_RF_center","text":"t = get_RF_center(x::RF)\n\nCalculates the time where is the center of the RF pulse x. This calculation includes the RF delay.\n\nArguments\n\nx: (::RF) the RF struct\n\nReturns\n\nt: (::Int64, [s]) the time where is the center of the RF pulse x\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#ADC","page":"API Documentation","title":"ADC","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.ADC — Type","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"getproperty(::Vector{ADC}, ::Symbol)\nKomaMRI.get_sample_times\nKomaMRI.get_sample_phase_compensation","category":"page"},{"location":"docstrings/#Base.getproperty-Tuple{Vector{ADC}, Symbol}","page":"API Documentation","title":"Base.getproperty","text":"y = getproperty(x::Vector{ADC}, f::Symbol)\n\nOverchages Base.getproperty(). It is meant to access properties of the ADC vector x directly without the need to iterate elementwise.\n\nArguments\n\nx: (::Vector{ADC}) the vector of ADC structs\nf: (::Symbol, opts: [:N, :T, :delay, :Δf, :ϕ, :dur]) the input symbol that   represents a property of the ACD structs\n\nReturns\n\ny: (::Vector{Any}) the vector with the property defined by the f for all elements of   the ADC vector x\n\njulia> ADCs = [ADC(16, 8, 2); ADC(8, 4, 6); ADC(4, 2, 8)]\n3-element Vector{ADC}:\n ADC(16, 8.0, 2.0, 0.0, 0.0)\n ADC(8, 4.0, 6.0, 0.0, 0.0)\n ADC(4, 2.0, 8.0, 0.0, 0.0)\n\njulia> getproperty(ADCs, :dur)\n3-element Vector{Float64}:\n 10.0\n 10.0\n 10.0\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#KomaMRI.get_sample_times","page":"API Documentation","title":"KomaMRI.get_sample_times","text":"times = get_sample_times(seq)\n\nReturns an array of times when the samples of the sequence seq are acquired.\n\nArguments\n\nseq: (::Sequence) the sequence struct\n\nReturns\n\ntimes: (::Vector{Float64}, [s]) the time array when samples are acquired\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#KomaMRI.get_sample_phase_compensation","page":"API Documentation","title":"KomaMRI.get_sample_phase_compensation","text":"phase = get_sample_phase_compensation(seq)\n\nReturns the array of phases for every acquired sample in the sequence seq.\n\nnote: Note\nThis function is useful to compensate the phase when the RF pulse has a phase too. Refer to the end of the run_sim_time_iter function to see its usage.\n\nArguments\n\nseq: (::Sequence) the sequence struct\n\nReturns\n\nphase: (::Vector{Complex{Int64}}, [rad]) the array of phases for every acquired   sample\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Delay","page":"API Documentation","title":"Delay","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.Delay — Type","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"show(::IO, ::Delay)\n+(::Sequence, ::Delay)","category":"page"},{"location":"docstrings/#Base.show-Tuple{IO, Delay}","page":"API Documentation","title":"Base.show","text":"str = show(io::IO, s::Delay)\n\nDisplays the delay time in m[s] of the delay struct s in the julia REPL.\n\nArguments\n\ns: (::Delay) the delay struct\n\nReturns\n\nstr: (::String) the output string message\n\nExamples\n\njulia> x = Delay(1)\nDelay(1000.0ms)\n\njulia> x\nDelay(1000.0ms)\n\njulia> show(x)\nDelay(1000.0ms)\n\njulia> display(x)\nDelay(1000.0ms)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.:+-Tuple{Sequence, Delay}","page":"API Documentation","title":"Base.:+","text":"seq = +(s::Sequence, d::Delay)\nseq = +(d::Delay, s::Sequence)\n\nAdd a delay to sequence struct. It ultimately affects to the duration of the gradients of a sequence.\n\nArguments\n\ns: (::Sequence) the sequence struct\nd: (::Delay) the delay struct\n\nReturns\n\nseq: (::Sequence) the delayed sequence\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#pulseq","page":"API Documentation","title":"Pulseq.jl","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.read_seq — Function","category":"page"},{"location":"docstrings/#read_Grad","page":"API Documentation","title":"read_Grad","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.read_Grad","category":"page"},{"location":"docstrings/#KomaMRI.read_Grad","page":"API Documentation","title":"KomaMRI.read_Grad","text":"grad = read_Grad(gradLibrary, shapeLibrary, Δt_gr, i)\n\nReads the gradient. It is used internally by get_block.\n\nArguments\n\ngradLibrary: (::Dict{K, V}) the \"gradLibrary\" dictionary\nshapeLibrary: (::Dict{K, V}) the \"shapeLibrary\" dictionary\nΔt_gr: (::Float64, [s]) the gradient raster time\ni: (::Int64) the index of the axis in the block event\n\nReturns\n\ngrad: (::Grad) the gradient struct\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#read_RF","page":"API Documentation","title":"read_RF","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.read_RF","category":"page"},{"location":"docstrings/#KomaMRI.read_RF","page":"API Documentation","title":"KomaMRI.read_RF","text":"rf = read_RF(rfLibrary, shapeLibrary, Δt_rf, i)\n\nReads the RF. It is used internally by get_block.\n\nArguments\n\nrfLibrary: (::Dict{K, V}) the \"rfLibrary\" dictionary\nshapeLibrary: (::Dict{K, V}) the \"shapeLibrary\" dictionary\nΔt_rf: (::Float64, [s]) the RF raster time\ni: (::Int64) the index of the RF in the block event\n\nReturns\n\nrf: (1x1 ::Matrix{RF}) the RF struct\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#read_ADC","page":"API Documentation","title":"read_ADC","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.read_ADC","category":"page"},{"location":"docstrings/#KomaMRI.read_ADC","page":"API Documentation","title":"KomaMRI.read_ADC","text":"adc = read_ADC(adcLibrary, i)\n\nReads the ADC. It is used internally by get_block.\n\nArguments\n\nadcLibrary: (::Dict{String, Any}) the \"adcLibrary\" dictionary\ni: (::Int64) the index of the adc in the block event\n\nReturns\n\nadc: (1x1 ::Vector{ADC}) the ADC struct\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#get_block","page":"API Documentation","title":"get_block","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.get_block","category":"page"},{"location":"docstrings/#KomaMRI.get_block","page":"API Documentation","title":"KomaMRI.get_block","text":"seq = get_block(obj, i)\n\nBlock sequence definition. Used internally by read_seq.\n\nArguments\n\nobj: (::Dict{String, Any}) the main dictionary\ni: (::Int64) the index of a block event\n\nReturns\n\ns: (::Sequence) the block sequence struct\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#jemris","page":"API Documentation","title":"JEMRIS.jl","text":"","category":"section"},{"location":"docstrings/#read_phantom_jemris","page":"API Documentation","title":"read_phantom_jemris","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.read_phantom_jemris — Function","category":"page"},{"location":"docstrings/#ismrmrd","page":"API Documentation","title":"ISMRMRD.jl","text":"","category":"section"},{"location":"docstrings/#rawSignalToISMRMRD","page":"API Documentation","title":"rawSignalToISMRMRD","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.rawSignalToISMRMRD — Function","category":"page"},{"location":"docstrings/#pulse-designer","page":"API Documentation","title":"PulseDesigner.jl","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.PulseDesigner — Function\nKomaMRI.PulseDesigner.RF_hard — Function\nKomaMRI.PulseDesigner.EPI — Function\nKomaMRI.PulseDesigner.radial_base — Function","category":"page"},{"location":"docstrings/#key-values-calculation","page":"API Documentation","title":"KeyValuesCalculation.jl","text":"","category":"section"},{"location":"docstrings/#get_theo_A","page":"API Documentation","title":"get_theo_A","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.get_theo_A","category":"page"},{"location":"docstrings/#KomaMRI.get_theo_A","page":"API Documentation","title":"KomaMRI.get_theo_A","text":"A = get_theo_A(g::Grad; off_val=0)\nA = get_theo_A(r::RF; off_val=0, max_rf_samples=Inf)\nA = get_theo_A(d::ADC; off_val=0)\n\nGet the theoretical amplitudes of a rectangle waveform for Grad, RF or ADC structs. This are 5 points: delay, start, rise, stop and fall.\n\nnote: Note\nIn some cases the array result can have duplicated points, so it is necessary to remove them whenever necessary.\n\nArguments\n\ng: (::Grad) the gradient struct\nr: (::RF) the RF struct\nd: (::ADC) the ADC truct\n\nKeywords\n\noff_val: (::Float64, =0) the offset value for amplitude. In general, it is used for   not showing some points in plots by giving an Inf value\nmax_rf_samples: (::Float64, =Inf) the number of maximum samples for the RF struct.   In general, this parameter is not necessary to set\n\nReturns\n\nA: (::Vector{Float64}) the vector with the amplitude key points of the rectangle   waveform\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#get_theo_t","page":"API Documentation","title":"get_theo_t","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.get_theo_t","category":"page"},{"location":"docstrings/#KomaMRI.get_theo_t","page":"API Documentation","title":"KomaMRI.get_theo_t","text":"t = get_theo_t(g::Grad)\nt = get_theo_t(r::RF; max_rf_samples=Inf)\nt = get_theo_t(d::ADC)\n\nGet the theoretical times of a rectangle waveform for Grad, RF or ADC structs. This are 5 points: delay, start, rise, stop and fall.\n\nnote: Note\nIn some cases the array result can have duplicated points, so it is necessary to remove them whenever necessary.\n\nArguments\n\ng: (::Grad) the gradient struct\nr: (::RF) the RF struct\nd: (::ADC) the ADC truct\n\nKeywords\n\nmax_rf_samples: (::Float64, =Inf) the number of maximum samples for the RF struct.   In general, this parameter is not necessary to set\n\nReturns\n\nt: (::Vector{Float64}) the vector with the time key points of the rectangle waveform\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#get_theo_Gi","page":"API Documentation","title":"get_theo_Gi","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.get_theo_Gi","category":"page"},{"location":"docstrings/#KomaMRI.get_theo_Gi","page":"API Documentation","title":"KomaMRI.get_theo_Gi","text":"t, g = get_theo_Gi(seq, idx)\n\nGet the theoretical gradient for a sequence in a defined axis.\n\nArguments\n\nseq: (::Sequence) the sequence struct\nidx: (::Int64, opts=[1, 2, 3]) the axis x, y or z for the gradient\n\nReturns\n\nt: (::Vector{Float64}) the time key points\ng: (::Vector{Float64}) the amplitude key points\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#trapezoidal-integration","page":"API Documentation","title":"TrapezoidalIntegration.jl","text":"","category":"section"},{"location":"docstrings/#trapz","page":"API Documentation","title":"trapz","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.trapz","category":"page"},{"location":"docstrings/#KomaMRI.trapz","page":"API Documentation","title":"KomaMRI.trapz","text":"y = trapz(Δt, x)\n\nTrapezoidal integration for every spin of a phantom.\n\nnote: Note\nIn practice, this function is used to integrate (Gx * x + Gy * y + Gz * z) * Δt for all the spins. NΔt is the length of Δt. Ns stands for the number of spins of a phantom. x is a matrix which rows represents different spins and columns are different times and the elements are the field Gx * x + Gy * y + Gz * z values.\n\nArguments\n\nΔt: (1 x NΔt ::Matrix{Float64}, [s]) the delta time 1-row array\nx: (Ns x (NΔt+1) ::Matrix{Float64}, [T]) the magnitude of field Gx * x + Gy * y +   Gz * z\n\nReturns\n\ny: (Ns x 1 ::Matrix{Float64}, [T*s]) the vector where every element is the integral   of (Gx * x + Gy * y + Gz * z) * Δt for every spin of a phantom\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#cumtrapz","page":"API Documentation","title":"cumtrapz","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.cumtrapz","category":"page"},{"location":"docstrings/#KomaMRI.cumtrapz","page":"API Documentation","title":"KomaMRI.cumtrapz","text":"y = cumtrapz(Δt, x)\n\nTrapezoidal cumulative integration over time for every spin of a phantom.\n\nnote: Note\nIn practice, this function is used to get the cumulative integration of (Gx * x + Gy * y + Gz * z) * Δt for all the spins. NΔt is the length of Δt. Ns stands for the number of spins of a phantom. x is a matrix which rows represents different spins and columns are different times and the elements are the field Gx * x + Gy * y + Gz * z values. Note that the last column of the result of this function cumtrapz is equal to the result of the function trapz\n\nArguments\n\nΔt: (1 x NΔt ::Matrix{Float64}, [s]) the delta time 1-row array\nx: (Ns x (NΔt+1) ::Matrix{Float64}, [T]) the magnitude of field Gx * x + Gy * y +   Gz * z\n\nReturns\n\ny: (Ns x NΔt ::Matrix{Float64}, [T*s]) the matrix where every column is the   cumulative integration over time of (Gx * x + Gy * y + Gz * z) * Δt for every spin of a   phantom\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#time-step-calculation","page":"API Documentation","title":"TimeStepCalculation.jl","text":"","category":"section"},{"location":"docstrings/#points_from_key_times","page":"API Documentation","title":"points_from_key_times","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.points_from_key_times","category":"page"},{"location":"docstrings/#KomaMRI.points_from_key_times","page":"API Documentation","title":"KomaMRI.points_from_key_times","text":"t = points_from_key_times(times; dt)\n\nReturns a vector which contains the same points as times but with additional points that have a separation of at most dt.\n\nnote: Note\nThe last time points could not be present in the output in some cases. Some time points could be duplicated in the output. Duplicated time points should be removed afterwards (done by     get_variable_times). The output represents all time points regarded during the simulation with a \"nominal\" dt separation between two samples.\n\nArguments\n\ntimes: (::Vector{Float64}, [s]) the time array with key points you want to keep\n\nKeywords\n\ndt: (::Float64, [s]) the maximum delta time separation between two time samples\n\nReturns\n\nt: (::Vector{Float64}, [s]) the time array with the same points as the input array but with   additional points that have a separation of at most dt.\n\nExamples\n\njulia> times = [0 1 2 10 11 12 20]\n1×7 Matrix{Int64}:\n 0  1  2  10  11  12  20\n\njulia> points_from_key_times(times; dt=0.5)'\n1×46 adjoint(::Vector{Float64}) with eltype Float64:\n 0.0  0.5  1.0  1.0  1.5  2.0  2.0  2.5  3.0  3.5  4.0  4.5  …  16.0  16.5  17.0  17.5\n   18.0  18.5  19.0  19.5  20.0\n\njulia> points_from_key_times(times; dt=0.7)'\n1×32 adjoint(::Vector{Float64}) with eltype Float64:\n 0.0  0.7  1.0  1.7  2.0  2.7  3.4  4.1  4.8  5.5  6.2  6.9  …  14.1  14.8  15.5  16.2\n   16.9  17.6  18.3  19.0  19.7\n\njulia> points_from_key_times(times; dt=2.5)'\n1×16 adjoint(::Vector{Float64}) with eltype Float64:\n 0.0  1.0  1.0  2.0  2.0  4.5  7.0  9.5  10.0  11.0  11.0  12.0  12.0  14.5  17.0  19.5\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#get_variable_times","page":"API Documentation","title":"get_variable_times","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.get_variable_times","category":"page"},{"location":"docstrings/#KomaMRI.get_variable_times","page":"API Documentation","title":"KomaMRI.get_variable_times","text":"t, Δt = get_variable_times(seq; dt=1, dt_rf=1e-4)\n\nThis function returns non-uniform time points that are relevant in the sequence seq.\n\nnote: Note\nIt is important to use a variable time step (instead of constant sampling time) to increase the simulation speed.\n\nArguments\n\nseq: (::Sequence) the sequence struct\ndt: (::Real, =1, [s]) the nominal delta time separation between two time samples   for ADC acquisition and Gradients (by nominal we mean that the time separation should be   at most Δt when the samples are regarded by KomaMRI.is_ADC_on or   KomaMRI.is_GR_on), otherwise the time points are not necessary and the   separation will be bigger)\n\nKeywords\n\nΔt_rf: (::Real, =1e-4, [s]) the nominal delta time separation between two time   samples for RF excitation (by nominal we mean that the time separation should be at most   Δt_rf when the samples are regarded by KomaMRI.is_RF_on, otherwise the time   points are not necessary and the separation will be bigger)\n\nReturns\n\nt: (::Vector{Float64}, [s]) the time array with non-uniform time values\nΔt: (::Vector{Float64}, [s]) the delta time array with the separation between two   adjacent time points of the t time array\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#get_uniform_times","page":"API Documentation","title":"get_uniform_times","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.get_uniform_times","category":"page"},{"location":"docstrings/#KomaMRI.get_uniform_times","page":"API Documentation","title":"KomaMRI.get_uniform_times","text":"t, Δt = get_uniform_times(seq, Δt; Δt_rf=1e-4)\n\nThis function, despite its name, actually gets non-uniform time points. Refer to get_variable_times for more details.\n\nnote: Note\nThis function should be deprecated and the simulator should only use the get_variable_times function. Note that in this KomaMRI version, this function is bypassed by get_variable_times.\n\nArguments\n\nseq: (::Sequence) the sequence struct\nΔt: (::Real, [s]) the nominal delta time separation between two time samples for ADC   acquisition and Gradients (by nominal we mean that the time separation should be at   most Δt when the samples are regarded by KomaMRI.is_ADC_on or   KomaMRI.is_GR_on), otherwise the time points are not necessary and the   separation will be bigger)\n\nKeywords\n\nΔt_rf: (::Real, =1e-4, [s]) the nominal delta time separation between two time   samples for RF excitation (by nominal we mean that the time separation should be at most   Δt_rf when the samples are regarded by KomaMRI.is_RF_on, otherwise the time   points are not necessary and the separation will be bigger)\n\nReturns\n\nt: (::Vector{Float64}, [s]) the time array with non-uniform time values\nΔt: (::Vector{Float64}, [s]) the delta time array with the separation between two   adjacent time points of the t time array\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#kfoldperm","page":"API Documentation","title":"kfoldperm","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.kfoldperm","category":"page"},{"location":"docstrings/#KomaMRI.kfoldperm","page":"API Documentation","title":"KomaMRI.kfoldperm","text":"array_of_ranges = kfoldperm(N, k; type=\"random\", breaks=[])\n\nDivides a list of indices 1:N (which is in your imagination) into k groups.\n\nnote: Note\nIt is possible to predifine some break points at specific indices with the breaks keyword, in this case the number of groups could increase. This is useful to define start and end indices of RF pulses to separate the simulation into excitation and preccesion computations.\n\nArguments\n\nN: (::Int64) the number of elements to be ordered (of an imaginary array 1:N)\nk: (::Int64) the number of groups to divide the N elements\n\nKeywords\n\ntype: (::String, =\"random\", opts: [\"random\", \"ordered\"]) the order type option.   If random, then the indices of the groups are unordered. If \"ordered\", then the indices   of the groups are sorted in an incremental order\nbreaks: (::Vector{Int64}, =[]) the array of indices where predefined break points   are placed\n\nReturns\n\narray_of_ranges: (::Vector{UnitRange{Int64}}) the array that contains ranges of   different groups (the aim target are k groups, but this could be increased by adding   elements in the breaks input array)\n\nExamples\n\njulia> kfoldperm(20, 3; type=\"ordered\")\n3-element Vector{UnitRange{Int64}}:\n 1:7\n 8:14\n 15:20\n\njulia> kfoldperm(20, 3; type=\"ordered\", breaks=[3])\n4-element Vector{UnitRange{Int64}}:\n 1:2\n 3:7\n 8:14\n 15:20\n\njulia> kfoldperm(20, 3; type=\"ordered\", breaks=[3, 10])\n5-element Vector{UnitRange{Int64}}:\n 1:2\n 3:7\n 8:9\n 10:14\n 15:20\n\njulia> kfoldperm(20, 3; type=\"ordered\", breaks=[3, 10, 17])\n6-element Vector{UnitRange{Int64}}:\n 1:2\n 3:7\n 8:9\n 10:14\n 15:16\n 17:20\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#get_breaks_in_RF_key_points","page":"API Documentation","title":"get_breaks_in_RF_key_points","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.get_breaks_in_RF_key_points","category":"page"},{"location":"docstrings/#KomaMRI.get_breaks_in_RF_key_points","page":"API Documentation","title":"KomaMRI.get_breaks_in_RF_key_points","text":"key_idxs = get_breaks_in_RF_key_points(seq::Sequence, t)\n\nReturn the indices of the t time array where are RF key points from the seq sequence. Thus, it is possible to split the simulation into excitation and preccesion computations.\n\nnote: Note\nBy RF key points we mean all the start and end points where the RF excitation takes place with the KomaMRI.is_RF_on function.\n\nArguments\n\nseq: (::Sequence) the sequence struct\nt: (::Vector{Int64}, [s]) the non-uniform time array\n\nReturns\n\nkey_idxs: (::Vector{Int64}) array of indices of the t time array where are RF key   points\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#simulation-core","page":"API Documentation","title":"SimulationCore.jl","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.simulate — Function\nKomaMRI.simulate_slice_profile — Function","category":"page"},{"location":"docstrings/#print_gpus","page":"API Documentation","title":"print_gpus","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.print_gpus","category":"page"},{"location":"docstrings/#KomaMRI.print_gpus","page":"API Documentation","title":"KomaMRI.print_gpus","text":"print_gpus()\n\nSimple function to print the gpus CUDA devices available in the host.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#run_spin_precession","page":"API Documentation","title":"run_spin_precession","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.run_spin_precession","category":"page"},{"location":"docstrings/#KomaMRI.run_spin_precession","page":"API Documentation","title":"KomaMRI.run_spin_precession","text":"S, M0 = run_spin_precession(obj, seq, t, Δt; M0, gpu)\n\nSimulates an MRI sequence seq on the Phantom obj for time points t. It calculates S(t) = ∫ ρ(x,t) exp(- t/T2(x,t) ) exp(- 𝒊 ϕ(x,t)) dx. It performs the simulation in free precession.\n\nnote: Note\nThis function is used to simulate a part of the simulation over time given by the variable Nblocks (which is outside of this function, refer to run_sim_time_iter) to reduce the RAM memory utilization. It is also used to simulate a part of the spins in a phantom defined by the variable Nthreads (which is outside of this function too, refer to run_spin_precession_parallel) to take advantage of CPU parallel processing.\n\nArguments\n\nobj: (::Phantom) the phantom struct (actually, it's a part of the complete phantom)\nseq: (::Sequence) the sequence struct\nt: (1-row ::Matrix{Float64}, [s]) the non-uniform time vector (actually it's a part   of the complete simulation time vector)\nΔt: (1-row ::Matrix{Float64}, [s]) the delta time of t (actually it's a part of   the complete simulation time vector)\n\nKeywords\n\nM0: (::Vector{Mag}) the initial state of the Mag vector (actually, it's a part of the   complete Mag vector)\ngpu: (::Function) the function that represents the gpu of the host\n\nReturns\n\nS: (Vector{ComplexF64}) the raw signal over time\nM0: (::Vector{Mag}) the final state of the Mag vector (actually, it's a part of the   complete Mag vector) (it's not the initial state for the next simulation, since it's   necessary to add the magnetization of all the parts of the phantom (i.e. sum up all the   spin magnetizations first), refer to run_spin_precession_parallel)\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#run_spin_precession_parallel","page":"API Documentation","title":"run_spin_precession_parallel","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.run_spin_precession_parallel","category":"page"},{"location":"docstrings/#KomaMRI.run_spin_precession_parallel","page":"API Documentation","title":"KomaMRI.run_spin_precession_parallel","text":"S, M0 = run_spin_precession_parallel(obj, seq, t, Δt; M0, Nthreads, gpu)\n\nImplementation in multiple threads for the simulation in free precession, separating the spins of the phantom obj in Nthreads.\n\nnote: Note\nThis function does not use the complete time vector of the total simulation, it uses instead a piece of the time vector given by a variable called Nblocks (which is outside of this function, refer to run_sim_time_iter) to reduce the RAM memory utilization.\n\nArguments\n\nobj: (::Phantom) the phantom struct\nseq: (::Sequence) the sequence struct\nt: (::Vector{Float64}, [s]) the non-uniform time vector (actually it's a part of the   complete simulation time vector)\nΔt: (::Vector{Float64}, [s]) the delta time of t (actually it's a part of the   complete simulation time vector)\n\nKeywords\n\nM0: (::Vector{Mag}) the initial state of the Mag vector\nNthreads: (::Int, =Hwloc.num_physical_cores()) the number of process threads for   dividing the simulation into different phantom spin parts\ngpu: (::Function) the function that represents the gpu of the host\n\nReturns\n\nS: (Vector{ComplexF64}) the raw signal over time\nM0: (::Vector{Mag}) the final state of the Mag vector (or the initial state for the   next simulation step (the next step can be another precession step or an excitation   step))\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#run_spin_excitation","page":"API Documentation","title":"run_spin_excitation","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.run_spin_excitation","category":"page"},{"location":"docstrings/#KomaMRI.run_spin_excitation","page":"API Documentation","title":"KomaMRI.run_spin_excitation","text":"M0 = run_spin_excitation(obj, seq, t, Δt; M0, gpu)\n\nIt gives rise to a rotation of M0 with an angle given by the efective magnetic field (including B1, gradients and off resonance) and with respect to a rotation axis.\n\nnote: Note\nThis function is used to simulate a part of the simulation over time given by the variable Nblocks (which is outside of this function, refer to run_sim_time_iter) to reduce the RAM memory utilization. It is also used to simulate a part of the spins in a phantom defined by the variable Nthreads (which is outside of this function too, refer to run_spin_excitation_parallel) to take advantage of CPU parallel processing.\n\nArguments\n\nobj: (::Phantom) the phantom struct (actually, it's a part of the complete phantom)\nseq: (::Sequence) the sequence struct\nt: (1-row ::Matrix{Float64}, [s]) the non-uniform time vector (actually it's a part   of the complete simulation time vector)\nΔt: (1-row ::Matrix{Float64}, [s]) the delta time of t (actually it's a part of   the complete simulation time vector)\n\nKeywords\n\nM0: (::Vector{Mag}) the initial state of the Mag vector (actually, it's a part of the   complete Mag vector)\ngpu: (::Function) the function that represents the gpu of the host\n\nReturns\n\nM0: (::Vector{Mag}) the final state of the Mag vector after a rotation (actually, it's   a part of the complete Mag vector and it's a part of the initial state for the next   precession simulation step)\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#run_spin_excitation_parallel","page":"API Documentation","title":"run_spin_excitation_parallel","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.run_spin_excitation_parallel","category":"page"},{"location":"docstrings/#KomaMRI.run_spin_excitation_parallel","page":"API Documentation","title":"KomaMRI.run_spin_excitation_parallel","text":"M0 = run_spin_excitation_parallel(obj, seq, t, Δt; M0, Nthreads, gpu)\n\nIt gives rise to a rotation of M0 with an angle given by the efective magnetic field (including B1, gradients and off resonance) and with respect to a rotation axis. It uses different number threads to excecute the process.\n\nnote: Note\nThis function does not use the complete time vector of the total simulation, it uses instead a piece of the time vector given by a variable called Nblocks (which is outside of this function, refer to run_sim_time_iter) to reduce the RAM memory utilization.\n\nArguments\n\nobj: (::Phantom) the phantom struct\nseq: (::Sequence) the sequence struct\nt: (::Vector{Float64}, [s]) the non-uniform time vector (actually it's a part of the   complete simulation time vector)\nΔt: (::Vector{Float64}, [s]) the delta time of t (actually it's a part of the   complete simulation time vector)\n\nKeywords\n\nM0: (::Vector{Mag}) the initial state of the Mag vector\nNthreads: (::Int, =Hwloc.num_physical_cores()) the number of process threads for   dividing the simulation into different phantom spin parts\ngpu: (::Function) the function that represents the gpu of the host\n\nReturns\n\nM0: (::Vector{Mag}) the final state of the Mag vector after a rotation (or the initial   state for the next precession simulation step)\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#run_sim_time_iter","page":"API Documentation","title":"run_sim_time_iter","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.run_sim_time_iter","category":"page"},{"location":"docstrings/#KomaMRI.run_sim_time_iter","page":"API Documentation","title":"KomaMRI.run_sim_time_iter","text":"S_interp, M0 = run_sim_time_iter(obj, seq, t, Δt; Nblocks, Nthreads, gpu, w)\n\nPerforms the simulation over the total time vector t by dividing the time into Nblocks parts to reduce RAM usage and spliting the spins of the phantom obj into Nthreads to take advantage of CPU parallel processing.\n\nArguments\n\nobj: (::Phantom) the phantom struct\nseq: (::Sequence) the sequence struct\nt: (::Vector{Float64}, [s]) the non-uniform time vector\nΔt: (::Vector{Float64}, [s]) the delta time of t\n\nKeywords\n\nNblocks: (::Int, =16) the number of groups for spliting the simulation over time\nNthreads: (::Int, =Hwloc.num_physical_cores()) the number of process threads for   dividing the simulation into different phantom spin parts\ngpu: (::Function) the function that represents the gpu of the host\nw: (::Any, =nothing) the flag to regard a progress bar in the blink window UI. If   this variable is differnet from nothing, then the progress bar is considered\n\nReturns\n\nS_interp: (::Vector{ComplexF64}) the interpolated raw signal\nM0: (::Vector{Mag}) the final state of the Mag vector\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#display-functions","page":"API Documentation","title":"DisplayFunctions.jl","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"Refer to API Documentation:","category":"page"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.plot_seq — Function\nKomaMRI.plot_image — Function\nplot_kspace — Function\nplot_M0 — Function\nplot_phantom_map — Function\nplot_signal — Function","category":"page"},{"location":"docstrings/#theme_chooser","page":"API Documentation","title":"theme_chooser","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.theme_chooser","category":"page"},{"location":"docstrings/#KomaMRI.theme_chooser","page":"API Documentation","title":"KomaMRI.theme_chooser","text":"bgcolor, text_color, plot_bgcolor, grid_color, sep_color = theme_chooser(darkmode)\n\nDefine colors for dark or light mode.\n\nArguments\n\ndarkmode: (::Bool) the boolean that selects dark or light mode\n\nReturns\n\nbgcolor: (::String) the backgound color\ntext_color: (::String) the text color\nplot_bgcolor: (::String) the color background for the plots\ngrid_color: (::String) the color of the grids\nsep_color: (::String) the color of separator lines\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#interp_map","page":"API Documentation","title":"interp_map","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.interp_map","category":"page"},{"location":"docstrings/#KomaMRI.interp_map","page":"API Documentation","title":"KomaMRI.interp_map","text":"c_map_interp = interp_map(c_map, t_interp)\n\nInterpolates a color map. This is used for plotting the kspace (refer to plot_kspace).\n\nArguments\n\nc_map: (::Vector{Vector{Any}}) the color map. Every element of this vector has a   vector with a number between 0-1 in its first element and a color string in its second   element. It serves as a reference to create a color map with more elements\nt_interp: (::Vector{Float64}) the vector with values between 0-1 that are the   reference for interpolate the color map with more elements\n\nReturns\n\nc_map_interp: (::Vector{String}) the vector with color strings with interpolated   values\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#plot_dict","page":"API Documentation","title":"plot_dict","text":"","category":"section"},{"location":"docstrings/","page":"API Documentation","title":"API Documentation","text":"KomaMRI.plot_dict","category":"page"},{"location":"docstrings/#KomaMRI.plot_dict","page":"API Documentation","title":"KomaMRI.plot_dict","text":"str = plot_dict(dict::Dict)\n\nGenerates a string in html format of the dictionary dict.\n\nArguments\n\ndict: (::Dict) the dictionary to generate tha html string\n\nReturns\n\nstr: (::String) the string of the dictionary dict which is a table in html format\n\n\n\n\n\n","category":"function"}]
}
