<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ways of using Koma ¬∑ KomaMRI.jl: General MRI simulation framework</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/extra-styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="KomaMRI.jl: General MRI simulation framework logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="KomaMRI.jl: General MRI simulation framework logo"/></a><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><span class="tocitem">Ways of Using KomaMRI</span><ul><li><a class="tocitem" href="../ui-details/">User Interface</a></li><li><a class="tocitem" href="../programming-workflow/">Julia Scripts</a></li><li><a class="tocitem" href="../notebooks/">Notebooks</a></li></ul></li><li><a class="tocitem" href="../create-your-own-phantom/">Create Your Own Phantom</a></li><li><span class="tocitem">Create Your Own Sequence</span><ul><li><a class="tocitem" href="../sequence/">Sequence</a></li><li><a class="tocitem" href="../events/">Sequence Events</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/examples/01-FID/">Free Induction Decay</a></li><li><a class="tocitem" href="../generated/examples/02-SmallTipApproximation/">Small Tip Angle Approximation</a></li><li><a class="tocitem" href="../generated/examples/03-ChemicalShiftEPI/">Chemical Shift in an EPI sequence</a></li><li><a class="tocitem" href="../generated/examples/04-3DSliceSelective/">Slice Selective Acquisition of 3D Phantom</a></li></ul></li><li><a class="tocitem" href="../educational-1d-simulation/">Educational Material üìö</a></li><li><a class="tocitem" href="../mri-theory/">Simulation</a></li><li><a class="tocitem" href="../api/">API Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Ways of using Koma</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ways of using Koma</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaHealth/KomaMRI.jl/blob/master/docs/src/ways-of-using-koma.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Ways-of-using-Koma"><a class="docs-heading-anchor" href="#Ways-of-using-Koma">Ways of using Koma</a><a id="Ways-of-using-Koma-1"></a><a class="docs-heading-anchor-permalink" href="#Ways-of-using-Koma" title="Permalink"></a></h1><p><strong>KomaMRI</strong> can be used in different environments, depending on the degree of flexibility you desire. If you lack prior programming knowledge, we recommend starting with the <a href="#User-Interface">User Interface</a>. If you seek the full range of flexibility that <strong>KomaMRI</strong> offers, programming with <a href="#Scripts">Scripts</a> is likely your preference. Alternatively, you can utilize the programming environment provided by <a href="#Notebooks">Notebooks</a>. Detailed explanations for each method of using <strong>KomaMRI</strong> will be provided in the following sections.</p><h2 id="User-Interface"><a class="docs-heading-anchor" href="#User-Interface">User Interface</a><a id="User-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#User-Interface" title="Permalink"></a></h2><p>This section explains how to use the user interface of the <strong>KomaMRI</strong> package and the internal processes during interaction.</p><h3 id="Basic-Workflow"><a class="docs-heading-anchor" href="#Basic-Workflow">Basic Workflow</a><a id="Basic-Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Workflow" title="Permalink"></a></h3><p>(You can also go to <a href="../programming-workflow/#Basic-Workflow">analog steps using Scripts</a>)</p><p>As a general overview, remember the following workflow steps when using KomaMRI:</p><ul><li>Loading Simulation Inputs: <strong>Scanner</strong>, <strong>Phantom</strong>, <strong>Sequence</strong></li><li>Running Simulation</li><li>Reconstructing Image using <strong>MRIReco</strong></li></ul><p>In the following subsections, we will cover all the mentioned steps. First, open the <strong>Julia REPL</strong> and enter the following commands to include the <strong>KomaMRI</strong> package and launch the user interface:</p><pre><code class="language-julia-repl hljs">julia&gt; using KomaMRI

julia&gt; KomaUI()</code></pre><p align="center"><img width="90%" src="../assets/gui-dashboard.png"/></p><h3 id="Loading-Simulation-Inputs"><a class="docs-heading-anchor" href="#Loading-Simulation-Inputs">Loading Simulation Inputs</a><a id="Loading-Simulation-Inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-Simulation-Inputs" title="Permalink"></a></h3><p>(You can also go to <a href="../programming-workflow/#Loading-Simulation-Inputs">analog steps using Scripts</a>)</p><p>The user interface has preloaded certain inputs into RAM, including the <strong>Scanner</strong>, <strong>Phantom</strong>, and <strong>Sequence</strong> structs. In the following subsections, we will demonstrate how to visualize these inputs.</p><h4 id="Scanner"><a class="docs-heading-anchor" href="#Scanner">Scanner</a><a id="Scanner-1"></a><a class="docs-heading-anchor-permalink" href="#Scanner" title="Permalink"></a></h4><p>You can visualize the preloaded <strong>Scanner</strong> struct by clicking on the <code>Scanner</code> dropdown and then pressing the <code>View Scanner</code> button. The <strong>Scanner</strong> struct contains hardware-related information, such as the main magnetic field&#39;s magnitude:</p><p align="center"><img width="90%" src="../assets/gui-scanner-view.png"/></p><h4 id="Phantom"><a class="docs-heading-anchor" href="#Phantom">Phantom</a><a id="Phantom-1"></a><a class="docs-heading-anchor-permalink" href="#Phantom" title="Permalink"></a></h4><p>To see the phantom already stored in RAM, simply click on the <code>Phantom</code> dropdown an then press the <code>View Phantom</code> button. The preloaded phantom is a slice of a brain:</p><p align="center"><img width="90%" src="../assets/gui-phantom-view.png"/></p><p>It is also possible to load <code>.h5</code> phantom files. The <strong>KomaMRI.jl</strong> has some examples stored at <code>~/.julia/packages/KomaMRI/&lt;id-string&gt;/examples/2.phantoms/</code>. For instance, let&#39;s load the <code>sphere_chemical_shift.h5</code> file:</p><p align="center"><img width="90%" src="../assets/gui-phantom-load.png"/></p><p>Note that you can select different spin parameters to visualize like <code>œÅ</code>, <code>T1</code>, <code>T2</code>, among others. </p><h4 id="Sequence"><a class="docs-heading-anchor" href="#Sequence">Sequence</a><a id="Sequence-1"></a><a class="docs-heading-anchor-permalink" href="#Sequence" title="Permalink"></a></h4><p>There are two options to visualize the sequence already preloaded in RAM: in the time domain or in the k-space. The preloaded sequence is a single-shot EPI.</p><p>For visualization of the sequence in the time domain, click on the <code>Sequence</code> dropdown and then press the <code>Sequence (MPS)</code> button:</p><p align="center"><img width="90%" src="../assets/gui-seq-time-view.png"/></p><p>For visualization of the sequence in the k-space, click on the <code>Sequence</code> dropdown and then press the <code>k-space</code> button:</p><p align="center"><img width="90%" src="../assets/gui-seq-kspace-view.png"/></p><p>You can also display the <code>Moments</code> related to the <strong>Sequence</strong> by pressing the <code>View Moments</code> and then pressing the buttons for zero, first and second moments.</p><p>It is also possible to load <strong>Pulseq</strong> compatible <code>.seq</code> sequence files. The <strong>KomaMRI</strong> has some examples stored at <code>~/.julia/packages/KomaMRI/&lt;id-string&gt;/examples/1.sequences/</code>. For instance, let&#39;s load the <code>spiral.seq</code> file and view it the time domain and k-space:</p><p align="center"><img width="90%" src="../assets/gui-seq-time-load.png"/></p><p align="center"><img width="90%" src="../assets/gui-seq-kspace-load.png"/></p><h3 id="Running-Simulation"><a class="docs-heading-anchor" href="#Running-Simulation">Running Simulation</a><a id="Running-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Running-Simulation" title="Permalink"></a></h3><p>(You can also go to <a href="../programming-workflow/#Running-Simulation">analog steps using Scripts</a>)</p><p>Once the inputs are loaded in RAM, it is possible to perform the simulation to get the <strong>Raw Signal</strong>.</p><h4 id="Simulation-Parameters"><a class="docs-heading-anchor" href="#Simulation-Parameters">Simulation Parameters</a><a id="Simulation-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Parameters" title="Permalink"></a></h4><p>To visualize the default simulation parameters, click on the <code>Simulate!</code> dropdown and then press the <code>View Options</code> button:</p><p align="center"><img width="90%" src="../assets/gui-sim-params-view.png"/></p><h4 id="Visualization-of-the-Raw-Signal"><a class="docs-heading-anchor" href="#Visualization-of-the-Raw-Signal">Visualization of the Raw Signal</a><a id="Visualization-of-the-Raw-Signal-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-of-the-Raw-Signal" title="Permalink"></a></h4><p>Press the <code>Simulate!</code> button to perform the simulation (this may take a while). Automatically the generated <strong>Raw Signal</strong> should be displayed or you can click on the <code>Raw Data</code> dropdown and then press the <code>View Raw Data</code> button:</p><p align="center"><img width="90%" src="../assets/gui-rawsignal-view.png"/></p><h3 id="Reconstructing-Image-using-MRIReco"><a class="docs-heading-anchor" href="#Reconstructing-Image-using-MRIReco">Reconstructing Image using MRIReco</a><a id="Reconstructing-Image-using-MRIReco-1"></a><a class="docs-heading-anchor-permalink" href="#Reconstructing-Image-using-MRIReco" title="Permalink"></a></h3><p>(You can also go to <a href="../programming-workflow/#Reconstructing-Image-using-MRIReco">analog steps using Scripts</a>)</p><p>Once the <strong>Raw Signal</strong> is loaded in RAM, it is possible to reconstruct the image.</p><h4 id="Reconstruction-Parameters"><a class="docs-heading-anchor" href="#Reconstruction-Parameters">Reconstruction Parameters</a><a id="Reconstruction-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Reconstruction-Parameters" title="Permalink"></a></h4><p>To visualize the default reconstruction parameters, click on the <code>Reconstruct!</code> dropdown and then press the <code>View Options</code> button:</p><p align="center"><img width="90%" src="../assets/gui-recon-params-view.png"/></p><h4 id="Visualization-of-the-Image"><a class="docs-heading-anchor" href="#Visualization-of-the-Image">Visualization of the Image</a><a id="Visualization-of-the-Image-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-of-the-Image" title="Permalink"></a></h4><p>Press the <code>Reconstruct!</code> button to perform the reconstruction (this may take a while).  Automatically the generated <strong>Image</strong> should be displayed or you can click on the he <code>Reconstruct!</code> dropdown and then press the <code>|Image|</code> button:</p><p align="center"><img width="90%" src="../assets/gui-image-view.png"/></p><h3 id="Exporting-Results-to-.mat-File"><a class="docs-heading-anchor" href="#Exporting-Results-to-.mat-File">Exporting Results to .mat File</a><a id="Exporting-Results-to-.mat-File-1"></a><a class="docs-heading-anchor-permalink" href="#Exporting-Results-to-.mat-File" title="Permalink"></a></h3><p>(You can also go to <a href="../programming-workflow/#Exporting-Results-to-.mat-File">analog steps using Scripts</a>)</p><p>The user interface has the option to save the results in <code>.mat</code> format. Simply click on the <code>Export to .mat</code> and you have the alternatives to get data independently or you can press the <code>All</code> button to have all the results given by the simulator:</p><p align="center"><img width="90%" src="../assets/gui-export-to-mat.png"/></p><p>So far, and due to limitations of the user interface dependencies, the <code>.mat</code> files are saved in the temporal directory of your computer OS, which can be found by typing the <code>tempdir()</code> command in the <strong>Julia REPL</strong>.</p><h2 id="Julia-Scripts"><a class="docs-heading-anchor" href="#Julia-Scripts">Julia Scripts</a><a id="Julia-Scripts-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Scripts" title="Permalink"></a></h2><p>You should already be familiar with the  <a href="../ui-details/">Graphical User Interface</a> of <strong>KomaMRI</strong>. However, you can also use this package directly from the <strong>Julia REPL</strong> or write your own Julia scripts. This allows you to unlock the full potential of KomaMRI, enabling you to utilize more of its functionalities and even test your own MRI ideas.</p><p>This section demonstrates a basic workflow with <strong>KomaMRI</strong> through writing your own scripts or entering commands directly into the <strong>Julia REPL</strong>. Let&#39;s begin.</p><h3 id="Basic-Workflow-2"><a class="docs-heading-anchor" href="#Basic-Workflow-2">Basic Workflow</a><a class="docs-heading-anchor-permalink" href="#Basic-Workflow-2" title="Permalink"></a></h3><p>(You can also go to <a href="../ui-details/#Basic-Workflow">analog steps using UI</a>)</p><p>As a general overview, remember the following workflow steps when using KomaMRI:</p><ul><li>Loading Simulation Inputs: <strong>Scanner</strong>, <strong>Phantom</strong>, <strong>Sequence</strong></li><li>Running Simulation</li><li>Reconstructing Image using <strong>MRIReco</strong></li></ul><p>Let&#39;s replicate these previous steps in a <strong>Julia</strong> script. You will obtain the following code, which you can copy and paste into the <strong>Julia REPL</strong>:</p><pre><code class="language-julia hljs"># Import the package
using KomaMRI

# Define scanner, object and sequence
sys = Scanner()
obj = brain_phantom2D()
seq = PulseDesigner.EPI_example()

# Define simulation parameters and perform simulation
sim_params = KomaMRICore.default_sim_params() 
raw = simulate(obj, seq, sys; sim_params)

# Auxiliary function for reconstruction
function reconstruct_2d_image(raw::RawAcquisitionData)
    acqData = AcquisitionData(raw)
    acqData.traj[1].circular = false #Removing circular window
    C = maximum(2*abs.(acqData.traj[1].nodes[:]))  #Normalize k-space to -.5 to .5 for NUFFT
    acqData.traj[1].nodes = acqData.traj[1].nodes[1:2,:] ./ C
    Nx, Ny = raw.params[&quot;reconSize&quot;][1:2]
    recParams = Dict{Symbol,Any}()
    recParams[:reconSize] = (Nx, Ny)
    recParams[:densityWeighting] = true
    rec = reconstruction(acqData, recParams)
    image3d  = reshape(rec.data, Nx, Ny, :)
    image2d = (abs.(image3d) * prod(size(image3d)[1:2]))[:,:,1]
    return image2d
end

# Perform reconstruction to get the image
image = reconstruct_2d_image(raw)</code></pre><p>Let&#39;s go through this script step by step.</p><h3 id="Loading-Simulation-Inputs-2"><a class="docs-heading-anchor" href="#Loading-Simulation-Inputs-2">Loading Simulation Inputs</a><a class="docs-heading-anchor-permalink" href="#Loading-Simulation-Inputs-2" title="Permalink"></a></h3><p>(You can also go to <a href="../ui-details/#Loading-Simulation-Inputs">analog steps using UI</a>)</p><p>The inputs of the simulation are created in the following part of the script: </p><pre><code class="language-julia hljs"># Define scanner, object and sequence
sys = Scanner()
obj = brain_phantom2D()
seq = PulseDesigner.EPI_example()</code></pre><h4 id="Scanner-2"><a class="docs-heading-anchor" href="#Scanner-2">Scanner</a><a class="docs-heading-anchor-permalink" href="#Scanner-2" title="Permalink"></a></h4><p>The previously created <strong>Scanner</strong> struct contains default parameters. In your initial simulations, you will likely use this default struct without making any modifications. You can view all the parameters by displaying the struct variable in the <strong>Julia REPL</strong>. The Scanner&#39;s parameters include hardware limitations such as the main magnetic field, maximum gradient values, minimum raster times, and more. You may want to adjust these values for your future custom simulations.</p><pre><code class="language-julia-repl hljs">julia&gt; sys
Scanner
  B0: Float64 1.5
  B1: Float64 1.0e-5
  Gmax: Float64 0.06
  Smax: Int64 500
  ADC_Œît: Float64 2.0e-6
  seq_Œît: Float64 1.0e-5
  GR_Œît: Float64 1.0e-5
  RF_Œît: Float64 1.0e-6
  RF_ring_down_T: Float64 2.0e-5
  RF_dead_time_T: Float64 0.0001
  ADC_dead_time_T: Float64 1.0e-5</code></pre><h4 id="Phantom-2"><a class="docs-heading-anchor" href="#Phantom-2">Phantom</a><a class="docs-heading-anchor-permalink" href="#Phantom-2" title="Permalink"></a></h4><p>The Phantom struct created in this example represents a slice of a brain. To create it, we use the function <code>brain_phantom2D</code>, which is part of the subdependency <strong>KomaMRICore</strong>. While <strong>KomaMRI</strong> provides some phantom examples for experimentation, you may also want to create your custom <strong>Phantom</strong> struct tailored to your specific requirements.</p><p>The <strong>Phantom</strong> struct contains MRI parameters related to the magnetization properties of an object. These parameters include magnetization positions, proton density, relaxation times, off-resonance, among others. To view all the keys and values of the object, you can do so in the <strong>Julia REPL</strong> as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; obj
Phantom{Float64}
  name: String &quot;brain2D_axial&quot;
  x: Array{Float64}((6506,)) [-0.084, -0.084,  ‚Ä¶  0.086, 0.086]
  y: Array{Float64}((6506,)) [-0.03, -0.028,  ‚Ä¶  0.0, 0.002]
  z: Array{Float64}((6506,)) [-0.0, -0.0,  ‚Ä¶  0.0, 0.0]
  œÅ: Array{Float64}((6506,)) [0.7, 0.7,  ‚Ä¶  0.7, 0.7]
  T1: Array{Float64}((6506,)) [0.569, 0.569,  ‚Ä¶  0.569, 0.569]
  T2: Array{Float64}((6506,)) [0.329, 0.329,  ‚Ä¶  0.329, 0.329]
  T2s: Array{Float64}((6506,)) [0.058, 0.058,  ‚Ä¶  0.058, 0.058]
  Œîw: Array{Float64}((6506,)) [-0.0, -0.0,  ‚Ä¶  -0.0, -0.0]
  DŒª1: Array{Float64}((6506,)) [0.0, 0.0,  ‚Ä¶  0.0, 0.0]
  DŒª2: Array{Float64}((6506,)) [0.0, 0.0,  ‚Ä¶  0.0, 0.0]
  DŒ∏: Array{Float64}((6506,)) [0.0, 0.0,  ‚Ä¶  0.0, 0.0]
...</code></pre><p>As you can see, attributes of the <strong>Phantom</strong> struct are vectors representing object properties, with each element holding a value associated with a single magnetization.</p><p>You can also visualize the <strong>Phantom</strong> struct using the <code>plot_phantom_map</code> function, which is part of the <strong>KomaMRIPlots</strong> subdependency. This function plots the magnitude of a property for each magnetization at a specific spatial position. You can observe properties such as proton density and relaxation times, so feel free to replace the <code>:œÅ</code> symbol with another property of the phantom in the example below:</p><pre><code class="language-julia-repl hljs">julia&gt; plot_phantom_map(obj, :œÅ)</code></pre><object type="text/html" data="../assets/phantom-rho.html" style="width:100%; height:620px;"></object><p>To utilize test phantoms included with <strong>KomaMRI</strong>, navigate to the &quot;examples&quot; folder and use the <code>read_phantom_jemris</code> function to read a phantom in <code>.h5</code> format. The following steps outline how to do this in <strong>Julia</strong>:</p><pre><code class="language-julia-repl hljs">julia&gt; path_koma = dirname(dirname(pathof(KomaMRI)))
julia&gt; path_sphere = joinpath(path_koma, &quot;examples&quot;, &quot;2.phantoms&quot;, &quot;sphere_chemical_shift.h5&quot;)
julia&gt; sphere = read_phantom_jemris(path_sphere)
julia&gt; plot_phantom_map(sphere, :T2)</code></pre><object type="text/html" data="../assets/phantom-T2-circle.html" style="width:100%; height:620px;"></object><h4 id="Sequence-2"><a class="docs-heading-anchor" href="#Sequence-2">Sequence</a><a class="docs-heading-anchor-permalink" href="#Sequence-2" title="Permalink"></a></h4><p>The <strong>Sequence</strong> struct in the example represents one of the most basic MRI sequences. It excites the object with a 90¬∞ RF pulse and then uses EPI gradients to fill the k-space in a &quot;square&quot; manner. While you may want to create your sequences for experiments, you can always use some of the examples already available in <strong>KomaMRI</strong>.</p><p>In MRI, the sequence must be carefully designed with precise timing to obtain an image. It includes subcomponents such as gradients, radio-frequency excitation signals, and sample acquisition. For more information on constructing a <strong>Sequence</strong> struct, refer to the <a href="../sequence/">Sequence</a> section.</p><p>You can view general information about a <strong>Sequence</strong> struct by displaying it in the <strong>Julia REPL</strong>:</p><pre><code class="language-julia-repl hljs">julia&gt; seq
Sequence[ œÑ = 62.846 ms | blocks: 204 | ADC: 101 | GR: 205 | RF: 1 | DEF: 5 ]</code></pre><p>For more precise timing checks, you can use the <code>plot_seq</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; plot_seq(seq; range=[0 30])</code></pre><object type="text/html" data="../assets/plot-seq-epi.html" style="width:100%; height:420px;"></object><p>It is important to consider how the sequence traverses through k-space. The <code>plot_kspace</code> function does precisely that:</p><pre><code class="language-julia-repl hljs">julia&gt; plot_kspace(seq)</code></pre><object type="text/html" data="../assets/kspace-epi.html" style="width:100%; height:420px;"></object><p>Additionally, there are helpful sequence construction functions within a submodule of <strong>KomaMRI</strong> called <strong>PulseDesigner</strong>. These functions include <code>RF_hard</code>, <code>RF_sinc</code>, <code>EPI</code>, <code>radial_base</code> and <code>spiral_base</code>. For more details on how to use them, refer to the <a href="../api/">API documentation</a>.</p><p><strong>KomaMRI</strong> is also compatible with <a href="https://pulseq.github.io/">Pulseq</a>. The package installation includes some <code>.seq</code> files in <strong>Pulseq</strong> format, which can be read and used as a <strong>Sequence</strong> struct. Here&#39;s how to read a spiral <strong>Pulseq</strong> file stored in the &quot;examples&quot; folder of <strong>KomaMRI</strong>:</p><pre><code class="language-julia-repl hljs">julia&gt; path_koma = dirname(dirname(pathof(KomaMRI)))
julia&gt; path_spiral = joinpath(path_koma, &quot;examples&quot;, &quot;1.sequences&quot;, &quot;spiral.seq&quot;)
julia&gt; spiral = read_seq(path_spiral)
julia&gt; plot_seq(spiral)
julia&gt; plot_kspace(spiral)</code></pre><object type="text/html" data="../assets/seq-spiral-pulseq-time.html" style="width:50%; height:420px;"></object><object type="text/html" data="../assets/seq-spiral-pulseq-kspace.html" style="width:50%; height:420px;"></object><h3 id="Running-Simulation-2"><a class="docs-heading-anchor" href="#Running-Simulation-2">Running Simulation</a><a class="docs-heading-anchor-permalink" href="#Running-Simulation-2" title="Permalink"></a></h3><p>(You can also go to <a href="../ui-details/#Running-Simulation">analog steps using UI</a>)</p><p>The following lines in the example script configure and perform the simulation:</p><pre><code class="language-julia hljs"># Define simulation parameters and perform simulation
sim_params = KomaMRICore.default_sim_params() 
raw = simulate(obj, seq, sys; sim_params)</code></pre><h4 id="Simulation-Parameters-2"><a class="docs-heading-anchor" href="#Simulation-Parameters-2">Simulation Parameters</a><a class="docs-heading-anchor-permalink" href="#Simulation-Parameters-2" title="Permalink"></a></h4><p>To perform simulations, <strong>KomaMRI</strong> requires certain parameters. You can use the default parameters for testing, but you also have the option to customize specific simulation aspects. In the example, we use the <code>default_sim_params</code> function to create a dictionary with default simulation parameters. You can view the keys that can be modified by displaying the <code>sim_params</code> variable:</p><pre><code class="language-julia-repl hljs">julia&gt; sim_params
Dict{String, Any} with 9 entries:
  &quot;return_type&quot; =&gt; &quot;raw&quot;
  &quot;Nblocks&quot;     =&gt; 20
  &quot;gpu&quot;         =&gt; true
  &quot;Nthreads&quot;    =&gt; 1
  &quot;gpu_device&quot;  =&gt; 0
  &quot;sim_method&quot;  =&gt; Bloch()
  &quot;precision&quot;   =&gt; &quot;f32&quot;
  &quot;Œît&quot;          =&gt; 0.001
  &quot;Œît_rf&quot;       =&gt; 5.0e-5</code></pre><p>All of these parameters deserve special attention. We will explain some of the most important ones here. For instance, <code>&quot;Œît&quot;</code> and <code>&quot;Œît_rf&quot;</code> represent the raster times for the gradients and RFs. <code>&quot;return_type&quot;</code> specifies the type of variable returned by the simulator (by default, it returns an object ready for use with <strong>MRIReco</strong> for reconstruction, but you can use the value <code>&quot;mat&quot;</code> to return a simple vector). <code>&quot;gpu&quot;</code> indicates whether you want to use your GPU device for simulations, and <code>&quot;precision&quot;</code> sets the floating-point precision. For more details on how to set these parameters, please refer to the <a href="../programming-workflow/#Simulation-Parameters">Simulation Parameters Section</a>.</p><h4 id="Raw-Signal"><a class="docs-heading-anchor" href="#Raw-Signal">Raw Signal</a><a id="Raw-Signal-1"></a><a class="docs-heading-anchor-permalink" href="#Raw-Signal" title="Permalink"></a></h4><p>The simulation is performed using the <code>simulate</code> function, which requires three arguments: a <strong>Scanner</strong> struct, a <strong>Phantom</strong> struct, and a <strong>Sequence</strong> struct. Optionally, you can include the keyword argument <code>sim_params</code> if you wish to use custom simulation parameters.</p><p>In the example, we can see that the output of the simulation is a special struct:</p><pre><code class="language-julia-repl hljs">julia&gt; typeof(raw)
RawAcquisitionData

julia&gt; raw
RawAcquisitionData[SeqName: epi | 101 Profile(s) of 101√ó1]</code></pre><p>You can plot the simulation result with the <code>plot_signal</code> function like so:</p><pre><code class="language-julia-repl hljs">julia&gt; plot_signal(raw)</code></pre><object type="text/html" data="../assets/raw-epi-brain-default.html" style="width:100%; height:420px;"></object><h3 id="Reconstructing-Image-using-MRIReco-2"><a class="docs-heading-anchor" href="#Reconstructing-Image-using-MRIReco-2">Reconstructing Image using MRIReco</a><a class="docs-heading-anchor-permalink" href="#Reconstructing-Image-using-MRIReco-2" title="Permalink"></a></h3><p>(You can also go to <a href="../ui-details/#Reconstructing-Image-using-MRIReco">analog steps using UI</a>)</p><p><strong>KomaMRI</strong> does not handle reconstruction; instead, you should utilize the <strong>MRIReco</strong> package to generate an image. For convenience, when you install <strong>KomaMRI</strong>, you also install <strong>MRIReco</strong>, allowing you to access functions from that package. You should pay special attention to the <code>RawAcquisitionData</code> and <code>AcquisitionData</code> structs, as well as the <code>reconstruction</code> function.</p><p>In the example below, we define an auxiliary function, <code>reconstruct_2d_image</code>, which takes a raw signal struct, <code>RawAcquisitionData</code>, as input and returns a 2D Array representing an image. Within this function, we create an <code>AcquisitionData</code> struct and set some reconstruction parameters, which serve as inputs for the <code>reconstruction</code> function. The latter function is responsible for the image generation process.</p><pre><code class="language-julia hljs"># Auxiliary function for reconstruction
function reconstruct_2d_image(raw::RawAcquisitionData)
    acqData = AcquisitionData(raw)
    acqData.traj[1].circular = false #Removing circular window
    C = maximum(2*abs.(acqData.traj[1].nodes[:]))  #Normalize k-space to -.5 to .5 for NUFFT
    acqData.traj[1].nodes = acqData.traj[1].nodes[1:2,:] ./ C
    Nx, Ny = raw.params[&quot;reconSize&quot;][1:2]
    recParams = Dict{Symbol,Any}()
    recParams[:reconSize] = (Nx, Ny)
    recParams[:densityWeighting] = true
    rec = reconstruction(acqData, recParams)
    image3d  = reshape(rec.data, Nx, Ny, :)
    image2d = (abs.(image3d) * prod(size(image3d)[1:2]))[:,:,1]
    return image2d
end

# Perform reconstruction to get the image
image = reconstruct_2d_image(raw)</code></pre><p>If you need more information about how to use the <code>AcquisitionData</code> and the how to fill the reconstruction parameters, you need to visit the <a href="https://github.com/MagneticResonanceImaging/MRIReco.jl">MRIReco webpage</a>).</p><p>To display the image, you can use the <code>plot_image</code> function which is part of the <strong>KomaMRIPlots</strong> subpackage:</p><pre><code class="language-julia-repl hljs">julia&gt; plot_image(image)</code></pre><center><object type="text/html" data="../assets/image-default-brain.html" style="width:100%; height:620px;"></object></center><h3 id="Exporting-Results-to-.mat-File-2"><a class="docs-heading-anchor" href="#Exporting-Results-to-.mat-File-2">Exporting Results to .mat File</a><a class="docs-heading-anchor-permalink" href="#Exporting-Results-to-.mat-File-2" title="Permalink"></a></h3><p>(You can also go to <a href="../ui-details/#Exporting-Results-to-.mat-File">analog steps using UI</a>)</p><p>Many people in the MRI community uses MATLAB, probably you are one of them and you want to process the raw signal in the MATLAB environment after simulation is done with <strong>KomaMRI</strong>. Here we show you an example of how to save a <code>.mat</code> file with the information of the raw signal thank to the help of the <strong>MAT</strong> package:</p><p>Many people in the MRI community use <strong>MATLAB</strong>; you might be one of them and may want to process the <strong>Raw Signal</strong> in the <strong>MATLAB</strong> environment after simulation is completed with <strong>KomaMRI</strong>. Here, we provide an example of how to save a <code>.mat</code> file containing the  <strong>Raw Signal</strong> information using the <strong>MAT</strong> package.</p><pre><code class="language-julia hljs"># Use the MAT package
using MAT

# Perform simulation to return an Array type
sim_params[&quot;return_type&quot;] = &quot;mat&quot;
raw = simulate(obj, seq, sys; sim_params)

# Save the .mat file in the temp directory
matwrite(joinpath(tempdir(), &quot;koma-raw.mat&quot;), Dict(&quot;raw&quot; =&gt; raw))</code></pre><p>Note that we need to simulate to return an array type (not the default <code>RawAcquisitionData</code>), and then we utilize the <code>matwrite</code> function to save a file named &quot;koma-raw.mat&quot; in your computer&#39;s temporary directory. Now, you can navigate to your temporary directory (which you can find by displaying the result of <code>tempdir()</code> in the <strong>Julia REPL</strong>) and locate the &quot;koma-raw.mat&quot; file.</p><h2 id="Notebooks"><a class="docs-heading-anchor" href="#Notebooks">Notebooks</a><a id="Notebooks-1"></a><a class="docs-heading-anchor-permalink" href="#Notebooks" title="Permalink"></a></h2><p>You can use <strong>KomaMRI</strong> with popular programming environments such as <strong>Pluto</strong> and <strong>Jupyter</strong> notebooks. The following sections show how to set up these notebooks and test <strong>KomaMRI</strong> with them.</p><h3 id="Using-KomaMRI-with-Pluto"><a class="docs-heading-anchor" href="#Using-KomaMRI-with-Pluto">Using KomaMRI with Pluto</a><a id="Using-KomaMRI-with-Pluto-1"></a><a class="docs-heading-anchor-permalink" href="#Using-KomaMRI-with-Pluto" title="Permalink"></a></h3><p>First, install the <strong>Pluto</strong> module in your <strong>Julia</strong> environment. Remember to press the <code>]</code> button to open the <strong>Package Manager Session</strong>:&quot;</p><pre><code class="language-julia-repl hljs">julia&gt;

@(1.9) pkg&gt; add Pluto</code></pre><p>Afterward, return to the <strong>Julia Session</strong> by pressing the <code>backspace</code> button, and then execute the <code>Pluto.run()</code> function:</p><pre><code class="nohighlight hljs">julia&gt; using Pluto

julia&gt; Pluto.run()</code></pre><p>This should automatically open the <strong>Pluto</strong> dashboard in your default web browser:</p><center><img src="../assets/pluto-dashboard.png" alt="" style="width:75%;"></center><p>Next, create a new notebook by clicking on <code>+ Create a new notebook</code>:</p><center><img src="../assets/pluto-empty-notebook.png" alt="" style="width:75%;"></center><p>Write and run the following code, which is identical to the <a href="#Free-Induction-Decay">Free Induction Decay example</a>. <strong>Pluto</strong> automatically installs the required modules if they are not present on your system. Additionally, note that we do not use <strong>KomaMRI</strong> directly since we won&#39;t be utilizing the <code>KomaUI()</code> function. Instead, we rely on the <strong>KomaMRICore</strong> and <strong>KomaMRIPlots</strong> dependencies. To display plots in <strong>Pluto</strong>, ensure that you import the <strong>PlutoPlots</strong> package:&quot;</p><embed type="text/html" src="../assets/pluto-fid-example.html" style="height:1024px;width:100%;"><h3 id="Using-KomaMRI-with-Jupyter"><a class="docs-heading-anchor" href="#Using-KomaMRI-with-Jupyter">Using KomaMRI with Jupyter</a><a id="Using-KomaMRI-with-Jupyter-1"></a><a class="docs-heading-anchor-permalink" href="#Using-KomaMRI-with-Jupyter" title="Permalink"></a></h3><p>Ensure you have <strong>Jupyter</strong> installed on your computer. Follow <a href="https://test-jupyter.readthedocs.io/en/latest/install.html">this tutorial</a> for installation using <strong>Anaconda</strong>.</p><p>Next, install the <strong>IJulia</strong> module in your <strong>Julia</strong> environment. Remember to press the <code>]</code> key to open the <strong>Package Manager Session</strong>:</p><pre><code class="language-julia-repl hljs">julia&gt;

(@v1.9) pkg&gt; add IJulia</code></pre><p>For this example, make sure to install <strong>KomaMRICore</strong> and <strong>KomaMRIPlots</strong> (we do not use <strong>KomaMRI</strong> directly since we won&#39;t be utilizing the <code>KomaUI()</code> function):</p><pre><code class="language-julia-repl hljs">(@v1.9) pkg&gt; add KomaMRICore

(@v1.9) pkg&gt; add KomaMRIPlots</code></pre><p>Next, open <strong>Jupyter</strong>, navigate to a working folder, and create a new notebook by clicking on <code>New</code>, then <code>Julia 1.9.3</code>.&quot;</p><center><img src="../assets/jupyter-create-new-notebook.png" alt="" style="width:75%;"></center><p>A new, empty notebook will appear:</p><center><img src="../assets/jupyter-empty-notebook.png" alt="" style="width:75%;"></center><p>Proceed to write and execute the provided example:</p><details><summary>View code</summary><pre><code class="language-julia hljs"># Import modules
using KomaMRICore, KomaMRIPlots

# Define sequence
ampRF = 2e-6                        # 2 uT RF amplitude
durRF = œÄ / 2 / (2œÄ * Œ≥ * ampRF)    # required duration for a 90 deg RF pulse
exc = RF(ampRF, durRF)

nADC = 8192         # number of acquisition samples
durADC = 250e-3     # duration of the acquisition
delay =  1e-3       # small delay
acq = ADC(nADC, durADC, delay)

seq = Sequence()  # empty sequence
seq += exc        # adding RF-only block
seq += acq        # adding ADC-only block

# Plot the sequence
plot_seq(seq; slider=false, height=300)</code></pre></details><center><img src="../assets/jupyter-test-notebook.png" alt="" style="width:100%;"></center><p>This should be sufficient, and now you can start working with <strong>KomaMRI</strong> using <strong>Jupyter</strong> notebooks.</p><p>If you encounter the issue of <strong>WebIO</strong> not being detected:</p><center><img src="../assets/jupyter-webio-problem.png" alt="" style="width:75%;"></center><p>Refer to this <a href="https://juliagizmos.github.io/WebIO.jl/stable/troubleshooting/not-detected/">troubleshooting guide</a> for details. Essentially, you need to install a <strong>WebIO</strong> extension based on your <strong>Jupyter</strong> installation.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 10 April 2024 14:17">Wednesday 10 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
